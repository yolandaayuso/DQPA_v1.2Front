{"version":3,"file":"react-split-text.cjs.production.min.js","sources":["../src/components/Wrappers.tsx","../src/components/SplitTextInner.tsx","../src/components/SplitText.tsx","../src/utils.ts"],"sourcesContent":["import React from 'react';\n\nexport interface LineWrapperProp<T = any> {\n  /**\n   * The current index of the line.\n   */\n  lineIndex: number;\n  /**\n   * Extra props forwarded from SplitText.\n   */\n  extraProps?: T;\n}\n\nexport const LineWrapper: React.FC<LineWrapperProp> = ({ children }) => (\n  <div>{children}</div>\n);\n\nexport interface WordWrapperProp<T = any> {\n  /**\n   * The current line index where the word wrapper lives.\n   */\n  lineIndex: number;\n  /**\n   * The current index of the word.\n   */\n  wordIndex: number;\n  /**\n   * The current index of the total wrapped words inside <SplitText />.\n   */\n  countIndex: number;\n  /**\n   * Extra props forwarded from SplitText.\n   */\n  extraProps?: T;\n}\n\nexport const WordWrapper: React.FC<WordWrapperProp> = ({ children }) => (\n  <span style={{ whiteSpace: 'pre' }}>{children}</span>\n);\n\nexport interface LetterWrapperProp<T = any> {\n  /**\n   * The current line index where the letter wrapper lives.\n   */\n  lineIndex: number;\n  /**\n   * The current word index where the letter wrapper lives.\n   */\n  wordIndex: number;\n  /**\n   * The current index of the letter.\n   */\n  letterIndex: number;\n  /**\n   * The current index of the total wrapped letters inside <SplitText />.\n   */\n  countIndex: number;\n  /**\n   * Extra props forwarded from SplitText.\n   */\n  extraProps?: T;\n}\n\nexport const LetterWrapper: React.FC<LetterWrapperProp> = ({ children }) => (\n  <span>{children}</span>\n);\n","import React, {\n  useRef,\n  useLayoutEffect,\n  useState,\n  memo,\n  FC,\n  forwardRef,\n  MutableRefObject,\n} from 'react';\nimport { LineWrapper, WordWrapper, LetterWrapper } from './Wrappers';\nimport { SplitTextProps } from './SplitText';\n\nconst DefaultLineWrapper = memo(LineWrapper);\nconst DefaultWordWrapper = memo(WordWrapper);\nconst DefaultLetterWrapper = memo(LetterWrapper);\n\nexport const SplitTextInner: FC<SplitTextProps> = forwardRef(\n  function SplitTextInner(\n    {\n      children,\n      className,\n      style,\n      LineWrapper = DefaultLineWrapper,\n      WordWrapper = DefaultWordWrapper,\n      LetterWrapper = DefaultLetterWrapper,\n      extraProps,\n    },\n    ref\n  ) {\n    let text = '';\n    React.Children.map(children, child => {\n      if (typeof child === 'string' || typeof child === 'number') {\n        text += String(child);\n      } else {\n        throw new Error(`SplitText expect a text as children`);\n      }\n    });\n\n    const elRef = useRef<HTMLDivElement | null>(null);\n    const [lines, setLines] = useState<string[]>([]);\n    const maxCharPerLine = useRef<number>(0);\n\n    function makeLines() {\n      const el = elRef.current;\n      if (!el) return;\n\n      if (lines.length > 0) {\n        return refreshLines(lines, text);\n      }\n\n      let lastY;\n      let newLines: string[] = [];\n      let words: string[] = [];\n      for (const child of Array.from(el.children)) {\n        const y = child.getBoundingClientRect().top;\n        if (lastY == null) lastY = y;\n        if (y !== lastY) {\n          newLines.push(words.join(' '));\n          words = [];\n        }\n        lastY = y;\n        words.push((child.textContent || '').trim());\n      }\n      newLines.push(words.join(' '));\n      setLines(newLines);\n    }\n\n    function refreshLines(previous: string[], newText: string) {\n      const charPerLine =\n        maxCharPerLine.current ||\n        previous.map(line => line.length).sort((a, b) => b - a)[0];\n      const lines: string[] = [];\n      let line: string = '';\n      let charCount = 0;\n      const words = newText.split(' ');\n      for (const [i, word] of words.entries()) {\n        charCount += word.length + 1;\n        if (charCount > charPerLine + 1) {\n          lines.push(line);\n          line = '';\n          charCount = 0;\n        }\n        line += word.trim() + ' ';\n      }\n      lines.push(line);\n      setLines(lines.map(line => line.trim()));\n      if (charPerLine > maxCharPerLine.current) {\n        maxCharPerLine.current = charPerLine;\n      }\n    }\n\n    useLayoutEffect(() => makeLines(), [text]);\n\n    let wordCount = 0;\n    let letterCount = 0;\n\n    return lines.length ? (\n      <div\n        className={className}\n        ref={div => {\n          elRef.current = div;\n          if (typeof ref == 'function') {\n            ref(div);\n          } else if (ref) {\n            (ref as MutableRefObject<HTMLDivElement | null>).current = div;\n          }\n        }}\n        style={style}\n      >\n        {lines.map((line, i) => {\n          let words = line.split(' ');\n          words = words.map((word, i) =>\n            i === words.length - 1 ? word : word + ' '\n          );\n          return (\n            <LineWrapper key={i} lineIndex={i} extraProps={extraProps}>\n              {words.map((word, j) => {\n                const letters = word.split('');\n                return (\n                  <WordWrapper\n                    key={j}\n                    lineIndex={i}\n                    wordIndex={j}\n                    countIndex={wordCount++}\n                    extraProps={extraProps}\n                  >\n                    {letters.map((char, k) => (\n                      <LetterWrapper\n                        key={k}\n                        lineIndex={i}\n                        wordIndex={j}\n                        letterIndex={k}\n                        countIndex={letterCount++}\n                        extraProps={extraProps}\n                      >\n                        {char}\n                      </LetterWrapper>\n                    ))}\n                  </WordWrapper>\n                );\n              })}\n            </LineWrapper>\n          );\n        })}\n      </div>\n    ) : (\n      <div className={className} ref={elRef} style={style}>\n        {text.split(' ').map((word, i) => (\n          <span key={i}>{word} </span>\n        ))}\n      </div>\n    );\n  }\n);\n","import React, {\n  useState,\n  ComponentType,\n  CSSProperties,\n  FC,\n  useEffect,\n  forwardRef,\n  useCallback,\n} from 'react';\nimport {\n  LineWrapperProp,\n  WordWrapperProp,\n  LetterWrapperProp,\n} from './Wrappers';\nimport { SplitTextInner } from './SplitTextInner';\nimport { debounce } from '../utils';\n\nexport interface SplitTextProps<T = any> {\n  /**\n   * className to forward to the container.\n   * @type string\n   */\n  className?: string;\n  /**\n   * A style object to forward to the container.\n   * @type CSSProperties\n   */\n  style?: CSSProperties;\n  /**\n   * A React ref to forward to the container.\n   * @type A React ref\n   */\n  ref?: ((instance: unknown) => void) | React.MutableRefObject<unknown> | null;\n  /**\n   * A custom component to wrap each split line.\n   * @type ComponentType<LineWrapperProp>\n   */\n  LineWrapper?: ComponentType<LineWrapperProp>;\n  /**\n   * A custom component to wrap each split word.\n   * @type ComponentType<WordWrapperProp>\n   */\n  WordWrapper?: ComponentType<WordWrapperProp>;\n  /**\n   * A custom component to wrap each split letter.\n   * @type ComponentType<LetterWrapperProp>\n   */\n  LetterWrapper?: ComponentType<LetterWrapperProp>;\n  /**\n   * An extra value that will be forwarded to each wrappers.\n   * @type T = any\n   */\n  extraProps?: T;\n}\n\nexport const SplitText: FC<SplitTextProps> = forwardRef(function SplitText(\n  { children, ...props },\n  ref\n) {\n  const [key, setKey] = useState(0);\n\n  const onResize = debounce(() => setKey(v => v + 1), 300);\n\n  useEffect(() => {\n    window.addEventListener('resize', onResize);\n    return () => window.removeEventListener('resize', onResize);\n  }, []);\n\n  return (\n    <SplitTextInner key={key} {...props} ref={ref}>\n      {children}\n    </SplitTextInner>\n  );\n});\n","export function debounce(callback: Function, wait: number, immediate = false) {\n  let timeout: NodeJS.Timeout;\n\n  return function(this: any, ...args: any[]) {\n    const callNow = immediate && !timeout;\n    const next = () => callback.apply(this, args);\n\n    clearTimeout(timeout);\n    timeout = setTimeout(next, wait);\n\n    if (callNow) {\n      next();\n    }\n  };\n}\n"],"names":["LineWrapper","React","children","WordWrapper","style","whiteSpace","LetterWrapper","DefaultLineWrapper","memo","DefaultWordWrapper","DefaultLetterWrapper","SplitTextInner","forwardRef","ref","className","extraProps","text","Children","map","child","Error","String","elRef","useRef","useState","lines","setLines","maxCharPerLine","useLayoutEffect","el","current","length","previous","newText","charPerLine","line","sort","a","b","charCount","split","entries","i","word","push","trim","refreshLines","lastY","newLines","words","Array","from","y","getBoundingClientRect","top","join","textContent","makeLines","wordCount","letterCount","div","key","lineIndex","j","letters","wordIndex","countIndex","char","k","letterIndex","SplitText","callback","immediate","timeout","props","setKey","onResize","v","args","callNow","next","apply","_this","clearTimeout","setTimeout","useEffect","window","addEventListener","removeEventListener"],"mappings":"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"}