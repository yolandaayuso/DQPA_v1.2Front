/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { __extends, __values } from "tslib";
import { Base, fromEnum, Number_$type, Point_$type, markType } from "igniteui-react-core";
import { PointCollection } from "igniteui-react-core";
import { List$1 } from "igniteui-react-core";
import { PathGeometry } from "igniteui-react-core";
import { PolyLineSegment } from "igniteui-react-core";
import { PathFigure } from "igniteui-react-core";
import { PathFigureCollection } from "igniteui-react-core";
import { FastFlattener } from "igniteui-react-core";
import { ArrayAccessHelper } from "igniteui-react-core";
import { isNaN_ } from "igniteui-react-core";
/**
 * @hidden
 */
var CategoryLineRasterizer = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(CategoryLineRasterizer, _super);
    function CategoryLineRasterizer() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.a = false;
        _this.n = new PointCollection(0);
        return _this;
    }
    Object.defineProperty(CategoryLineRasterizer.prototype, "o", {
        get: function () {
            return this.n;
        },
        set: function (a) {
            this.n = a;
        },
        enumerable: false,
        configurable: true
    });
    CategoryLineRasterizer.prototype.m = function (a, b, c, d, e, f, g, h, i, j) {
        var k = new PathGeometry();
        var l = new PathGeometry();
        var m = new PathGeometry();
        a.an = k;
        b.an = l;
        c.an = m;
        k.c = new PathFigureCollection();
        l.c = new PathFigureCollection();
        m.c = new PathFigureCollection();
        var n = new List$1(PolyLineSegment.$, 0);
        var o = new List$1(PolyLineSegment.$, 0);
        var p = new List$1(PolyLineSegment.$, 0);
        var q = new List$1(PolyLineSegment.$, 0);
        if (g == 0 || g == 1) {
            var r = g == 1 ? h : null;
            var s = 0;
            for (var t = 0; t < d; t++) {
                if (isNaN_(e._inner[t][1])) {
                    var u = t - s;
                    var v = (g == 0 && u > 0) || (g == 1 && u > 1);
                    if (v) {
                        if (g == 1 || n.count == 0) {
                            var w = new PolyLineSegment();
                            var x = new PolyLineSegment();
                            var y = new PolyLineSegment();
                            var z = new PolyLineSegment();
                            n.add(w);
                            o.add(x);
                            p.add(y);
                            q.add(z);
                        }
                        this.l(n._inner[n.count - 1]._points, o._inner[o.count - 1]._points, p._inner[p.count - 1]._points, q._inner[q.count - 1]._points, s, t - 1, e, f, r, i, j);
                    }
                    s = t + 1;
                }
            }
            if (g == 1 || n.count == 0) {
                var aa = new PolyLineSegment();
                var ab = new PolyLineSegment();
                var ac = new PolyLineSegment();
                var ad = new PolyLineSegment();
                n.add(aa);
                o.add(ad);
                p.add(ab);
                q.add(ac);
            }
            this.l(n._inner[n.count - 1]._points, o._inner[o.count - 1]._points, p._inner[p.count - 1]._points, q._inner[q.count - 1]._points, s, d - 1, e, f, r, i, j);
            if (r == null && n.count == 1 && h != null) {
                this.d(n._inner[0], h);
                if (o.count == 1) {
                    this.d(o._inner[0], h);
                }
            }
        }
        else {
            n.add(new PolyLineSegment());
            o.add(new PolyLineSegment());
            p.add(new PolyLineSegment());
            q.add(new PolyLineSegment());
            this.k(n._inner[0]._points, o._inner[0]._points, p._inner[0]._points, q._inner[0]._points, d, e, f, h, i, j);
        }
        var _loop_1 = function (ae) {
            var e_1, _a;
            var af = n._inner[ae];
            var ag = o._inner[ae];
            var ah = p._inner[ae];
            var ai = q._inner[ae];
            if (af._points.count > 0) {
                var aj = ((function () {
                    var $ret = new PathFigure();
                    $ret.startPoint = af._points._inner[0];
                    return $ret;
                })());
                aj._segments.add(af);
                k.c.add(aj);
            }
            if (ag._points.count > 0) {
                var ak = ((function () {
                    var $ret = new PathFigure();
                    $ret.startPoint = ag._points._inner[0];
                    return $ret;
                })());
                ak._segments.add(ag);
                m.c.add(ak);
            }
            if (ah._points.count > 0 && ai._points.count > 0) {
                var al_1 = new PolyLineSegment();
                if (h != null) {
                    var am = h.f;
                    h.f = true;
                    h.i = al_1._points;
                    h.k(ah._points, false);
                    h.k(ai._points, true);
                    h.i = null;
                    h.f = am;
                }
                else {
                    try {
                        for (var _b = (e_1 = void 0, __values(fromEnum(ah._points))), _c = _b.next(); !_c.done; _c = _b.next()) {
                            var an = _c.value;
                            al_1._points.add(an);
                        }
                    }
                    catch (e_1_1) {
                        e_1 = { error: e_1_1 };
                    }
                    finally {
                        try {
                            if (_c && !_c.done && (_a = _b.return))
                                _a.call(_b);
                        }
                        finally {
                            if (e_1)
                                throw e_1.error;
                        }
                    }
                    for (var ao = ai._points.count - 1; ao >= 0; ao--) {
                        al_1._points.add(ai._points._inner[ao]);
                    }
                }
                if (al_1._points.count > 0) {
                    var ap = ((function () {
                        var $ret = new PathFigure();
                        $ret.startPoint = al_1._points._inner[0];
                        return $ret;
                    })());
                    ap._segments.add(al_1);
                    l.c.add(ap);
                }
            }
        };
        for (var ae = 0; ae < n.count; ae++) {
            _loop_1(ae);
        }
    };
    CategoryLineRasterizer.prototype.d = function (a, b) {
        var c = a._points;
        a._points = new PointCollection(0);
        b.i = a._points;
        b.k(c, false);
        b.i = null;
    };
    CategoryLineRasterizer.prototype.k = function (a, b, c, d, e, f, g, h, i, j) {
        this.l(a, b, c, d, 0, e - 1, f, g, h, i, j);
    };
    CategoryLineRasterizer.prototype.e = function (a, b, c, d, e, f, g) {
        var h = FastFlattener.a(new List$1(Number_$type, 0), d, e, f, b, c, g);
        var i = ArrayAccessHelper.c(h);
        var j = ArrayAccessHelper.a(d);
        var k = i != null;
        var l = j != null;
        var m = 0;
        var n = h.count;
        var o;
        var p;
        var q;
        if (e) {
            for (var r = 0; r < n; r++) {
                m = k ? i[r] : h.item(r);
                o = l ? j[m] : d._inner[m];
                p = o[0];
                q = o[1];
                var s = { $type: Point_$type, x: p, y: q };
                a.add(s);
            }
        }
        else if (f) {
            for (var t = 0; t < n; t++) {
                m = k ? i[t] : h.item(t);
                o = l ? j[m] : d._inner[m];
                p = o[0];
                q = o[2];
                var u = { $type: Point_$type, x: p, y: q };
                a.add(u);
            }
        }
        else {
            for (var v = 0; v < n; v++) {
                m = k ? i[v] : h.item(v);
                o = l ? j[m] : d._inner[m];
                p = o[2];
                q = o[3];
                var w = { $type: Point_$type, x: p, y: q };
                a.add(w);
            }
        }
    };
    CategoryLineRasterizer.prototype.b = function (a, b, c, d) {
        c.i = a;
        c.k(b, false);
        c.i = null;
    };
    CategoryLineRasterizer.prototype.c = function (a, b, c, d, e) {
        var f = c.f;
        c.f = e;
        this.b(a, b, c, d);
        c.f = f;
    };
    CategoryLineRasterizer.prototype.l = function (a, b, c, d, e, f, g, h, i, j, k) {
        if (f > -1) {
            if (j == 1 && !this.a) {
                var l = new PointCollection(0);
                this.e(l, e, f, g, true, h, k);
                if (i != null) {
                    this.b(a, l, i, k);
                }
                else {
                    this.f(a, l);
                }
            }
            else {
                var m = new PointCollection(0);
                var n = new PointCollection(0);
                this.e(m, e, f, g, true, h, k);
                this.e(n, e, f, g, false, h, k);
                this.f(c, m);
                this.f(d, n);
                if (i != null) {
                    this.b(a, m, i, k);
                    this.b(b, n, i, k);
                }
                else {
                    this.f(a, m);
                    this.f(b, n);
                }
            }
        }
    };
    CategoryLineRasterizer.prototype.i = function (a, b, c, d, e, f, g, h, i, j, k) {
        this.j(a, b, c, d, e, f, g, h, i, j, k, null);
    };
    CategoryLineRasterizer.prototype.j = function (a, b, c, d, e, f, g, h, i, j, k, l) {
        var m = new PathGeometry();
        var n = new PathGeometry();
        var o = new PathGeometry();
        var p = new PathGeometry();
        a.an = m;
        b.an = n;
        c.an = o;
        d.an = p;
        m.c = new PathFigureCollection();
        n.c = new PathFigureCollection();
        o.c = new PathFigureCollection();
        p.c = new PathFigureCollection();
        var q = new List$1(PolyLineSegment.$, 0);
        var r = new List$1(PolyLineSegment.$, 0);
        var s = new List$1(PolyLineSegment.$, 0);
        var t = new List$1(PolyLineSegment.$, 0);
        if (k == 0 || k == 1) {
            var u = k == 1 ? l : null;
            var v = 0;
            for (var w = 0; w < e; w++) {
                if (isNaN_(f._inner[w][1])) {
                    var x = w - v;
                    var y = (k == 0 && x > 0) || (k == 1 && x > 1);
                    if (y) {
                        if (k == 1 || r.count == 0) {
                            var z = new PolyLineSegment();
                            var aa = new PolyLineSegment();
                            var ab = new PolyLineSegment();
                            var ac = new PolyLineSegment();
                            q.add(z);
                            r.add(aa);
                            s.add(ab);
                            t.add(ac);
                        }
                        var ad = void 0;
                        var ae = void 0;
                        var af = void 0;
                        var ag = void 0;
                        if (l != null && k == 1) {
                            ad = new PointCollection(0);
                            ae = new PointCollection(0);
                            af = new PointCollection(0);
                            ag = new PointCollection(0);
                        }
                        else {
                            ad = q._inner[q.count - 1]._points;
                            ae = r._inner[r.count - 1]._points;
                            af = s._inner[s.count - 1]._points;
                            ag = t._inner[t.count - 1]._points;
                        }
                        this.g(ad, ae, af, ag, v, w - 1, f, g, null, h, i);
                        if (k == 1) {
                            j(ad, ae, af, ag, false);
                            if (l != null) {
                                this.c(q._inner[q.count - 1]._points, ad, l, i, true);
                                this.c(r._inner[r.count - 1]._points, ae, l, i, false);
                                this.c(s._inner[s.count - 1]._points, af, l, i, true);
                                this.c(t._inner[t.count - 1]._points, ag, l, i, false);
                            }
                        }
                    }
                    v = w + 1;
                }
            }
            if (k == 1 || r.count == 0) {
                var ah = new PolyLineSegment();
                var ai = new PolyLineSegment();
                var aj = new PolyLineSegment();
                var ak = new PolyLineSegment();
                q.add(ah);
                r.add(ai);
                s.add(aj);
                t.add(ak);
            }
            var al = void 0;
            var am = void 0;
            var an = void 0;
            var ao = void 0;
            if (l != null) {
                al = new PointCollection(0);
                this.f(al, q._inner[q.count - 1]._points);
                am = new PointCollection(0);
                this.f(am, r._inner[r.count - 1]._points);
                an = new PointCollection(0);
                this.f(an, s._inner[s.count - 1]._points);
                ao = new PointCollection(0);
                this.f(ao, t._inner[t.count - 1]._points);
                q._inner[q.count - 1]._points.clear();
                r._inner[r.count - 1]._points.clear();
                s._inner[s.count - 1]._points.clear();
                t._inner[t.count - 1]._points.clear();
            }
            else {
                al = q._inner[q.count - 1]._points;
                am = r._inner[r.count - 1]._points;
                an = s._inner[s.count - 1]._points;
                ao = t._inner[t.count - 1]._points;
            }
            this.g(al, am, an, ao, v, e - 1, f, g, null, h, i);
            j(al, am, an, ao, true);
            if (l != null) {
                this.c(q._inner[q.count - 1]._points, al, l, i, true);
                this.c(r._inner[r.count - 1]._points, am, l, i, false);
                this.c(s._inner[s.count - 1]._points, an, l, i, true);
                this.c(t._inner[t.count - 1]._points, ao, l, i, false);
            }
        }
        else {
            q.add(new PolyLineSegment());
            r.add(new PolyLineSegment());
            s.add(new PolyLineSegment());
            t.add(new PolyLineSegment());
            this.h(q._inner[0]._points, r._inner[0]._points, s._inner[0]._points, t._inner[0]._points, 0, e - 1, f, g, h, i);
            j(q._inner[0]._points, r._inner[0]._points, s._inner[0]._points, t._inner[0]._points, true);
        }
        var _loop_2 = function (ap) {
            var aq = q._inner[ap];
            var ar = r._inner[ap];
            var as = s._inner[ap];
            var at = t._inner[ap];
            if (aq._points.count > 0) {
                var au = ((function () {
                    var $ret = new PathFigure();
                    $ret.startPoint = aq._points._inner[0];
                    return $ret;
                })());
                au._segments.add(aq);
                m.c.add(au);
            }
            if (ar._points.count > 0) {
                var av = ((function () {
                    var $ret = new PathFigure();
                    $ret.startPoint = ar._points._inner[0];
                    return $ret;
                })());
                av._segments.add(ar);
                n.c.add(av);
            }
            if (as._points.count > 0) {
                var aw = ((function () {
                    var $ret = new PathFigure();
                    $ret.startPoint = as._points._inner[0];
                    return $ret;
                })());
                aw._segments.add(as);
                o.c.add(aw);
            }
            if (at._points.count > 0) {
                var ax = ((function () {
                    var $ret = new PathFigure();
                    $ret.startPoint = at._points._inner[0];
                    return $ret;
                })());
                ax._segments.add(at);
                p.c.add(ax);
            }
        };
        for (var ap = 0; ap < r.count; ap++) {
            _loop_2(ap);
        }
    };
    CategoryLineRasterizer.prototype.h = function (a, b, c, d, e, f, g, h, i, j) {
        this.g(a, b, c, d, e, f, g, h, null, i, j);
    };
    CategoryLineRasterizer.prototype.g = function (a, b, c, d, e, f, g, h, i, j, k) {
        this.o.clear();
        if (j == 1 && !this.a) {
            var l = FastFlattener.a(new List$1(Number_$type, 0), g, true, h, e, f, k);
            var m = l.count;
            var n = 0;
            var o = void 0;
            var p = void 0;
            var q = void 0;
            var r = new PointCollection(0);
            for (var s = 0; s < m; s++) {
                n = l.item(s);
                o = g._inner[n];
                p = o[0];
                q = o[1];
                r.add({ $type: Point_$type, x: p, y: q });
            }
            if (i != null) {
                this.c(a, r, i, k, true);
                this.c(d, r, i, k, false);
                this.c(this.o, r, i, k, false);
            }
            else {
                this.f(a, r);
                this.f(d, r);
                this.f(this.o, r);
            }
        }
        else {
            var t = FastFlattener.a(new List$1(Number_$type, 0), g, true, h, e, f, k);
            var u = FastFlattener.a(new List$1(Number_$type, 0), g, false, h, e, f, k);
            var v = t.count;
            var w = u.count;
            var x = 0;
            var y = void 0;
            var z = void 0;
            var aa = void 0;
            var ab = new PointCollection(0);
            var ac = new PointCollection(0);
            for (var ad = 0; ad < v; ad++) {
                x = t.item(ad);
                y = g._inner[x];
                z = y[0];
                aa = y[1];
                ab.add({ $type: Point_$type, x: z, y: aa });
                ac.add({ $type: Point_$type, x: z, y: aa });
            }
            var ae = new PointCollection(0);
            var af = void 0;
            var ag = void 0;
            for (var ah = w - 1; ah >= 0; ah--) {
                x = u.item(ah);
                y = g._inner[x];
                if (h) {
                    af = y[0];
                    ag = y[2];
                }
                else {
                    af = y[2];
                    ag = y[3];
                }
                ae.add({ $type: Point_$type, x: af, y: ag });
                ac.add({ $type: Point_$type, x: af, y: ag });
            }
            if (i != null) {
                this.c(a, ab, i, k, true);
                this.c(b, ab, i, k, false);
                this.c(d, ae, i, k, false);
                this.c(c, ac, i, k, true);
                this.c(this.o, ab, i, k, false);
            }
            else {
                this.f(a, ab);
                this.f(b, ab);
                this.f(d, ae);
                this.f(c, ac);
                this.f(this.o, ab);
            }
        }
    };
    CategoryLineRasterizer.prototype.f = function (a, b) {
        var c = b.count;
        for (var d = 0; d < c; d++) {
            a.add(b._inner[d]);
        }
    };
    CategoryLineRasterizer.$t = markType(CategoryLineRasterizer, 'CategoryLineRasterizer');
    return CategoryLineRasterizer;
}(Base));
export { CategoryLineRasterizer };
