/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { __extends } from "tslib";
import { ScatterBase } from "./ScatterBase";
import { DependencyProperty } from "igniteui-react-core";
import { Point_$type, typeCast, runOn, markType, markDep } from "igniteui-react-core";
import { ScatterFrame } from "./ScatterFrame";
import { ScatterSplineSeriesView } from "./ScatterSplineSeriesView";
import { Defaults } from "./Defaults";
import { Clipper } from "igniteui-react-core";
import { OwnedPoint } from "./OwnedPoint";
import { ScalerParams } from "./ScalerParams";
import { PathGeometry } from "igniteui-react-core";
import { Numeric } from "igniteui-react-core";
import { PropertyMetadata } from "igniteui-react-core";
import { isNaN_ } from "igniteui-react-core";
/**
 * @hidden
 */
var ScatterSplineSeries = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(ScatterSplineSeries, _super);
    function ScatterSplineSeries() {
        var _this = _super.call(this) || this;
        _this.ab = ScatterSplineSeries.$;
        _this.y2 = new ScatterFrame();
        _this.y4 = new ScatterFrame();
        _this.y0 = new ScatterFrame();
        return _this;
    }
    ScatterSplineSeries.prototype.bj = function () {
        return new ScatterSplineSeries();
    };
    ScatterSplineSeries.prototype.get_f0 = function () {
        return true;
    };
    ScatterSplineSeries.prototype.cs = function () {
        return new ScatterSplineSeriesView(this);
    };
    ScatterSplineSeries.prototype.zw = function () {
        return true;
    };
    ScatterSplineSeries.prototype.jk = function () {
        if (!isNaN_(this.jj)) {
            return _super.prototype.jk.call(this);
        }
        return Defaults.x;
    };
    ScatterSplineSeries.prototype.q9 = function (a, b, c, d) {
        _super.prototype.q9.call(this, a, b, c, d);
        switch (b) {
            case ScatterSplineSeries.$$p[0]:
                this.rr(false);
                this.ql();
                break;
        }
    };
    ScatterSplineSeries.prototype.b2 = function () {
        if (this.b3 == 0) {
            return 2;
        }
        else {
            return _super.prototype.b2.call(this);
        }
    };
    ScatterSplineSeries.prototype.abf = function (a, b) {
        var _this = this;
        _super.prototype.abf.call(this, a, b);
        a.m.clear();
        a.u.clear();
        var c = b.by;
        var d = b.bx;
        var e = this.getEffectiveViewport1(b);
        var f = this.id * this.id;
        var g = Math.min(this.zh != null ? this.zh.count : 0, this.zi != null ? this.zi.count : 0);
        var h = new ScalerParams(0, c, d, this.yw.d, e);
        var i = ((function () {
            var $ret = new ScalerParams(0, c, d, _this.yw.e, e);
            $ret.b = _this.iy();
            return $ret;
        })());
        var j = function (k) { return _this.yw.a.el(_this.zh.item(k), h); };
        var k = function (l) { return _this.yw.b.el(_this.zi.item(l), i); };
        var l = ((function () {
            var $ret = new Clipper(0, d, false);
            $ret.i = a.m;
            return $ret;
        })());
        for (var m = 0; m < g;) {
            var n = m;
            ++m;
            while (m < g && this.acn(j, k, n, m) < f) {
                ++m;
            }
            if (g > this.z9) {
                l.j(this.acr(j, k, n, m - 1));
            }
            else {
                var o = new OwnedPoint();
                o.c = { $type: Point_$type, x: j(n), y: k(n) };
                o.a = this.dn.item(n);
                if (!a.u.containsKey(o.a)) {
                    a.u.addItem(o.a, o);
                }
            }
        }
        if (g > this.z9) {
            l.i = null;
        }
    };
    ScatterSplineSeries.prototype.acr = function (a, b, c, d) {
        if (c == d) {
            return { $type: Point_$type, x: a(c), y: b(c) };
        }
        var e = 0;
        var f = 0;
        var g = (d - c + 1);
        for (var h = c; h <= d; ++h) {
            e += a(h);
            f += b(h);
        }
        return { $type: Point_$type, x: e / g, y: f / g };
    };
    ScatterSplineSeries.prototype.acn = function (a, b, c, d) {
        var e = a(d) - a(c);
        var f = b(d) - b(c);
        return e * e + f * f;
    };
    ScatterSplineSeries.prototype.get_zq = function () {
        return true;
    };
    ScatterSplineSeries.prototype.o5 = function (a, b) {
        _super.prototype.o5.call(this, a, b);
        var c = typeCast(ScatterSplineSeriesView.$, b);
        c.c9(false);
    };
    ScatterSplineSeries.prototype.abq = function (a, b) {
        this.o5(false, b);
        _super.prototype.abq.call(this, a, b);
        this.abi(a);
        var c = typeCast(ScatterSplineSeriesView.$, b);
        var d = c.dl;
        this.y9.az(this, this.zv(), runOn(this, this.yp));
        var e = false;
        var f = this.y9.b;
        if (f != null) {
            e = true;
        }
        if (e) {
            this.abb(-1, this.zh.count, b.q);
        }
        this.y9.ad(d, true, false, true, false);
        c.dl.an = new PathGeometry();
        c.dl.an.c = Numeric.h(a.m.count, function (g) { return a.m._inner[g].x; }, function (g) { return a.m._inner[g].y; }, this.aco);
    };
    ScatterSplineSeries.$t = markType(ScatterSplineSeries, 'ScatterSplineSeries', ScatterBase.$);
    ScatterSplineSeries.$$p = markDep(DependencyProperty, PropertyMetadata, ScatterSplineSeries, 'raisePropertyChanged', ['Stiffness:aco:acq', [1, 0.5]]);
    return ScatterSplineSeries;
}(ScatterBase));
export { ScatterSplineSeries };
