/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { __extends, __generator, __values } from "tslib";
import { Base, fromEnum, Number_$type, Point_$type, typeCast, toEnum, markType } from "igniteui-react-core";
import { PathFigure } from "igniteui-react-core";
import { List$1 } from "igniteui-react-core";
import { LineSegment } from "igniteui-react-core";
import { DelegateClipper } from "./DelegateClipper";
import { Flattener } from "igniteui-react-core";
import { GeometryGroup } from "igniteui-react-core";
import { isNaN_ } from "igniteui-react-core";
/**
 * @hidden
 */
var IndicatorRenderer = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(IndicatorRenderer, _super);
    function IndicatorRenderer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    IndicatorRenderer.h = function (a, b, c, d) {
        var e_1, _c;
        var e = new PathFigure();
        var f = IndicatorRenderer.b(a, b, c, d);
        var _loop_1 = function (g) {
            e._segments.add(((function () {
                var $ret = new LineSegment(1);
                $ret.c = g;
                return $ret;
            })()));
        };
        try {
            for (var _d = __values(fromEnum(f)), _e = _d.next(); !_e.done; _e = _d.next()) {
                var g = _e.value;
                _loop_1(g);
            }
        }
        catch (e_1_1) {
            e_1 = { error: e_1_1 };
        }
        finally {
            try {
                if (_e && !_e.done && (_c = _d.return))
                    _c.call(_d);
            }
            finally {
                if (e_1)
                    throw e_1.error;
            }
        }
        e._startPoint = e._segments._inner[0].c;
        return e;
    };
    IndicatorRenderer.g = function (a, b, c, d, e, f, g, h, i, j, k) {
        var l = g.an.c;
        var m = h.an.c;
        if (a > 1) {
            var n = new DelegateClipper(b, c, a, k);
            b = n.c;
            c = n.d;
            a = n.e;
        }
        if (i == 1) {
            var o = new List$1(Number_$type, 0);
            var p = l;
            var q = 0;
            o.add(0);
            for (var r = 0, s = 1; s < a; r = s++) {
                var t = q;
                var u = c(s) - c(r);
                if (d && !isNaN_(u)) {
                    t = Math.sign(u);
                }
                if (t != 0 && t != q) {
                    p.add(IndicatorRenderer.h(o, b, c, j));
                    q = t;
                    p = q == 1 ? m : l;
                    o.clear();
                    o.add(r);
                }
                o.add(s);
            }
            p.add(IndicatorRenderer.h(o, b, c, j));
        }
        else {
            var v = new List$1(Number_$type, 0);
            var w = l;
            var x = 0;
            v.add(0);
            for (var y = 0, z = 1; z < a; y = z++) {
                var aa = x;
                var ab = c(z) - c(y);
                if (d && !isNaN_(ab)) {
                    aa = Math.sign(ab);
                }
                if (aa != 0 && aa != x) {
                    if (v.count > 0) {
                        w.add(IndicatorRenderer.h(v, b, c, j));
                    }
                    x = aa;
                    w = x == 1 ? m : l;
                    v.clear();
                    v.add(y);
                }
                v.add(z);
            }
            if (v.count > 0) {
                w.add(IndicatorRenderer.h(v, b, c, j));
            }
        }
    };
    IndicatorRenderer.e = function (a, b, c, d, e, f, g, h, i, j, k, l, m, n) {
        var o = new List$1(List$1.$.specialize(Point_$type), 0);
        var p = new List$1(List$1.$.specialize(Point_$type), 0);
        var q = new List$1(List$1.$.specialize(Point_$type), 0);
        var r = new List$1(List$1.$.specialize(Point_$type), 0);
        if (a <= 1) {
            n = null;
        }
        k = Math.max(f.top, Math.min(f.bottom, k));
        if (l == 1) {
            var s = new List$1(Number_$type, 0);
            var t = o;
            var u = p;
            var v = 0;
            s.add(0);
            for (var w = 0, x = 1; x < a; w = x++) {
                var y = v;
                var z = c(x) - c(w);
                if (d && !isNaN_(z)) {
                    y = Math.sign(z);
                }
                if (y != 0 && y != v) {
                    if (s.count > 0) {
                        var aa = new List$1(Point_$type, 1, IndicatorRenderer.b(s, b, c, m));
                        var ab = new List$1(Point_$type, 1, aa);
                        ab.add({ $type: Point_$type, x: aa._inner[aa.count - 1].x, y: k });
                        ab.add({ $type: Point_$type, x: aa._inner[0].x, y: k });
                        t.add(aa);
                        u.add(ab);
                    }
                    v = y;
                    t = v == 1 ? q : o;
                    u = v == 1 ? r : p;
                    s.clear();
                    s.add(w);
                }
                s.add(x);
            }
            var ac = new List$1(Point_$type, 1, IndicatorRenderer.b(s, b, c, m));
            var ad = new List$1(Point_$type, 1, ac);
            ad.add({ $type: Point_$type, x: ac._inner[ac.count - 1].x, y: k });
            ad.add({ $type: Point_$type, x: ac._inner[0].x, y: k });
            t.add(ac);
            u.add(ad);
        }
        else {
            var ae = new List$1(Number_$type, 0);
            var af = o;
            var ag = p;
            var ah = 0;
            ae.add(0);
            for (var ai = 0, aj = 1; aj < a; ai = aj++) {
                var ak = ah;
                var al = c(aj) - c(ai);
                if (d && !isNaN_(al)) {
                    ak = Math.sign(al);
                }
                if (ak != 0 && ak != ah) {
                    if (ae.count > 0) {
                        var am = new List$1(Point_$type, 1, IndicatorRenderer.b(ae, b, c, m));
                        var an = new List$1(Point_$type, 1, am);
                        an.add({ $type: Point_$type, x: am._inner[am.count - 1].x, y: k });
                        an.add({ $type: Point_$type, x: am._inner[0].x, y: k });
                        af.add(am);
                        ag.add(an);
                    }
                    ah = ak;
                    af = ah == 1 ? q : o;
                    ag = ah == 1 ? r : p;
                    ae.clear();
                    ae.add(ai);
                }
                ae.add(aj);
            }
            var ao = new List$1(Point_$type, 1, IndicatorRenderer.b(ae, b, c, m));
            var ap = new List$1(Point_$type, 1, ao);
            ap.add({ $type: Point_$type, x: ao._inner[ao.count - 1].x, y: k });
            ap.add({ $type: Point_$type, x: ao._inner[0].x, y: k });
            af.add(ao);
            ag.add(ap);
        }
        if (n != null) {
            o = new List$1(List$1.$.specialize(Point_$type), 1, IndicatorRenderer.a(List$1.$.specialize(Point_$type), List$1.$.specialize(Point_$type), o, function (aq) { return IndicatorRenderer.c(n, aq, false); }));
            p = new List$1(List$1.$.specialize(Point_$type), 1, IndicatorRenderer.a(List$1.$.specialize(Point_$type), List$1.$.specialize(Point_$type), p, function (aq) { return IndicatorRenderer.c(n, aq, true); }));
            q = new List$1(List$1.$.specialize(Point_$type), 1, IndicatorRenderer.a(List$1.$.specialize(Point_$type), List$1.$.specialize(Point_$type), q, function (aq) { return IndicatorRenderer.c(n, aq, false); }));
            r = new List$1(List$1.$.specialize(Point_$type), 1, IndicatorRenderer.a(List$1.$.specialize(Point_$type), List$1.$.specialize(Point_$type), r, function (aq) { return IndicatorRenderer.c(n, aq, true); }));
        }
        var aq = g.an.c;
        var ar = h.an.c;
        var as = i.an.c;
        var at = j.an.c;
        IndicatorRenderer.d(aq, o);
        IndicatorRenderer.d(ar, p);
        IndicatorRenderer.d(as, q);
        IndicatorRenderer.d(at, r);
    };
    IndicatorRenderer.f = function (a, b, c, d, e, f, g, h, i) {
        var j = typeCast(GeometryGroup.$, h.an);
        var k = typeCast(GeometryGroup.$, i.an);
        var l = c;
        var m = b;
        var n = function (o) { return Math.max(e.left, Math.min(e.right, o)); };
        var o = function (p) { return Math.max(e.top, Math.min(e.bottom, p)); };
        b = function (p) { return n(m(p)); };
        c = function (p) { return o(l(p)); };
        f = o(f);
        for (var p = 0; p < a; ++p) {
            var q = g.item(p);
            q.d = { $type: Point_$type, x: b(p), y: f };
            q.c = { $type: Point_$type, x: b(p), y: c(p) };
            var r = false;
            if (p > 0) {
                if (c(p) <= c(p - 1)) {
                    r = true;
                }
            }
            else {
                if (a > 1) {
                    if (c(p + 1) <= c(p)) {
                        r = true;
                    }
                }
            }
            if (r) {
                j.d.add(q);
            }
            else {
                k.d.add(q);
            }
        }
        g.count = a;
    };
    IndicatorRenderer._b = function (a, b, c, d) {
        var e, f, g;
        return __generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    e = Flattener.a(new List$1(Number_$type, 0), a, b, c, 0, a.count - 1, d);
                    f = 0;
                    _c.label = 1;
                case 1:
                    if (!(f < e.count))
                        return [3 /*break*/, 4];
                    g = e.item(f);
                    return [4 /*yield*/, { $type: Point_$type, x: b(g), y: c(g) }];
                case 2:
                    _c.sent();
                    _c.label = 3;
                case 3:
                    f++;
                    return [3 /*break*/, 1];
                case 4: return [2 /*return*/];
            }
        });
    };
    IndicatorRenderer.b = function (a, b, c, d) {
        return toEnum(function () { return IndicatorRenderer._b(a, b, c, d); });
    };
    IndicatorRenderer.d = function (a, b) {
        var e_2, _c;
        var _loop_2 = function (c) {
            var e_3, _f;
            if (c.count == 0) {
                return "continue";
            }
            var d = ((function () {
                var $ret = new PathFigure();
                $ret.startPoint = c._inner[0];
                return $ret;
            })());
            var _loop_3 = function (e) {
                d._segments.add(((function () {
                    var $ret = new LineSegment(1);
                    $ret.c = e;
                    return $ret;
                })()));
            };
            try {
                for (var _g = (e_3 = void 0, __values(fromEnum(c))), _h = _g.next(); !_h.done; _h = _g.next()) {
                    var e = _h.value;
                    _loop_3(e);
                }
            }
            catch (e_3_1) {
                e_3 = { error: e_3_1 };
            }
            finally {
                try {
                    if (_h && !_h.done && (_f = _g.return))
                        _f.call(_g);
                }
                finally {
                    if (e_3)
                        throw e_3.error;
                }
            }
            a.add(d);
        };
        try {
            for (var _d = __values(fromEnum(b)), _e = _d.next(); !_e.done; _e = _d.next()) {
                var c = _e.value;
                _loop_2(c);
            }
        }
        catch (e_2_1) {
            e_2 = { error: e_2_1 };
        }
        finally {
            try {
                if (_e && !_e.done && (_c = _d.return))
                    _c.call(_d);
            }
            finally {
                if (e_2)
                    throw e_2.error;
            }
        }
    };
    IndicatorRenderer.c = function (a, b, c) {
        var d = a.f;
        a.f = c;
        var e = new List$1(Point_$type, 0);
        a.i = e;
        a.k(b, false);
        a.i = null;
        a.f = d;
        return e;
    };
    IndicatorRenderer._a = function ($tSource, $tResult, a, b) {
        var _c, _d, c, e_4_1;
        var e_4, _e;
        return __generator(this, function (_f) {
            switch (_f.label) {
                case 0:
                    _f.trys.push([0, 5, 6, 7]);
                    _c = __values(fromEnum(a)), _d = _c.next();
                    _f.label = 1;
                case 1:
                    if (!!_d.done)
                        return [3 /*break*/, 4];
                    c = _d.value;
                    return [4 /*yield*/, b(c)];
                case 2:
                    _f.sent();
                    _f.label = 3;
                case 3:
                    _d = _c.next();
                    return [3 /*break*/, 1];
                case 4: return [3 /*break*/, 7];
                case 5:
                    e_4_1 = _f.sent();
                    e_4 = { error: e_4_1 };
                    return [3 /*break*/, 7];
                case 6:
                    try {
                        if (_d && !_d.done && (_e = _c.return))
                            _e.call(_c);
                    }
                    finally {
                        if (e_4)
                            throw e_4.error;
                    }
                    return [7 /*endfinally*/];
                case 7: return [2 /*return*/];
            }
        });
    };
    IndicatorRenderer.a = function ($tSource, $tResult, a, b) {
        return toEnum(function () { return IndicatorRenderer._a($tSource, $tResult, a, b); });
    };
    IndicatorRenderer.$t = markType(IndicatorRenderer, 'IndicatorRenderer');
    return IndicatorRenderer;
}(Base));
export { IndicatorRenderer };
