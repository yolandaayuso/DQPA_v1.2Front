import { __extends } from "tslib";
import { IgrNumericXAxis } from "./igr-numeric-x-axis";
import { IgrCategoryYAxis } from "./igr-category-y-axis";
import { IgrAnchoredCategorySeries } from "./igr-anchored-category-series";
import { toPoint, fromRect, fromPoint } from "igniteui-react-core";
/**
 * Represents a vertically laid out category based series.
*/
var IgrVerticalAnchoredCategorySeries = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(IgrVerticalAnchoredCategorySeries, _super);
    function IgrVerticalAnchoredCategorySeries(props) {
        var _this = _super.call(this, props) || this;
        _this._xAxisName = null;
        _this._yAxisName = null;
        return _this;
    }
    Object.defineProperty(IgrVerticalAnchoredCategorySeries.prototype, "i", {
        /**
                                     * @hidden
                                     */
        get: function () {
            return this._implementation;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrVerticalAnchoredCategorySeries.prototype, "xAxis", {
        /**
         * Gets or sets the effective x-axis for the current CategorySeries object.
        */
        get: function () {
            var r = this.i.xAxis;
            if (r == null) {
                return null;
            }
            if (!r.externalObject) {
                var e = IgrNumericXAxis._createFromInternal(r);
                if (e) {
                    e._implementation = r;
                }
                r.externalObject = e;
            }
            return r.externalObject;
        },
        set: function (v) {
            if (v != null && this._stylingContainer && v._styling)
                v._styling(this._stylingContainer, this, this);
            v == null ? this.i.xAxis = null : this.i.xAxis = v.i;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrVerticalAnchoredCategorySeries.prototype, "xAxisName", {
        /**
        * Gets or sets the name to use to resolve xAxis from markup.
        */
        get: function () {
            return this._xAxisName;
        },
        set: function (v) {
            this._xAxisName = v;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrVerticalAnchoredCategorySeries.prototype, "yAxis", {
        /**
         * Gets or sets the effective y-axis for the current CategorySeries object.
        */
        get: function () {
            var r = this.i.yAxis;
            if (r == null) {
                return null;
            }
            if (!r.externalObject) {
                var e = IgrCategoryYAxis._createFromInternal(r);
                if (e) {
                    e._implementation = r;
                }
                r.externalObject = e;
            }
            return r.externalObject;
        },
        set: function (v) {
            if (v != null && this._stylingContainer && v._styling)
                v._styling(this._stylingContainer, this, this);
            v == null ? this.i.yAxis = null : this.i.yAxis = v.i;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrVerticalAnchoredCategorySeries.prototype, "yAxisName", {
        /**
        * Gets or sets the name to use to resolve yAxis from markup.
        */
        get: function () {
            return this._yAxisName;
        },
        set: function (v) {
            this._yAxisName = v;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrVerticalAnchoredCategorySeries.prototype, "isVertical", {
        /**
         * Gets whether or not the current series is vertical series
        */
        get: function () {
            return this.i.isVertical;
        },
        enumerable: false,
        configurable: true
    });
    IgrVerticalAnchoredCategorySeries.prototype.bindAxes = function (axes) {
        _super.prototype.bindAxes.call(this, axes);
        for (var i = 0; i < axes.length; i++) {
            if (this.xAxisName && this.xAxisName.length > 0 &&
                axes[i].name == this.xAxisName) {
                this.xAxis = axes[i];
            }
        }
        for (var i = 0; i < axes.length; i++) {
            if (this.yAxisName && this.yAxisName.length > 0 &&
                axes[i].name == this.yAxisName) {
                this.yAxis = axes[i];
            }
        }
    };
    IgrVerticalAnchoredCategorySeries.prototype.findByName = function (name) {
        var baseResult = _super.prototype.findByName.call(this, name);
        if (baseResult) {
            return baseResult;
        }
        if (this.xAxis && this.xAxis.name && this.xAxis.name == name) {
            return this.xAxis;
        }
        if (this.yAxis && this.yAxis.name && this.yAxis.name == name) {
            return this.yAxis;
        }
        return null;
    };
    IgrVerticalAnchoredCategorySeries.prototype._styling = function (container, component, parent) {
        _super.prototype._styling.call(this, container, component, parent);
        this._inStyling = true;
        if (this.xAxis && this.xAxis._styling) {
            this.xAxis._styling(container, component, this);
        }
        if (this.yAxis && this.yAxis._styling) {
            this.yAxis._styling(container, component, this);
        }
        this._inStyling = false;
    };
    /**
     * Returns the offset value for this series if grouped on a category axis.
    
    */
    IgrVerticalAnchoredCategorySeries.prototype.getOffsetValue = function () {
        var iv = this.i.getOffsetValue();
        return (iv);
    };
    /**
     * Returns the width of the category grouping this series is in.
    
    */
    IgrVerticalAnchoredCategorySeries.prototype.getCategoryWidth = function () {
        var iv = this.i.getCategoryWidth();
        return (iv);
    };
    IgrVerticalAnchoredCategorySeries.prototype.getNextOrExactIndex = function (world, skipUnknowns) {
        var iv = this.i.j8(toPoint(world), skipUnknowns);
        return (iv);
    };
    IgrVerticalAnchoredCategorySeries.prototype.getPreviousOrExactIndex = function (world, skipUnknowns) {
        var iv = this.i.ka(toPoint(world), skipUnknowns);
        return (iv);
    };
    /**
     * If possible, will return the best available value marker bounding box within the series that has the best value match for the world position provided.
    
    * @param world  * The world coordinates for which to get a value marker bounding box for
    */
    IgrVerticalAnchoredCategorySeries.prototype.getSeriesValueMarkerBoundingBox = function (world) {
        var iv = this.i.wp(toPoint(world));
        return fromRect(iv);
    };
    IgrVerticalAnchoredCategorySeries.prototype.getSeriesValue = function (world, useInterpolation, skipUnknowns) {
        var iv = this.i.i5(toPoint(world), useInterpolation, skipUnknowns);
        return (iv);
    };
    IgrVerticalAnchoredCategorySeries.prototype.getSeriesValuePosition = function (world, useInterpolation, skipUnknowns) {
        var iv = this.i.wc(toPoint(world), useInterpolation, skipUnknowns);
        return fromPoint(iv);
    };
    /**
     * Gets the precise item index, if possible, based on the closeness to the previous or next whole integer. If the series cannot provide this information, GetExactItemIndex will return the same integer value as GetItemIndex.
    
    * @param world  * The world position for which to return the index.
    */
    IgrVerticalAnchoredCategorySeries.prototype.getExactItemIndex = function (world) {
        var iv = this.i.ir(toPoint(world));
        return (iv);
    };
    /**
     * Gets the index of the item that resides at the provided world coordinates.
    
    * @param world  * The world coordinates of the requested item.
    */
    IgrVerticalAnchoredCategorySeries.prototype.getItemIndex = function (world) {
        var iv = this.i.j3(toPoint(world));
        return (iv);
    };
    /**
     * Gets the item that is the best match for the specified world coordinates.
    
    * @param world  * The world coordinates to use.
    */
    IgrVerticalAnchoredCategorySeries.prototype.getItem = function (world) {
        var iv = this.i.kn(toPoint(world));
        return (iv);
    };
    /**
     * Determine if object can be used as YAxis
    
    * @param axis  * The object to check
    */
    IgrVerticalAnchoredCategorySeries.prototype.canUseAsYAxis = function (axis) {
        var iv = this.i.aci(axis);
        return (iv);
    };
    /**
     * Determine if object can be used as XAxis
    
    * @param axis  * The object to check
    */
    IgrVerticalAnchoredCategorySeries.prototype.canUseAsXAxis = function (axis) {
        var iv = this.i.ach(axis);
        return (iv);
    };
    return IgrVerticalAnchoredCategorySeries;
}(IgrAnchoredCategorySeries));
export { IgrVerticalAnchoredCategorySeries };
