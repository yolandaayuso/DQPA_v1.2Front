/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { __extends } from "tslib";
import { AxisRendererBase } from "./AxisRendererBase";
import { CategoryAxisRenderingParameters } from "./CategoryAxisRenderingParameters";
import { LinearCategorySnapper } from "./LinearCategorySnapper";
import { typeCast, markType } from "igniteui-react-core";
import { truncate } from "igniteui-react-core";
/**
 * @hidden
 */
var CategoryAxisRenderer = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(CategoryAxisRenderer, _super);
    function CategoryAxisRenderer(a) {
        return _super.call(this, a) || this;
    }
    CategoryAxisRenderer.prototype.ac = function (a, b, c, d, e) {
        var f = typeCast(CategoryAxisRenderingParameters.$, a);
        var g = 0;
        if (f != null) {
            g = f.ac;
        }
        var h = new LinearCategorySnapper(1, a.e.d, a.e.c, a.e.b, a.p, g, a.o);
        b = h.g;
        if (a.e.a != -1) {
            b = a.e.a;
        }
        var i = Math.floor((a.e.d - a.m) / b);
        var j = Math.ceil((a.e.c - a.m) / b);
        d = truncate(i);
        e = truncate(j);
        c = truncate(h.h);
        if (a.e.e != -1) {
            c = a.e.e;
        }
        return {
            p1: b,
            p2: c,
            p3: d,
            p4: e
        };
    };
    CategoryAxisRenderer.prototype.w = function (a, b, c, d) {
        var e = typeCast(CategoryAxisRenderingParameters.$, a);
        if (e == null) {
            return null;
        }
        var f = 0;
        if (d >= 1) {
            f = c * truncate(Math.floor(d));
        }
        else {
            if ((c * d) * 2 % 2 == 0) {
                f = truncate(Math.floor(c * d));
            }
            else {
                f = -1;
            }
        }
        var g = null;
        if ((e.af > 0 && f < e.af && f >= 0) || e.ae) {
            while (f >= e.af && e.ae) {
                f -= e.af;
            }
            g = this.g(f, false);
        }
        return g;
    };
    CategoryAxisRenderer.prototype.ad = function (a, b, c, d, e, f) {
        var g = typeCast(CategoryAxisRenderingParameters.$, a);
        if (g.ac != 0 && g.ag != 0) {
            for (var h = 0; h < truncate(b); h++) {
                for (var i = 0; i < g.ag; i++) {
                    var j = this.f(i, a.ab, a.aa, a.z);
                    if (g.ad) {
                        j = -j;
                    }
                    var k = this.m(a, h + e * b) + j;
                    a.b = a.d;
                    this.k(a, a.w, k);
                    a.b = null;
                }
            }
        }
    };
    CategoryAxisRenderer.$t = markType(CategoryAxisRenderer, 'CategoryAxisRenderer', AxisRendererBase.$);
    return CategoryAxisRenderer;
}(AxisRendererBase));
export { CategoryAxisRenderer };
