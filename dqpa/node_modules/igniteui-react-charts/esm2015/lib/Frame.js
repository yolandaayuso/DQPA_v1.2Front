/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { Base, Point_$type, markType } from "igniteui-react-core";
/**
 * @hidden
 */
export let Frame = /*@__PURE__*/ (() => {
    class Frame extends Base {
        static a(a, b, c, d) {
            let e = c.count;
            let f = d.count;
            let g = Math.max(e, f);
            let h = 1 - b;
            if (a.count < g) {
                a.s(a.count, new Array(g - a.count));
            }
            if (a.count > g) {
                a.v(g, a.count - g);
            }
            for (let i = 0; i < Math.min(e, f); ++i) {
                a._inner[i] = { $type: Point_$type, x: c._inner[i].x * h + d._inner[i].x * b, y: c._inner[i].y * h + d._inner[i].y * b };
            }
            if (e < f) {
                let j = e > 0 ? c._inner[e - 1] : { $type: Point_$type, x: 0, y: 0 };
                for (let k = e; k < f; ++k) {
                    a._inner[k] = { $type: Point_$type, x: j.x * h + d._inner[k].x * b, y: j.y * h + d._inner[k].y * b };
                }
            }
            if (e > f) {
                let l = f > 0 ? d._inner[f - 1] : { $type: Point_$type, x: 0, y: 0 };
                for (let m = f; m < e; ++m) {
                    a._inner[m] = { $type: Point_$type, x: c._inner[m].x * h + l.x * b, y: c._inner[m].y * h + l.y * b };
                }
            }
        }
        static d(a, b, c, d, e) {
            let f = c.count;
            let g = d.count;
            let h = Math.max(f, g);
            let i = 1 - b;
            if (a.count < h) {
                a.s(a.count, new Array(h - a.count));
            }
            if (a.count > h) {
                a.v(h, a.count - h);
            }
            let j;
            let k;
            for (let l = 0; l < Math.min(f, g); ++l) {
                j = b * e._inner[l];
                j = j > 1 ? 1 : j;
                k = 1 - j;
                a._inner[l] = { $type: Point_$type, x: c._inner[l].x * k + d._inner[l].x * j, y: c._inner[l].y * k + d._inner[l].y * j };
            }
            if (f < g) {
                let m = f > 0 ? c._inner[f - 1] : { $type: Point_$type, x: 0, y: 0 };
                for (let n = f; n < g; ++n) {
                    j = b * e._inner[n];
                    j = j > 1 ? 1 : j;
                    k = 1 - j;
                    a._inner[n] = { $type: Point_$type, x: m.x * k + d._inner[n].x * j, y: m.y * k + d._inner[n].y * j };
                }
            }
            if (f > g) {
                let o = g > 0 ? d._inner[g - 1] : { $type: Point_$type, x: 0, y: 0 };
                for (let p = g; p < f; ++p) {
                    j = b * e._inner[p];
                    j = j > 1 ? 1 : j;
                    k = 1 - j;
                    a._inner[p] = { $type: Point_$type, x: c._inner[p].x * k + o.x * j, y: c._inner[p].y * k + o.y * j };
                }
            }
        }
        static b(a, b, c, d) {
            let e = c.count;
            let f = d.count;
            let g = Math.max(e, f);
            let h = 1 - b;
            if (a.count < g) {
                let i = new Array(g - a.count);
                for (let j = 0; j < g - a.count; j++) {
                    i[j] = 0;
                }
                a.s(a.count, i);
            }
            if (a.count > g) {
                a.v(g, a.count - g);
            }
            for (let k = 0; k < Math.min(e, f); ++k) {
                a._inner[k] = c._inner[k] * h + d._inner[k] * b;
            }
            if (e < f) {
                let l = e > 0 ? c._inner[e - 1] : 0;
                for (let m = e; m < f; ++m) {
                    a._inner[m] = l * h + d._inner[m] * b;
                }
            }
            if (e > f) {
                let n = f > 0 ? d._inner[f - 1] : 0;
                for (let o = f; o < e; ++o) {
                    a._inner[o] = c._inner[o] * h + n * b;
                }
            }
        }
        static e(a, b, c, d, e) {
            let f = c.count;
            let g = d.count;
            let h = Math.max(f, g);
            let i = 1 - b;
            if (a.count < h) {
                let j = new Array(h - a.count);
                for (let k = 0; k < h - a.count; k++) {
                    j[k] = 0;
                }
                a.s(a.count, j);
            }
            if (a.count > h) {
                a.v(h, a.count - h);
            }
            let l;
            let m;
            for (let n = 0; n < Math.min(f, g); ++n) {
                l = b * e._inner[n];
                l = l > 1 ? 1 : l;
                m = 1 - l;
                a._inner[n] = c._inner[n] * m + d._inner[n] * l;
            }
            if (f < g) {
                let o = f > 0 ? c._inner[f - 1] : 0;
                for (let p = f; p < g; ++p) {
                    l = b * e._inner[p];
                    l = l > 1 ? 1 : l;
                    m = 1 - l;
                    a._inner[p] = o * m + d._inner[p] * l;
                }
            }
            if (f > g) {
                let q = g > 0 ? d._inner[g - 1] : 0;
                for (let r = g; r < f; ++r) {
                    l = b * e._inner[r];
                    l = l > 1 ? 1 : l;
                    m = 1 - l;
                    a._inner[r] = c._inner[r] * m + q * l;
                }
            }
        }
    }
    Frame.$t = /*@__PURE__*/ markType(Frame, 'Frame');
    return Frame;
})();
