/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { TimeAxisBase } from "./TimeAxisBase";
import { ITimeRangeSelectorAxis_$type } from "./ITimeRangeSelectorAxis";
import { List$1 } from "igniteui-react-core";
import { TimeAxisBreak } from "./TimeAxisBreak";
import { TimeAxisBreakCollection } from "./TimeAxisBreakCollection";
import { TimeAxisLabellingMode_$type } from "./TimeAxisLabellingMode";
import { TimeAxisLabelFormatCollection } from "./TimeAxisLabelFormatCollection";
import { OrderedDictionary$2 } from "./OrderedDictionary$2";
import { TimeAxisInterval } from "./TimeAxisInterval";
import { TimeAxisIntervalCollection } from "./TimeAxisIntervalCollection";
import { EventArgs, runOn, delegateCombine, Number_$type, fromEnum, enumGetBox, fromEn, typeCast, Date_$type, markType } from "igniteui-react-core";
import { ScalerParams } from "./ScalerParams";
import { Rect } from "igniteui-react-core";
import { NumericScaler } from "./NumericScaler";
import { KeyValuePair$2 } from "igniteui-react-core";
import { NumericYAxis } from "./NumericYAxis";
import { LabelPosition } from "./LabelPosition";
import { Extensions } from "igniteui-react-core";
import { SortedListView$1 } from "./SortedListView$1";
import { Dictionary$2 } from "igniteui-react-core";
import { truncate, intDivide, isNaN_ } from "igniteui-react-core";
import { dateFromTicks, dateMaxValue, dateSubtract, dateMinValue, dateGetMonth, dateAddMonths, dateFromValues, dateGetTimeOfDay, dateAddDays, dateAddHours } from "igniteui-react-core";
import { timeSpanTicks, timeSpanInit3, timeSpanInit1, timeSpanFromMilliseconds, timeSpanFromSeconds, timeSpanFromMinutes, timeSpanFromHours, timeSpanFromDays, timeSpanFromTicks, timeSpanTotalMilliseconds } from "igniteui-react-core";
import { dateToStringFormat } from "igniteui-react-core";
/**
 * @hidden
 */
export let TimeXAxis = /*@__PURE__*/ (() => {
    class TimeXAxis extends TimeAxisBase {
        constructor() {
            super();
            this.ol = 0;
            this.nv = null;
            this.n4 = 0;
            this.n2 = null;
            this._omission = 0;
            this.nt = null;
            this.n0 = null;
            this.op = null;
            this.o2 = 0;
            this.od = dateMaxValue();
            this.ob = dateMaxValue();
            this.oa = dateMaxValue();
            this.oc = dateMinValue();
            this.nx = null;
            this.o0 = 0;
            this.visibleRangeChanged = null;
            this.ab = TimeXAxis.$;
            this.omission = (0);
            this.ol = -2147483648;
            this.nv = new TimeAxisBreakCollection();
            let a = this.breaks;
            a.collectionChanged = delegateCombine(a.collectionChanged, runOn(this, this.o5));
            this.n0 = new TimeAxisIntervalCollection();
            let b = this.intervals;
            b.collectionChanged = delegateCombine(b.collectionChanged, runOn(this, this.o6));
            this.n2 = new TimeAxisLabelFormatCollection();
            let c = this.labelFormats;
            c.collectionChanged = delegateCombine(c.collectionChanged, runOn(this, this.o7));
            this.o2 = (0);
        }
        get_cl() {
            return this.breaks != null && this.breaks.count > 0;
        }
        el(a, b) {
            if (!b.c.isEmpty) {
                let c = this.oj(a, NumericScaler.ac, b.c, Rect.empty);
                c = (c - b.d.left) / b.d.width;
                c = b.d.left + b.d.width * (c - b.e.left) / b.e.width;
                return c;
            }
            return this.oj(a, b.e, b.d, b.c);
        }
        oj(a, b, c, d) {
            let e = new KeyValuePair$2(TimeAxisBreak.$, Number_$type);
            let f = this.ol != -2147483648 ? this.ol : 0;
            let g = this.nt != null ? this.nt.count : 0;
            while (f < g) {
                let h = this.nt.item1(f);
                if (h.d.getTime() <= a && h.c.getTime() >= a) {
                    return NaN;
                }
                if (h.c.getTime() <= a) {
                    e = new KeyValuePair$2(TimeAxisBreak.$, Number_$type, 1, h, this.nt.item(h));
                    f++;
                }
                else {
                    break;
                }
            }
            if (f > 0) {
                f -= 1;
            }
            if (this.ol != -2147483648) {
                this.ol = f;
            }
            let i;
            let j;
            if (e.key != null) {
                i = e.value;
                j = e.key.c;
            }
            else {
                i = 0;
                j = this.actualMinimumValue;
            }
            let fromPrecedingBreak_ = +(dateFromTicks(truncate(a))) - +j;
            let k = (fromPrecedingBreak_ / ((this.actualMaximumValue.getTime() - this.actualMinimumValue.getTime()) - this.omission));
            let l = i + k;
            l -= b.left;
            l /= b.width;
            let m = c.left;
            let n = c.right;
            let o = c.width;
            if (this.categoryMode != 0) {
                let p = this.getCategorySize(b, c, d);
                m += p / 2;
                n -= p / 2;
                o -= p;
            }
            if (this.ch) {
                return n - o * l;
            }
            return m + o * l;
        }
        hq(a, b, c, d) {
            this.ol = 0;
            for (let e = b; e < c; e++) {
                a.item(e, this.el(a.item(e), d));
            }
            this.ol = -2147483648;
        }
        startCursor() {
            this.ol = 0;
        }
        resetCursor() {
            this.ol = -2147483648;
        }
        eo(a, b) {
            if (!b.c.isEmpty) {
                let c = b.e.left + b.e.width * (a - b.d.left) / b.d.width;
                c = (c * b.d.width) + b.d.left;
                c = this.getUnscaledValue3(c, NumericScaler.ac, b.c, this.categoryMode);
                return c;
            }
            return this.ok(a, b.e, b.d, b.c);
        }
        ok(a, b, c, d) {
            let e = c.left;
            let f = c.width;
            if (this.categoryMode != 0) {
                let g = this.getCategorySize(b, c, d);
                e += g / 2;
                f -= g;
            }
            let h = b.left + b.width * (a - e) / f;
            if (this.ch) {
                h = 1 - h;
            }
            let i = new KeyValuePair$2(TimeAxisBreak.$, Number_$type);
            if (this.nt != null) {
                for (let j of fromEnum(this.nt)) {
                    if (j.value >= h && j.value <= h) {
                        return j.key.d.getTime();
                    }
                    if (j.value < h && j.value > i.value) {
                        i = j;
                    }
                }
            }
            let precedingBreakEnd_;
            let k;
            if (i.key != null) {
                k = i.value;
                precedingBreakEnd_ = i.key.c;
            }
            else {
                k = 0;
                precedingBreakEnd_ = this.actualMinimumValue;
            }
            let portionFromPrecedingBreak_ = h - k;
            let actualRange_ = +(this.actualMaximumValue) - +(this.actualMinimumValue) - this.omission;
            return (precedingBreakEnd_.getTime() + portionFromPrecedingBreak_ * actualRange_);
        }
        get breaks() {
            return this.nv;
        }
        get n5() {
            return this.n4;
        }
        set n5(a) {
            let b = this.n5;
            if (a != b) {
                this.n4 = a;
                this.h5("LabellingMode", enumGetBox(TimeAxisLabellingMode_$type, b), enumGetBox(TimeAxisLabellingMode_$type, this.n5));
            }
        }
        get labelFormats() {
            return this.n2;
        }
        hz(a, b, c, d) {
            super.hz(a, b, c, d);
            switch (b) {
                case "ActualMaximumValue":
                    this.o4();
                    break;
                case "DateTimeColumn":
                    this.o0 = this.oy();
                    break;
                case "LabellingMode":
                    this.ib(false);
                    break;
            }
        }
        it(a, b) {
            super.it(a, b);
            this.o3();
            this.nn();
        }
        is(a, b) {
            super.is(a, b);
            this.o3();
            this.nn();
        }
        c3() {
            let a = super.c3();
            this.o3();
            return a;
        }
        get omission() {
            return this._omission;
        }
        set omission(a) {
            this._omission = a;
        }
        o4() {
            let a = this.n8(this.breaks);
            let b = (0);
            for (let c of fromEnum(a)) {
                b += (+(c.c) - +(c.d));
            }
            this.omission = b;
        }
        n8(a) {
            let b = new List$1(TimeAxisBreak.$, 0);
            if (a == null || +(this.actualMaximumValue) == +(dateMaxValue())) {
                return b;
            }
            for (let c of fromEn(a)) {
                if (c.c >= this.actualMinimumValue && c.d <= this.actualMaximumValue) {
                    b.add(c);
                }
                if (c.i != (0)) {
                    let d = +(c.c) - +(c.d);
                    let e = this.oe(c.d, c.i);
                    while (e <= this.actualMaximumValue) {
                        let f = this.oe(e, d);
                        let g = ((() => {
                            let $ret = new TimeAxisBreak();
                            $ret.d = e;
                            $ret.c = f;
                            return $ret;
                        })());
                        if (g.c >= this.actualMinimumValue && g.d <= this.actualMaximumValue) {
                            b.add(g);
                        }
                        if (dateSubtract(+(dateMaxValue()), +(c.i)) < g.d) {
                            break;
                        }
                        e = this.oe(g.d, c.i);
                    }
                }
            }
            return b;
        }
        oe(a, b) {
            let c = dateFromTicks(a.getTime());
            c.setMilliseconds(c.getMilliseconds() + b);
            return c;
        }
        o3() {
            this.nt = new OrderedDictionary$2(TimeAxisBreak.$, Number_$type);
            if (+(this.actualMaximumValue) == +(dateMaxValue()) || this.breaks == null || this.breaks.count == 0 || this.bi == null) {
                return;
            }
            let a = new List$1(TimeAxisBreak.$, 1, this.n8(this.breaks));
            a.aa((b, c) => b.d < c.d ? -1 : b.d > c.d ? 1 : 0);
            let b = this.bi.v4;
            let c = new ScalerParams(0, this.bi.v4, this.bi.wk, this.ch, this.bi.v8);
            let d = +(this.actualMaximumValue) - +(this.actualMinimumValue) - this.omission;
            let e = 0;
            for (let f of fromEnum(a)) {
                let g = timeSpanTicks((+(f.d) - +(this.actualMinimumValue))) / timeSpanTicks(d);
                let h = timeSpanTicks((+(f.c) - +(this.actualMinimumValue))) / timeSpanTicks(d);
                if (h < 0 || g - e > 1) {
                    continue;
                }
                this.nt.addItem(f, g - e);
                e += (h - g);
            }
        }
        gf(a) {
            if (isNaN_(a)) {
                return null;
            }
            let ticks_ = truncate(a);
            let b = (new Date(ticks_));
            let c = this.f1(b);
            if (c == null) {
                return null;
            }
            return c.toString();
        }
        f1(a) {
            if (!(typeCast(Date_$type, a) !== null)) {
                return super.f1(a);
            }
            let b = dateMinValue();
            let c = false;
            if (this.op != null) {
                if (typeCast(Date_$type, this.op) !== null) {
                    b = this.op;
                    c = true;
                }
            }
            let d = TimeXAxis.oo(a, c, b, this.n5, this.o2, this.labelFormats, this.fm);
            return d == null ? super.f1(a) : d;
        }
        static oo(a, b, c, d, e, f, g) {
            let h = TimeXAxis.ot(a, b, c, d, e, f, g);
            return dateToStringFormat(a, h, g);
        }
        static ot(a, b, c, d, e, f, g) {
            let h = 0;
            if (b) {
                h = TimeXAxis.n6(a, c);
            }
            let i = null;
            let j;
            if (f == null || f.count == 0) {
                j = TimeXAxis.os(e, h, d);
            }
            else {
                let k = Number.MAX_VALUE;
                let l = null;
                for (let m of fromEnum(f)) {
                    if (m.o < k) {
                        k = m.o;
                        l = m;
                    }
                    if (m.o > e) {
                        continue;
                    }
                    if (i == null || m.o > i.o) {
                        i = m;
                    }
                }
                if (i == null) {
                    i = l;
                }
                if (i == null) {
                    return null;
                }
                switch (h) {
                    case 3:
                        if (i.h != null) {
                            j = i.h;
                        }
                        else if (i.j != null) {
                            j = i.j;
                        }
                        else if (i.l != null) {
                            j = i.l;
                        }
                        else {
                            j = i.e;
                        }
                        break;
                    case 2:
                        if (i.j != null) {
                            j = i.j;
                        }
                        else if (i.l != null) {
                            j = i.l;
                        }
                        else {
                            j = i.e;
                        }
                        break;
                    case 1:
                        if (i.l != null) {
                            j = i.l;
                        }
                        else {
                            j = i.e;
                        }
                        break;
                    default:
                        j = i.e;
                        break;
                }
            }
            return j;
        }
        static n6(a, b) {
            if (a.getFullYear() == b.getFullYear() && dateGetMonth(a) == dateGetMonth(b) && a.getDate() == b.getDate()) {
                return 3;
            }
            else if (a.getFullYear() == b.getFullYear() && dateGetMonth(a) == dateGetMonth(b)) {
                return 2;
            }
            else if (a.getFullYear() == b.getFullYear()) {
                return 1;
            }
            return 0;
        }
        get_mq() {
            return super.get_mq() || (this.intervals != null && this.intervals.count > 0);
        }
        set_mq(a) {
            super.set_mq(a);
        }
        get intervals() {
            return this.n0;
        }
        or(a, b) {
            return TimeXAxis.os(this.o2, a, b);
        }
        static os(a, b, c) {
            if (c != 2) {
                b = 0;
            }
            a = Math.abs(a);
            if (a > timeSpanInit3(1825, 0, 0, 0)) {
                return "yyyy";
            }
            if (a > timeSpanInit3(365, 0, 0, 0)) {
                switch (b) {
                    case 3:
                    case 2:
                    case 1: return "MMM";
                }
                return "MMM yyyy";
            }
            ;
            if (a > timeSpanInit3(4, 0, 0, 0)) {
                switch (b) {
                    case 3:
                    case 2: return "dd";
                }
                return "MMM dd";
            }
            ;
            if (a > timeSpanInit3(1, 0, 0, 0)) {
                switch (b) {
                    case 3: return "hh:mmtt";
                    case 2: return "dd hh:mmtt";
                }
                return "MMM dd hh:mmtt";
            }
            ;
            if (a > timeSpanInit1(0, 10, 0)) {
                return "hh:mm";
            }
            return "hh:mm:ss";
        }
        static nu() {
            if (TimeXAxis.ns == null) {
                TimeXAxis.ns = ((() => {
                    let $ret = new OrderedDictionary$2(Number_$type, TimeAxisInterval.$);
                    $ret.addItem((0), ((() => {
                        let $ret = new TimeAxisInterval();
                        $ret.b = 0;
                        $ret.f = 1;
                        return $ret;
                    })()));
                    $ret.addItem(timeSpanFromMilliseconds(1), ((() => {
                        let $ret = new TimeAxisInterval();
                        $ret.b = 1;
                        $ret.f = 1;
                        return $ret;
                    })()));
                    $ret.addItem(timeSpanFromSeconds(1), ((() => {
                        let $ret = new TimeAxisInterval();
                        $ret.b = 2;
                        $ret.f = 1;
                        return $ret;
                    })()));
                    $ret.addItem(timeSpanFromSeconds(30), ((() => {
                        let $ret = new TimeAxisInterval();
                        $ret.b = 2;
                        $ret.f = 30;
                        return $ret;
                    })()));
                    $ret.addItem(timeSpanFromMinutes(2), ((() => {
                        let $ret = new TimeAxisInterval();
                        $ret.b = 3;
                        $ret.f = 2;
                        return $ret;
                    })()));
                    $ret.addItem(timeSpanFromMinutes(5), ((() => {
                        let $ret = new TimeAxisInterval();
                        $ret.b = 3;
                        $ret.f = 5;
                        return $ret;
                    })()));
                    $ret.addItem(timeSpanFromHours(1), ((() => {
                        let $ret = new TimeAxisInterval();
                        $ret.b = 4;
                        $ret.f = 1;
                        return $ret;
                    })()));
                    $ret.addItem(timeSpanFromDays(1), ((() => {
                        let $ret = new TimeAxisInterval();
                        $ret.b = 5;
                        $ret.f = 1;
                        return $ret;
                    })()));
                    $ret.addItem(timeSpanFromDays(2), ((() => {
                        let $ret = new TimeAxisInterval();
                        $ret.b = 5;
                        $ret.f = 2;
                        return $ret;
                    })()));
                    $ret.addItem(timeSpanFromDays(5), ((() => {
                        let $ret = new TimeAxisInterval();
                        $ret.b = 5;
                        $ret.f = 5;
                        return $ret;
                    })()));
                    $ret.addItem(timeSpanFromDays(10), ((() => {
                        let $ret = new TimeAxisInterval();
                        $ret.b = 5;
                        $ret.f = 10;
                        return $ret;
                    })()));
                    $ret.addItem(timeSpanFromDays(30), ((() => {
                        let $ret = new TimeAxisInterval();
                        $ret.b = 7;
                        $ret.f = 1;
                        return $ret;
                    })()));
                    $ret.addItem(timeSpanFromDays(60), ((() => {
                        let $ret = new TimeAxisInterval();
                        $ret.b = 7;
                        $ret.f = 3;
                        return $ret;
                    })()));
                    $ret.addItem(timeSpanFromDays(365), ((() => {
                        let $ret = new TimeAxisInterval();
                        $ret.b = 8;
                        $ret.f = 1;
                        return $ret;
                    })()));
                    $ret.addItem(timeSpanFromDays(365 * 10), ((() => {
                        let $ret = new TimeAxisInterval();
                        $ret.b = 8;
                        $ret.f = 10;
                        return $ret;
                    })()));
                    return $ret;
                })());
            }
            return TimeXAxis.ns;
        }
        ny() {
            if (this.c4 && (this.az == null || this.az.angle == 0)) {
                let a = this.ez();
                let b = this.kh.width;
                let c = truncate(Math.floor(b / a));
                let d = Number.MAX_VALUE;
                let e = c == 0 ? d : timeSpanFromTicks((intDivide(timeSpanTicks(this.o2), c)));
                let f = null;
                for (let g of fromEnum(TimeXAxis.nu())) {
                    f = g.value;
                    if (g.key > e) {
                        break;
                    }
                }
                let h = this.nx;
                if (h != f) {
                    this.ih();
                }
                this.nx = f;
                return f;
            }
            let i = this.o2;
            if (i == (0)) {
                return ((() => {
                    let $ret = new TimeAxisInterval();
                    $ret.b = 8;
                    $ret.f = 1;
                    return $ret;
                })());
            }
            if (i >= timeSpanFromDays(365 * 100)) {
                return ((() => {
                    let $ret = new TimeAxisInterval();
                    $ret.b = 8;
                    $ret.f = 10;
                    return $ret;
                })());
            }
            if (i >= timeSpanFromDays(365 * 5)) {
                return ((() => {
                    let $ret = new TimeAxisInterval();
                    $ret.b = 8;
                    $ret.f = 1;
                    return $ret;
                })());
            }
            if (i >= timeSpanFromDays(365 * 2)) {
                return ((() => {
                    let $ret = new TimeAxisInterval();
                    $ret.b = 7;
                    $ret.f = 3;
                    return $ret;
                })());
            }
            if (i >= timeSpanFromDays(150)) {
                return ((() => {
                    let $ret = new TimeAxisInterval();
                    $ret.b = 7;
                    $ret.f = 1;
                    return $ret;
                })());
            }
            if (i >= timeSpanFromDays(60)) {
                return ((() => {
                    let $ret = new TimeAxisInterval();
                    $ret.b = 5;
                    $ret.f = 10;
                    return $ret;
                })());
            }
            if (i >= timeSpanFromDays(30)) {
                return ((() => {
                    let $ret = new TimeAxisInterval();
                    $ret.b = 5;
                    $ret.f = 5;
                    return $ret;
                })());
            }
            if (i >= timeSpanFromDays(20)) {
                return ((() => {
                    let $ret = new TimeAxisInterval();
                    $ret.b = 5;
                    $ret.f = 2;
                    return $ret;
                })());
            }
            if (i >= timeSpanFromDays(4)) {
                return ((() => {
                    let $ret = new TimeAxisInterval();
                    $ret.b = 5;
                    $ret.f = 1;
                    return $ret;
                })());
            }
            if (i >= timeSpanFromDays(1)) {
                return ((() => {
                    let $ret = new TimeAxisInterval();
                    $ret.b = 4;
                    $ret.f = 12;
                    return $ret;
                })());
            }
            if (i >= timeSpanFromHours(6)) {
                return ((() => {
                    let $ret = new TimeAxisInterval();
                    $ret.b = 4;
                    $ret.f = 1;
                    return $ret;
                })());
            }
            if (i >= timeSpanFromMinutes(30)) {
                return ((() => {
                    let $ret = new TimeAxisInterval();
                    $ret.b = 3;
                    $ret.f = 5;
                    return $ret;
                })());
            }
            if (i >= timeSpanFromMinutes(10)) {
                return ((() => {
                    let $ret = new TimeAxisInterval();
                    $ret.b = 3;
                    $ret.f = 2;
                    return $ret;
                })());
            }
            return ((() => {
                let $ret = new TimeAxisInterval();
                $ret.b = 2;
                $ret.f = 30;
                return $ret;
            })());
        }
        nz() {
            if (this.intervals == null || this.intervals.count == 0) {
                return this.ny();
            }
            if (this.o2 == (0)) {
                return ((() => {
                    let $ret = new TimeAxisInterval();
                    $ret.b = 8;
                    $ret.f = 1;
                    return $ret;
                })());
            }
            let a = null;
            for (let b of fromEnum(this.intervals)) {
                if (b.k > this.o2) {
                    continue;
                }
                if (a == null || b.k > a.k) {
                    a = b;
                }
            }
            return a == null ? this.ny() : a;
        }
        ic(a) {
            super.ic(a);
            let b = this.bi != null ? this.bi.v4 : Rect.empty;
            let c = !b.isEmpty ? this.kh : Rect.empty;
            let d = this.kc();
            let e = this.kb();
            let f = new ScalerParams(0, b, c, this.ch, d);
            if (this.mm == null && !this.ms() && !this.mt()) {
                return;
            }
            if (!b.isEmpty && !c.isEmpty) {
                let g = c.bottom;
                let h = g - c.top;
                if (this.aj != null) {
                    let i = typeCast(NumericYAxis.$, this.aj);
                    if (i != null) {
                        let j = this.ii(g, h, b, c, d, c.top, c.bottom);
                        g = j.p0;
                        h = j.p1;
                    }
                }
                if (isNaN_(g)) {
                    g = 0;
                }
                this.ht(this.a5.a4(), g, c, this.a5.e(), true);
                this.aw.bg = h;
                let k = truncate(Math.ceil(e.right));
                let l = truncate(Math.floor(e.left));
                let m = this.a5.a7();
                let n = this.a5.f();
                let o = this.a5.a5();
                this.nn();
                let p = new List$1(Date_$type, 1, this.n7());
                let q = new List$1(Number_$type, 0);
                for (let r = 0; r < p.count; r++) {
                    q.add(p._inner[r].getTime());
                }
                this.hq(q, 0, q.count, f);
                this.op = null;
                for (let s = 0; s < p.count; s++) {
                    let t = p._inner[s];
                    let u = q._inner[s];
                    let v = truncate(Math.round(u));
                    if (v <= k) {
                        if (s % 2 == 0) {
                            let w = s < q.count - 1 ? q._inner[s + 1] : e.right;
                            this.ir(m, u, w, c);
                        }
                        this.iq(o, u, c, n, false);
                        this.k2.add(u);
                    }
                    if (v >= l && v <= k) {
                        let x = this.f1(t);
                        this.op = t;
                        if (x != null) {
                            this.dd.add1(x);
                            this.de.add(new LabelPosition(u));
                        }
                    }
                }
                this.op = null;
            }
            if ((this.az == null || this.az.visibility == 0) && this.aj != null) {
                if (this.az != null && (this.az.location == 4 || this.az.location == 5)) {
                    this.bi.n3();
                }
            }
            this.aw.a9 = this.dd;
            this.aw.ba = this.de;
            this.aw.cl();
            this.l9();
        }
        n7() {
            let a = this.bi != null ? this.bi.v4 : Rect.empty;
            let b = !a.isEmpty ? this.kh : Rect.empty;
            let c = this.kc();
            let d = this.kb();
            let e = new ScalerParams(0, a, b, this.ch, c);
            let f = this.nz();
            let g = this.og;
            if (!this.mt() && f != null) {
                if (f.b == 7 && g.getDate() != 1) {
                    g = dateAddMonths(g, 1);
                    g = dateFromValues(g.getFullYear(), dateGetMonth(g), 1, 0, 0, 0, 0);
                }
                else if (f.b == 5 && dateGetTimeOfDay(g) != (0)) {
                    g = dateAddDays(g, 1);
                    g = dateFromValues(g.getFullYear(), dateGetMonth(g), g.getDate(), 0, 0, 0, 0);
                }
                else if (f.b == 4 && g.getMinutes() != 0) {
                    g = dateAddHours(g, 1);
                    g = dateFromValues(g.getFullYear(), dateGetMonth(g), g.getDate(), g.getHours(), 0, 0, 0);
                }
            }
            let h = new List$1(Date_$type, 0);
            let i = 0;
            let j = 10000;
            if (f.f == 0) {
                return h;
            }
            while (g <= this.visibleMaximum && i++ < j) {
                let k = this.n9(g);
                let l = g;
                if (k.key != null) {
                    l = f.d(k.key.c);
                }
                h.add(l);
                while (g <= l) {
                    g = f.c(g);
                }
            }
            return h;
        }
        n9(a) {
            if (this.nt == null) {
                return new KeyValuePair$2(TimeAxisBreak.$, Number_$type);
            }
            for (let b of fromEnum(this.nt)) {
                if (b.key.d <= a && b.key.c >= a) {
                    return b;
                }
            }
            return new KeyValuePair$2(TimeAxisBreak.$, Number_$type);
        }
        get visibleMinimum() {
            return this.od;
        }
        set visibleMinimum(a) {
            this.od = a;
        }
        get og() {
            return this.ob;
        }
        set og(a) {
            this.ob = a;
        }
        get of() {
            return this.oa;
        }
        set of(a) {
            this.oa = a;
        }
        get visibleMaximum() {
            return this.oc;
        }
        set visibleMaximum(a) {
            this.oc = a;
        }
        nn() {
            super.nn();
            if (this.bi == null || !Extensions.b(this.bi.wk)) {
                return;
            }
            let a = new ScalerParams(0, this.bi.v4, this.bi.wk, this.ch, this.bi.v8);
            let b = this.kb();
            let c = b.left;
            let d = b.right;
            let e = b.left;
            let f = b.right;
            if (this.categoryMode != 0) {
                let g = this.getCategorySize(a.e, a.d, a.c);
                e += g / 2;
                f -= g / 2;
            }
            let h = truncate(this.eo(c, a));
            let i = truncate(this.eo(d, a));
            let j = truncate(this.eo(e, a));
            let k = truncate(this.eo(f, a));
            if (j < 0 || k < 0) {
                this.o2 = (0);
                return;
            }
            h = Math.min(dateMaxValue().getTime(), h);
            i = Math.min(dateMaxValue().getTime(), i);
            h = Math.max(dateMinValue().getTime(), h);
            i = Math.max(dateMinValue().getTime(), i);
            j = Math.min(dateMaxValue().getTime(), j);
            k = Math.min(dateMaxValue().getTime(), k);
            let l = dateFromTicks(Math.min(h, i));
            let m = dateFromTicks(Math.max(h, i));
            let n = dateFromTicks(Math.min(j, k));
            let o = dateFromTicks(Math.max(j, k));
            let p = +(this.visibleMinimum) != +n || +(this.visibleMaximum) != +o;
            this.visibleMinimum = n;
            this.visibleMaximum = o;
            this.og = l;
            this.of = m;
            if (p && this.visibleRangeChanged != null) {
                this.visibleRangeChanged(this, EventArgs.empty);
            }
            this.o2 = +(this.visibleMaximum) - +(this.visibleMinimum);
        }
        la(a, b, c, d, e) {
            return 0;
        }
        i$f(a) {
            let b = this;
            if (b.i$b == null || b.i$b.count == 0) {
                return -1;
            }
            let c = new SortedListView$1(Date_$type, this.mm, b.i$b);
            let ticks_ = a;
            let d = (new Date(ticks_));
            let e = this.m6(d, c);
            e = Math.max(0, Math.min(b.i$b.count - 1, e));
            let f = c.item(e);
            let g;
            let h;
            if (f < d) {
                g = e;
                h = g + 1;
            }
            else {
                h = e;
                g = e - 1;
            }
            g = this.on(g, c);
            h = this.om(h, c);
            if (g < 0) {
                return h;
            }
            if (h >= b.i$b.count) {
                return g;
            }
            let i = c.item(g);
            let j = c.item(h);
            let k = new ScalerParams(0, this.bi.wl, this.kh, this.ch, this.bi.v8);
            this.startCursor();
            let l = this.el(i.getTime(), k);
            let m = this.el(a, k);
            let n = this.el(j.getTime(), k);
            this.resetCursor();
            if (i < this.og && j <= this.of) {
                return this.mv._inner[h];
            }
            if (j > this.of && i >= this.og) {
                return this.mv._inner[g];
            }
            if (Math.abs(l - m) < Math.abs(n - m)) {
                return this.mv._inner[g];
            }
            else {
                return this.mv._inner[h];
            }
        }
        om(a, b) {
            if (a < 0 || a >= b.count - 1) {
                return a;
            }
            let c = b.item(a);
            let d = 0;
            while (d < this.nt.count) {
                let e = this.nt.item1(d);
                if (c >= e.d && c <= e.c) {
                    break;
                }
                d++;
            }
            if (d >= this.nt.count) {
                return a;
            }
            let f = a;
            while (f < b.count) {
                if (f < 0 || f >= b.count - 1) {
                    return a;
                }
                c = b.item(f);
                let g = this.nt.item1(d);
                if (c >= g.d && c <= g.c) {
                    f++;
                    continue;
                }
                d++;
                if (d > this.nt.count - 1) {
                    break;
                }
                g = this.nt.item1(d);
                if (c >= g.d && c <= g.c) {
                    f++;
                    continue;
                }
                break;
            }
            if (f < 0 || f > b.count - 1) {
                return a;
            }
            return f;
        }
        on(a, b) {
            if (a < 0 || a >= b.count - 1) {
                return a;
            }
            let c = b.item(a);
            let d = 0;
            while (d < this.nt.count) {
                let e = this.nt.item1(d);
                if (c >= e.d && c <= e.c) {
                    break;
                }
                d++;
            }
            if (d >= this.nt.count) {
                return a;
            }
            let f = a;
            while (f >= 0) {
                if (f < 0 || f >= b.count - 1) {
                    return a;
                }
                c = b.item(f);
                let g = this.nt.item1(d);
                if (c >= g.d && c <= g.c) {
                    f--;
                    continue;
                }
                d--;
                if (d < 0) {
                    break;
                }
                g = this.nt.item1(d);
                if (c >= g.d && c <= g.c) {
                    f--;
                    continue;
                }
                break;
            }
            if (f < 0 || f > b.count - 1) {
                return a;
            }
            return f;
        }
        o5(a, b) {
            this.o4();
            this.o3();
            if (this.aw != null) {
                this.aw.al = this.breaks.count > 0;
            }
            this.ib(false);
            for (let c of fromEnum(this.db())) {
                c.rr(false);
            }
        }
        o7(a, b) {
            this.ib(false);
        }
        o6(a, b) {
            this.ib(false);
        }
        get_cc() {
            return false;
        }
        getWindowRectForSelection(a, b) {
            let c = +(this.actualMaximumValue) - +(this.actualMinimumValue);
            let d = timeSpanTotalMilliseconds((+a - +(this.actualMinimumValue))) / timeSpanTotalMilliseconds(c);
            let e = 1 - (timeSpanTotalMilliseconds((+(this.actualMaximumValue) - +b)) / timeSpanTotalMilliseconds(c));
            e = Math.min(1, e);
            return new Rect(0, d, NaN, Math.max(0, e - d), NaN);
        }
        getCategorySize(a, b, c) {
            if (this.o2 != (0)) {
                let d = timeSpanFromTicks(truncate((timeSpanTicks(this.o2) * (a.width / (this.bi != null ? this.bi.v4.width : 1)))));
                let e = timeSpanTicks(d) / timeSpanTicks(this.o0);
                let f = b.width / 4;
                return Math.min(f, b.width / (e + 1));
            }
            return super.getCategorySize(a, b, c);
        }
        static oz(a, b) {
            let c = Math.min(5, b);
            let d = a(0);
            let e = new Dictionary$2(Number_$type, Number_$type, 0);
            let f = 0;
            let g = (0);
            for (let h = 0; h < c; h++) {
                let i = a(h);
                let j = +i - +d;
                if (!e.containsKey(j)) {
                    e.addItem(j, 0);
                }
                e.item(j, e.item(j) + 1);
                if (e.item(j) > f) {
                    f = e.item(j);
                    g = j;
                }
                d = i;
            }
            return g;
        }
        oy() {
            if (this.mm == null || this.mm.count < 2 || this.mv == null) {
                return (0);
            }
            return TimeXAxis.oz((a) => this.mm.item(this.mv._inner[a]), this.mm.count);
        }
        nj() {
            super.nj();
            this.o0 = this.oy();
        }
        static ov(a) {
            if (a >= timeSpanFromDays(1)) {
                return "D";
            }
            return "g";
        }
        itemLabelFormat() {
            return TimeXAxis.ov(this.o0);
        }
        m5(a, b, c, d) {
            return this.m4(this.visibleMinimum);
        }
        m8(a, b, c, d) {
            return this.m7(this.visibleMaximum);
        }
        get isVertical() {
            return this.cp;
        }
        j$d(a, b) {
            return this.eo.apply(this, arguments);
        }
        j$c(a, b) {
            return this.el.apply(this, arguments);
        }
        j$e(a, b, c, d, e) {
            this.hp.apply(this, arguments);
        }
        j$f(a, b, c, d) {
            this.hq.apply(this, arguments);
        }
        j$g(a, b, c, d) {
            this.hr.apply(this, arguments);
        }
        get j$b() {
            return this.ch;
        }
        j$a() {
            return this.ag.apply(this, arguments);
        }
        get i$a() {
            return this.ce;
        }
    }
    TimeXAxis.$t = /*@__PURE__*/ markType(TimeXAxis, 'TimeXAxis', TimeAxisBase.$, [ITimeRangeSelectorAxis_$type]);
    TimeXAxis.ns = null;
    return TimeXAxis;
})();
