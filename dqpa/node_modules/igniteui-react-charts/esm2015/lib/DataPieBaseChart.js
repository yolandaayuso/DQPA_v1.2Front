/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { RadialBaseChart } from "./RadialBaseChart";
import { ProportionalCategoryAngleAxis } from "./ProportionalCategoryAngleAxis";
import { NumericRadiusAxis } from "./NumericRadiusAxis";
import { typeCast, runOn, delegateCombine, enumGetBox, markType } from "igniteui-react-core";
import { PieChartSweepDirection_$type } from "./PieChartSweepDirection";
import { CalloutCollisionMode_$type } from "igniteui-react-core";
import { LegendEmptyValuesMode_$type } from "igniteui-react-core";
import { OthersCategoryType_$type } from "igniteui-react-core";
import { AxisRangeBufferMode_$type } from "./AxisRangeBufferMode";
import { RadialLabelMode_$type } from "igniteui-react-core";
import { CollisionAvoidanceType_$type } from "./CollisionAvoidanceType";
import { RadialBase } from "./RadialBase";
import { RadialPieSeries } from "./RadialPieSeries";
import { AnchoredRadialSeries } from "./AnchoredRadialSeries";
import { AxisLabelSettings } from "./AxisLabelSettings";
import { isNaN_ } from "igniteui-react-core";
/**
 * @hidden
 */
export let DataPieBaseChart = /*@__PURE__*/ (() => {
    class DataPieBaseChart extends RadialBaseChart {
        constructor() {
            super();
            this.aiw = null;
            this.ag2 = null;
            this.ais = null;
            this.ag0 = null;
            this.aiu = null;
            this.ag1 = null;
            this.air = null;
            this.agz = null;
            this.ah3 = 0;
            this.ahj = 0;
            this.ag9 = 6;
            this.aki = null;
            this.akh = null;
            this.aix = null;
            this.aiq = null;
            this.ahd = 0;
            this.ahh = 1;
            this.ah4 = 3;
            this.ait = null;
            this.aip = null;
            this.ahu = true;
            this.ag7 = 0;
            this.ah1 = 0;
            this.ah2 = 0;
            this.ah7 = 0;
            this.ahv = false;
            this.ain = 10;
            this.ah9 = NaN;
            this.ah8 = NaN;
            this.aia = 0;
            this.ah5 = NaN;
            this.ah6 = NaN;
            this.aiv = " - ";
            this.aho = 0;
            this.ahn = 0;
            this.ahs = true;
            this.aht = true;
            this.ahb = 0;
        }
        hd() {
            return true;
        }
        akd(a) {
            this.ake((b, c) => a(b));
        }
        ake(a) {
            if (this.dataChart == null) {
                return;
            }
            for (let b = 0; b < this.dataChart.series.count; b++) {
                let c = this.dataChart.series._inner[b];
                if (c.ft) {
                    a(c, b);
                }
            }
        }
        akb(a) {
            this.akc((b, c) => a(b));
        }
        akc(a) {
            if (this.dataChart == null) {
                return;
            }
            for (let b = 0; b < this.dataChart.series.count; b++) {
                let c = this.dataChart.series._inner[b];
                if (c.ft) {
                    a(c, b);
                }
            }
        }
        wp() {
            let a = this.bf.dataSeries != null ? this.bf.dataSeries.count : 0;
            super.wp();
            if (this.ai3 != null) {
                let b = this.ai3;
                this.angleAxis.f2 = b;
            }
            else {
                this.angleAxis.f2 = this.ack == null ? RadialBaseChart.ad1(this.angleAxis, this.bf.dataSeries) : this.ack;
            }
            this.angleAxis.itemsSource = this.dataChart != null && this.dataChart.series.count > 0 ? this.dataChart.series._inner[0].itemsSource : null;
            if (this.aj8 != null) {
                this.angleAxis.ok = this.aj8;
            }
            else {
                this.angleAxis.ok = (this.dataChart != null && this.dataChart.series.count > 0 && typeCast(RadialPieSeries.$, this.dataChart.series._inner[0]) !== null) ? this.dataChart.series._inner[0].acx : null;
            }
        }
        c2(a, b) {
            if (this.c5 == null || this.c5.count == 0) {
                return 13;
            }
            let c = super.c2(a, b);
            if (c == 1) {
                return 13;
            }
            return c;
        }
        wn(a) {
        }
        g9(a) {
            if (!super.g9(a)) {
                return false;
            }
            return true;
        }
        wq() {
            this.valueAxis.lo = this.ah0;
            this.valueAxis.mm = this.aio;
        }
        get angleAxis() {
            return this.ahl;
        }
        set angleAxis(a) {
            let b = this.angleAxis;
            if (a != b) {
                this.ahl = a;
                this.vu("AngleAxis", b, this.angleAxis);
            }
        }
        get valueAxis() {
            return this.ahf;
        }
        set valueAxis(a) {
            let b = this.valueAxis;
            if (a != b) {
                this.ahf = a;
                this.vu("ValueAxis", b, this.valueAxis);
            }
        }
        get_ahx() {
            return false;
        }
        get ahx() {
            return this.get_ahx();
        }
        dc(a, b) {
            let c = null;
            if (b == 34) {
                c = this.ahr(a, b);
            }
            if (a.index > 0) {
                if (!this.ahx) {
                    if (c != null) {
                        c.o2();
                    }
                    return null;
                }
            }
            return c;
        }
        u6(a, b) {
            super.u6(a, b);
            if (this.gx(a) && this.ce.isCalloutLayer(a)) {
                if (this.akk != null) {
                    this.ce.setCalloutLightColor(a, this.akk);
                }
                if (this.akj != null) {
                    this.ce.setCalloutDarkColor(a, this.akj);
                }
                let c = this.ah;
                if (this.aha != 0) {
                    c = this.aha;
                }
                this.ce.setCollisionMode(a, c);
            }
        }
        ahr(a, b) {
            let c = null;
            if (b == 34) {
                c = this.de(34);
            }
            else {
                c = this.de(34);
            }
            if (this.aj8 != null) {
                c.acx = this.aj8;
            }
            else {
                c.acx = a.getMemberPathFor(0);
            }
            if (this.ai6 != null) {
                c.ad0 = this.ai6;
            }
            c.adq = this.ahe;
            c.yz = this.angleAxis;
            c.y5 = this.valueAxis;
            c.g9 = true;
            c.ach = true;
            c.aa2 = this.ajs;
            c.yr = this.ag6;
            c.aaz = this.ajl;
            c.yq = this.ag5;
            c.aas = this.ajc;
            c.yo = this.ag4;
            c.aaw = this.ai8;
            c.yp = this.ag3;
            c.ze = this.ahq;
            c.zf = this.ahp;
            c.aad = this.ajq;
            return c;
        }
        z4() {
            return this.angleAxis;
        }
        z5() {
            return this.valueAxis;
        }
        ug() {
            this.angleAxis = new ProportionalCategoryAngleAxis();
            this.angleAxis.name = "angleAxis";
            let a = this.angleAxis;
            a.propertyChanged = delegateCombine(a.propertyChanged, runOn(this, this.akf));
            this.angleAxis.k5 = 0;
            this.valueAxis = new NumericRadiusAxis();
            this.valueAxis.name = "valueAxis";
            let b = this.valueAxis;
            b.propertyChanged = delegateCombine(b.propertyChanged, runOn(this, this.akg));
            if (this.angleAxis.az == null) {
                this.angleAxis.az = new AxisLabelSettings();
            }
            if (this.valueAxis.az == null) {
                this.valueAxis.az = new AxisLabelSettings();
            }
        }
        akf(a, b) {
            switch (b.propertyName) {
                case "ActualMinimumValue":
                    this.wb("AngleAxisActualMinimum");
                    break;
                case "ActualMaximumValue":
                    this.wb("AngleAxisActualMaximum");
                    break;
            }
        }
        akg(a, b) {
            switch (b.propertyName) {
                case "ActualMinimumValue":
                    this.wb("ValueAxisActualMinimum");
                    break;
                case "ActualMaximumValue":
                    this.wb("ValueAxisActualMaximum");
                    break;
            }
        }
        ua(a, b) {
            let c = typeCast(RadialBase.$, a);
            if (c != null) {
                c.xa = this.c2(a, b);
            }
        }
        afb(a) {
            super.afb(a);
            a.lf = this.ahy;
            a.lj = this.ahz;
            a.og = this.aid;
            if (!isNaN_(this.aif)) {
                a.oh = this.aif;
            }
            else {
                a.oh = 0.65;
            }
        }
        ae9(a) {
            super.ae9(a);
            a.oe = this.ajh;
            a.ny = this.ahi;
            a.ob = this.aie;
            if (!isNaN_(this.aig)) {
                a.ne = this.aig;
            }
            if (this.ahk != 0) {
                if (this.ahk == 1) {
                    a.ch = false;
                }
                else {
                    a.ch = true;
                }
            }
        }
        vu(a, b, c) {
            super.vu(a, b, c);
            switch (a) {
                case "SliceLabelPositionMode":
                    this.us((d) => {
                        if (d.eo) {
                            this.ce.setCollisionMode(d, this.aha);
                        }
                    });
                    break;
                case "SliceLabelContentSeparator":
                    this.akb((d) => d.aad = this.ajq);
                    break;
                case "SliceLabelContentMode":
                    this.akb((d) => d.ze = this.ahq);
                    break;
                case "LegendSliceLabelContentMode":
                    this.akb((d) => d.zf = this.ahp);
                    break;
                case "SliceLabelFormat":
                    this.akb((d) => d.aa2 = this.ajs);
                    break;
                case "SliceLabelFormatSpecifiers":
                    this.akb((d) => d.yr = this.ag6);
                    break;
                case "OthersSliceLabelFormat":
                    this.akb((d) => d.aaz = this.ajl);
                    break;
                case "OthersSliceLabelFormatSpecifiers":
                    this.akb((d) => d.yq = this.ag5);
                    break;
                case "LegendSliceLabelFormat":
                    this.akb((d) => d.aas = this.ajs);
                    break;
                case "LegendSliceLabelFormatSpecifiers":
                    this.akb((d) => d.yo = this.ag6);
                    break;
                case "LegendOthersSliceLabelFormat":
                    this.akb((d) => d.aaw = this.ai8);
                    break;
                case "LegendOthersSliceLabelFormatSpecifiers":
                    this.akb((d) => d.yp = this.ag3);
                    break;
                case "SweepDirection":
                    if (this.angleAxis != null) {
                        if (this.ahk != 0) {
                            if (this.ahk == 1) {
                                this.angleAxis.ch = false;
                            }
                            else {
                                this.angleAxis.ch = true;
                            }
                        }
                        else {
                            this.angleAxis.ch = this.aag;
                        }
                    }
                    break;
                case "StartAngle":
                    if (this.angleAxis != null) {
                        this.angleAxis.ne = isNaN_(this.aig) ? 0 : this.aig;
                    }
                    break;
                case "RadiusExtent":
                    if (this.valueAxis != null) {
                        this.valueAxis.oh = isNaN_(this.aif) ? 0.65 : this.aif;
                    }
                    break;
                case "OthersCategoryText":
                    if (this.angleAxis != null) {
                        this.angleAxis.oe = this.ajh;
                    }
                    break;
                case "OthersCategoryType":
                    if (this.angleAxis != null) {
                        this.angleAxis.ny = this.ahi;
                    }
                    break;
                case "OthersCategoryThreshold":
                    if (this.angleAxis != null) {
                        this.angleAxis.ob = this.aie;
                    }
                    break;
                case "InnerExtent":
                    if (this.valueAxis != null) {
                        this.valueAxis.og = this.aid;
                    }
                    break;
                case "LightSliceLabelColor":
                    this.up((d) => {
                        if (d.eo) {
                            this.ce.setCalloutLightColor(d, this.akk);
                        }
                    });
                    break;
                case "DarkSliceLabelColor":
                    this.up((d) => {
                        if (d.eo) {
                            this.ce.setCalloutDarkColor(d, this.akj);
                        }
                    });
                    break;
                case "ValueMemberPath":
                    if (c != null) {
                        this.uu((d) => {
                            if (typeCast(AnchoredRadialSeries.$, d) !== null) {
                                let e = d;
                                e.acx = this.aj8;
                            }
                        });
                        this.angleAxis.ok = this.aj8;
                    }
                    else {
                        this.v0();
                    }
                    break;
                case "LabelMemberPath":
                    if (c != null) {
                        let d = this.ai3;
                        this.angleAxis.f2 = d;
                    }
                    else {
                        this.v0();
                    }
                    break;
                case "LegendLabelMemberPath":
                    if (c != null) {
                        this.uu((e) => {
                            if (typeCast(RadialPieSeries.$, e) !== null) {
                                let f = e;
                                f.ad0 = this.ai6;
                            }
                        });
                    }
                    else {
                        this.v0();
                    }
                    break;
                case "AngleAxisInterval":
                    this.angleAxis.nb = this.aib;
                    break;
                case "ValueAxisInterval":
                    this.valueAxis.l8 = this.aij;
                    break;
                case "ValueAxisFavorLabellingScaleEnd":
                    this.valueAxis.lj = this.ahz;
                    break;
                case "ValueAxisAutoRangeBufferMode":
                    this.valueAxis.ky = this.ag8;
                    break;
                case "AngleAxisMinorInterval":
                    this.angleAxis.nc = this.aic;
                    break;
                case "ValueAxisMinorInterval":
                    this.valueAxis.md = this.aim;
                    break;
                case "ValueAxisIsLogarithmic":
                    this.valueAxis.lo = this.ah0;
                    break;
                case "ValueAxisLogarithmBase":
                    this.valueAxis.mm = this.aio;
                    break;
                case "ValueAxisMinimumValue":
                    this.valueAxis.mc = this.ail;
                    break;
                case "ValueAxisMaximumValue":
                    this.valueAxis.mb = this.aik;
                    break;
                case "MarkerCollision":
                    this.uv((e, f) => this.ua(e, f));
                    break;
                case "ValueAxisAbbreviateLargeNumbers":
                    this.afi((e) => e.lf = this.ahy);
                    break;
            }
        }
        get ajs() {
            return this.aiw;
        }
        set ajs(a) {
            let b = this.ajs;
            if (a != b) {
                this.aiw = a;
                this.vu("SliceLabelFormat", b, this.ajs);
            }
        }
        get ag6() {
            return this.ag2;
        }
        set ag6(a) {
            let b = this.ag6;
            if (a != b) {
                this.ag2 = a;
                this.vu("SliceLabelFormatSpecifiers", b, this.ag6);
            }
        }
        get ajc() {
            return this.ais;
        }
        set ajc(a) {
            let b = this.ajc;
            if (a != b) {
                this.ais = a;
                this.vu("LegendSliceLabelFormat", b, this.ajc);
            }
        }
        get ag4() {
            return this.ag0;
        }
        set ag4(a) {
            let b = this.ag4;
            if (a != b) {
                this.ag0 = a;
                this.vu("LegendSliceLabelFormatSpecifiers", b, this.ag4);
            }
        }
        get ajl() {
            return this.aiu;
        }
        set ajl(a) {
            let b = this.ajl;
            if (a != b) {
                this.aiu = a;
                this.vu("OthersSliceLabelFormat", b, this.ajl);
            }
        }
        get ag5() {
            return this.ag1;
        }
        set ag5(a) {
            let b = this.ag5;
            if (a != b) {
                this.ag1 = a;
                this.vu("OthersSliceLabelFormatSpecifiers", b, this.ag5);
            }
        }
        get ai8() {
            return this.air;
        }
        set ai8(a) {
            let b = this.ai8;
            if (a != b) {
                this.air = a;
                this.vu("LegendOthersSliceLabelFormat", b, this.ai8);
            }
        }
        get ag3() {
            return this.agz;
        }
        set ag3(a) {
            let b = this.ag3;
            if (a != b) {
                this.agz = a;
                this.vu("LegendOthersSliceLabelFormatSpecifiers", b, this.ag3);
            }
        }
        get aid() {
            return this.ah3;
        }
        set aid(a) {
            let b = this.aid;
            if (a != b) {
                this.ah3 = a;
                this.vu("InnerExtent", b, this.aid);
            }
        }
        get ahk() {
            return this.ahj;
        }
        set ahk(a) {
            let b = this.ahk;
            if (a != b) {
                this.ahj = a;
                this.vu("SweepDirection", enumGetBox(PieChartSweepDirection_$type, b), enumGetBox(PieChartSweepDirection_$type, this.ahk));
            }
        }
        get aha() {
            return this.ag9;
        }
        set aha(a) {
            let b = this.aha;
            if (a != b) {
                this.ag9 = a;
                this.vu("SliceLabelPositionMode", enumGetBox(CalloutCollisionMode_$type, b), enumGetBox(CalloutCollisionMode_$type, this.aha));
            }
        }
        get akk() {
            return this.aki;
        }
        set akk(a) {
            let b = this.akk;
            if (a != b) {
                this.aki = a;
                this.vu("LightSliceLabelColor", b, this.akk);
            }
        }
        get akj() {
            return this.akh;
        }
        set akj(a) {
            let b = this.akj;
            if (a != b) {
                this.akh = a;
                this.vu("DarkSliceLabelColor", b, this.akj);
            }
        }
        get aj8() {
            return this.aix;
        }
        set aj8(a) {
            let b = this.aj8;
            if (a != b) {
                this.aix = a;
                this.vu("ValueMemberPath", b, this.aj8);
            }
        }
        get ai6() {
            return this.aiq;
        }
        set ai6(a) {
            let b = this.aiq;
            if (a != b) {
                this.aiq = a;
                this.vu("LegendLabelMemberPath", b, this.aiq);
            }
        }
        get ahe() {
            return this.ahd;
        }
        set ahe(a) {
            let b = this.ahd;
            if (a != b) {
                this.ahd = a;
                this.vu("LegendEmptyValuesMode", enumGetBox(LegendEmptyValuesMode_$type, b), this.aiq);
            }
        }
        get ahi() {
            return this.ahh;
        }
        set ahi(a) {
            let b = this.ahi;
            if (a != b) {
                this.ahh = a;
                this.vu("OthersCategoryType", enumGetBox(OthersCategoryType_$type, b), enumGetBox(OthersCategoryType_$type, this.ahi));
            }
        }
        get aie() {
            return this.ah4;
        }
        set aie(a) {
            let b = this.aie;
            if (a != b) {
                this.ah4 = a;
                this.vu("OthersCategoryThreshold", b, this.aie);
            }
        }
        get ajh() {
            return this.ait;
        }
        set ajh(a) {
            let b = this.ajh;
            if (a != b) {
                this.ait = a;
                this.vu("OthersCategoryText", b, this.ajh);
            }
        }
        get ai3() {
            return this.aip;
        }
        set ai3(a) {
            let b = this.ai3;
            if (a != b) {
                this.aip = a;
                this.vu("LabelMemberPath", b, this.ai3);
            }
        }
        get ahz() {
            return this.ahu;
        }
        set ahz(a) {
            let b = this.ahz;
            if (a != b) {
                this.ahu = a;
                this.vu("ValueAxisFavorLabellingScaleEnd", b, this.ahz);
            }
        }
        get ag8() {
            return this.ag7;
        }
        set ag8(a) {
            let b = this.ag8;
            if (a != b) {
                this.ag7 = a;
                this.vu("ValueAxisAutoRangeBufferMode", enumGetBox(AxisRangeBufferMode_$type, b), enumGetBox(AxisRangeBufferMode_$type, this.ag8));
            }
        }
        get aib() {
            return this.ah1;
        }
        set aib(a) {
            let b = this.aib;
            if (a != b) {
                this.ah1 = a;
                this.vu("AngleAxisInterval", b, this.aib);
            }
        }
        get aic() {
            return this.ah2;
        }
        set aic(a) {
            let b = this.aic;
            if (a != b) {
                this.ah2 = a;
                this.vu("AngleAxisMinorInterval", b, this.aic);
            }
        }
        get aij() {
            return this.ah7;
        }
        set aij(a) {
            let b = this.aij;
            if (a != b) {
                this.ah7 = a;
                this.vu("ValueAxisInterval", b, this.aij);
            }
        }
        get ah0() {
            return this.ahv;
        }
        set ah0(a) {
            let b = this.ah0;
            if (a != b) {
                this.ahv = a;
                this.vu("ValueAxisIsLogarithmic", b, this.ah0);
            }
        }
        get aio() {
            return this.ain;
        }
        set aio(a) {
            let b = this.aio;
            if (a != b) {
                this.ain = a;
                this.vu("ValueAxisLogarithmBase", b, this.aio);
            }
        }
        get ail() {
            return this.ah9;
        }
        set ail(a) {
            let b = this.ail;
            if (a != b) {
                this.ah9 = a;
                this.vu("ValueAxisMinimumValue", b, this.ail);
            }
        }
        get aik() {
            return this.ah8;
        }
        set aik(a) {
            let b = this.aik;
            if (a != b) {
                this.ah8 = a;
                this.vu("ValueAxisMaximumValue", b, this.aik);
            }
        }
        get aim() {
            return this.aia;
        }
        set aim(a) {
            let b = this.aim;
            if (a != b) {
                this.aia = a;
                this.vu("ValueAxisMinorInterval", b, this.aim);
            }
        }
        get aii() {
            return this.valueAxis.l4;
        }
        get aih() {
            return this.valueAxis.l3;
        }
        get aif() {
            return this.ah5;
        }
        set aif(a) {
            let b = this.aif;
            if (a != b) {
                this.ah5 = a;
                this.vu("RadiusExtent", b, this.aif);
            }
        }
        get aig() {
            return this.ah6;
        }
        set aig(a) {
            let b = this.aig;
            if (a != b) {
                this.ah6 = a;
                this.vu("StartAngle", b, this.aig);
            }
        }
        get ajq() {
            return this.aiv;
        }
        set ajq(a) {
            let b = this.ajq;
            if (a != b) {
                this.aiv = a;
                this.vu("SliceLabelContentSeparator", b, this.ajq);
            }
        }
        get ahq() {
            return this.aho;
        }
        set ahq(a) {
            let b = this.ahq;
            if (a != b) {
                this.aho = a;
                this.vu("SliceLabelContentMode", enumGetBox(RadialLabelMode_$type, b), enumGetBox(RadialLabelMode_$type, this.ahq));
            }
        }
        get ahp() {
            return this.ahn;
        }
        set ahp(a) {
            let b = this.ahp;
            if (a != b) {
                this.ahn = a;
                this.vu("LegendSliceLabelContentMode", enumGetBox(RadialLabelMode_$type, b), enumGetBox(RadialLabelMode_$type, this.ahp));
            }
        }
        get ahw() {
            return this.ahs;
        }
        set ahw(a) {
            let b = this.ahw;
            if (a != b) {
                this.ahs = a;
                this.vu("AngleAxisFavorLabellingScaleEnd", b, this.ahw);
            }
        }
        get ahy() {
            return this.aht;
        }
        set ahy(a) {
            let b = this.ahy;
            if (a != b) {
                this.aht = a;
                this.vu("ValueAxisAbbreviateLargeNumbers", b, this.ahy);
            }
        }
        get ahc() {
            return this.ahb;
        }
        set ahc(a) {
            let b = this.ahb;
            if (a != b) {
                this.ahb = a;
                this.vu("MarkerCollision", enumGetBox(CollisionAvoidanceType_$type, b), enumGetBox(CollisionAvoidanceType_$type, this.ahb));
            }
        }
    }
    DataPieBaseChart.$t = /*@__PURE__*/ markType(DataPieBaseChart, 'DataPieBaseChart', RadialBaseChart.$);
    return DataPieBaseChart;
})();
