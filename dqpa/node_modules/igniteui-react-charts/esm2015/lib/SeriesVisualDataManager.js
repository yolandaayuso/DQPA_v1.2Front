/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { Base, fromEnum, typeCast, markType, getInstanceType } from "igniteui-react-core";
import { ISeriesVisualDataManager_$type } from "./ISeriesVisualDataManager";
import { StackedSeriesVisualData } from "./StackedSeriesVisualData";
import { SeriesVisualData } from "./SeriesVisualData";
import { MarkerVisualData } from "./MarkerVisualData";
import { RectData } from "igniteui-react-core";
import { PrimitiveAppearanceData } from "igniteui-react-core";
import { DataContext } from "igniteui-react-core";
import { Color } from "igniteui-react-core";
import { ColorData } from "igniteui-react-core";
import { AppearanceHelper } from "igniteui-react-core";
import { PathVisualData } from "igniteui-react-core";
import { PolygonVisualData } from "igniteui-react-core";
import { PolyLineVisualData } from "igniteui-react-core";
import { RectangleVisualData } from "igniteui-react-core";
import { PointerTooltipVisualData } from "./PointerTooltipVisualData";
import { CalloutVisualData } from "./CalloutVisualData";
import { LineVisualData } from "igniteui-react-core";
/**
 * @hidden
 */
export let SeriesVisualDataManager = /*@__PURE__*/ (() => {
    class SeriesVisualDataManager extends Base {
        addSubSeriesVisualData(a, b) {
            let c = a;
            let d = b;
            c.fragmentSeries.add(d);
        }
        addSubSeriesLayerVisualData(a, b) {
            let c = a;
            let d = b;
            c.layers.add(d);
        }
        copyVisualData(a, b) {
            let c = a;
            let d = b;
            for (let e of fromEnum(d.shapes)) {
                c.shapes.add(e);
            }
            for (let f of fromEnum(d.markerShapes)) {
                c.markerShapes.add(f);
            }
            c.pixels = d.pixels;
            c.pixelWidth = d.pixelWidth;
        }
        createFragmentVisualData(a, b, c, d) {
            let e = new SeriesVisualData();
            e.viewport = RectData.b(b);
            e.type = c;
            e.name = d;
            return e;
        }
        exportMarkerVisualData(a, b) {
            let c = b;
            a.w6.cj((d) => {
                let e = this.getMarkerVisualData(a, d, a.x1);
                c.markerShapes.add(typeCast(MarkerVisualData.$, e));
            });
        }
        getMarkerVisualData(a, b, c) {
            let d = new MarkerVisualData();
            let e = new PrimitiveAppearanceData();
            d.x = b.n;
            d.y = b.o;
            d.bounds = new RectData(b.n - (b.m / 2), b.o - (b.l / 2), b.m, b.l);
            e.fill = ColorData.a_1(Color.u(0, 0, 0, 0));
            e.stroke = ColorData.a_1(Color.u(0, 0, 0, 0));
            d.index = -1;
            d.contentTemplate = b.ah;
            if (b.content != null && typeCast(DataContext.$, b.content) !== null && b._visibility == 0) {
                let f = b.content;
                e.fill = AppearanceHelper.b(f.actualItemBrush);
                e.fillExtended = AppearanceHelper.a(f.actualItemBrush);
                e.stroke = AppearanceHelper.b(f.outline);
                e.strokeExtended = AppearanceHelper.a(f.outline);
                e.strokeThickness = a.io();
                if (f.item != null) {
                    d.index = a.dn.indexOf(f.item);
                }
            }
            e.isVisible = b._visibility == 0;
            d.isVisible = b._visibility == 0;
            d.markerAppearance = e;
            d.markerType = this.a(a, c);
            return d;
        }
        a(a, b) {
            if (b == a.db.r1) {
                return "Circle";
            }
            else if (b == a.db.r2) {
                return "Diamond";
            }
            else if (b == a.db.r3) {
                return "Hexagon";
            }
            else if (b == a.db.r4) {
                return "Hexagram";
            }
            else if (b == a.db.r5) {
                return "Pentagon";
            }
            else if (b == a.db.r6) {
                return "Pentagram";
            }
            else if (b == a.db.r7) {
                return "Pyramid";
            }
            else if (b == a.db.r8) {
                return "Square";
            }
            else if (b == a.db.r9) {
                return "Tetragram";
            }
            else if (b == a.db.sa) {
                return "Triangle";
            }
            else {
                return "None";
            }
        }
        exportMarkerVisualDataFromMarker(a, b, c) {
            let d = b;
            let e = new MarkerVisualData();
            let f = new PrimitiveAppearanceData();
            e.x = c.n;
            e.y = c.o;
            e.bounds = new RectData(c.n - (c.m / 2), c.o - (c.l / 2), c.m, c.l);
            e.index = -1;
            e.contentTemplate = c.ah;
            if (typeCast(DataContext.$, c.content) !== null) {
                let g = c.content;
                f.fill = AppearanceHelper.b(g.actualItemBrush);
                f.stroke = AppearanceHelper.b(g.outline);
            }
            e.isVisible = c._visibility == 0;
            e.markerAppearance = f;
            if (c.ah == a.db.r1) {
                e.markerType = "Circle";
            }
            else if (c.ah == a.db.r2) {
                e.markerType = "Diamond";
            }
            else if (c.ah == a.db.r3) {
                e.markerType = "Hexagon";
            }
            else if (c.ah == a.db.r4) {
                e.markerType = "Hexagram";
            }
            else if (c.ah == a.db.r5) {
                e.markerType = "Pentagon";
            }
            else if (c.ah == a.db.r6) {
                e.markerType = "Pentagram";
            }
            else if (c.ah == a.db.r7) {
                e.markerType = "Pyramid";
            }
            else if (c.ah == a.db.r8) {
                e.markerType = "Square";
            }
            else if (c.ah == a.db.r9) {
                e.markerType = "Tetragram";
            }
            else if (c.ah == a.db.sa) {
                e.markerType = "Triangle";
            }
            else {
                e.markerType = "None";
            }
            d.markerShapes.add(e);
        }
        exportPathData(a, b, c, d) {
            let e = a;
            let f = new PathVisualData(1, c, b);
            if (d != null) {
                for (let g = 0; g < d.length; g++) {
                    f.tags.add(d[g]);
                }
            }
            e.shapes.add(f);
        }
        exportPolygonData(a, b, c, d) {
            let e = a;
            let f = new PolygonVisualData(1, c, b);
            if (d != null) {
                for (let g = 0; g < d.length; g++) {
                    f.tags.add(d[g]);
                }
            }
            e.shapes.add(f);
        }
        exportPolylineData(a, b, c, d) {
            let e = a;
            let f = new PolyLineVisualData(1, c, b);
            if (d != null) {
                for (let g = 0; g < d.length; g++) {
                    f.tags.add(d[g]);
                }
            }
            e.shapes.add(f);
        }
        exportRectangleData(a, b, c, d) {
            let e = a;
            let f = new RectangleVisualData(1, c, b);
            if (d != null) {
                for (let g = 0; g < d.length; g++) {
                    f.tags.add(d[g]);
                }
            }
            e.shapes.add(f);
        }
        exportStackedVisualData(a, b) {
            let c = new StackedSeriesVisualData();
            c.viewport = RectData.b(b);
            c.type = getInstanceType(a).typeName;
            c.name = a.name;
            return c;
        }
        exportTrendlineData(a, b, c) {
            let d = b;
            let e = new PolyLineVisualData(1, "trendLine", c);
            e.tags.add("Trend");
            d.shapes.add(e);
        }
        exportVisualData(a, b) {
            let c = new SeriesVisualData();
            c.viewport = RectData.b(b);
            c.type = this.b(getInstanceType(a).typeName);
            c.name = a.name;
            c.opacity = a._opacity;
            return c;
        }
        exportSeriesPixelsData(a, b, c, d) {
            let e = a;
            e.pixels = b;
            e.pixelWidth = c;
            e.pixelHeight = d;
        }
        b(a) {
            return a;
        }
        addPointerTooltipData(a, b, c, d, e) {
            if (b == null) {
                return;
            }
            let f = a;
            let g = b;
            g.offsetX = c;
            g.offsetY = d;
            g.categoryNames = e;
            f.pointerTooltips.add(g);
        }
        addPointerTooltipWithDataLegend(a, b, c, d, e) {
            if (b == null) {
                return;
            }
            let f = a;
            let g = b;
            g.offsetX = c;
            g.offsetY = d;
            g.content = e;
            f.pointerTooltips.add(g);
        }
        exportPointerTooltipData(a, b, c, d) {
            let e = new PointerTooltipVisualData();
            e.pointerFillShape = new PolygonVisualData(1, "fillShape", a);
            e.pointerOutlineShape = new PolyLineVisualData(1, "outlineShape", b);
            e.boxShape = new RectangleVisualData(1, "boxShape", c);
            e.viewport = RectData.b(d);
            return e;
        }
        exportCalloutData(a, b, c, d, e, f, g, h, i, j, k) {
            let l = new CalloutVisualData();
            l.left = a;
            l.top = b;
            l.marginLeft = c;
            l.marginTop = d;
            l.background = new RectangleVisualData(1, "calloutBackground", f);
            l.text = AppearanceHelper.c(g, h);
            l.line = new LineVisualData(1, "calloutLeaderLine", i);
            e.calloutShapes.add(l);
        }
        exportLayerVisualData(a, b) {
            for (let c = 0; c < a.actualLayers.count; c++) {
                b.layers.add1(a.actualLayers._inner[c].target.km());
            }
        }
    }
    SeriesVisualDataManager.$t = /*@__PURE__*/ markType(SeriesVisualDataManager, 'SeriesVisualDataManager', Base.$, [ISeriesVisualDataManager_$type]);
    return SeriesVisualDataManager;
})();
