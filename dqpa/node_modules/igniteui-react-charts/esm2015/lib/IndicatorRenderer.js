/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { Base, fromEnum, Number_$type, Point_$type, typeCast, toEnum, markType } from "igniteui-react-core";
import { PathFigure } from "igniteui-react-core";
import { List$1 } from "igniteui-react-core";
import { LineSegment } from "igniteui-react-core";
import { DelegateClipper } from "./DelegateClipper";
import { Flattener } from "igniteui-react-core";
import { GeometryGroup } from "igniteui-react-core";
import { isNaN_ } from "igniteui-react-core";
/**
 * @hidden
 */
export let IndicatorRenderer = /*@__PURE__*/ (() => {
    class IndicatorRenderer extends Base {
        static h(a, b, c, d) {
            let e = new PathFigure();
            let f = IndicatorRenderer.b(a, b, c, d);
            for (let g of fromEnum(f)) {
                e._segments.add(((() => {
                    let $ret = new LineSegment(1);
                    $ret.c = g;
                    return $ret;
                })()));
            }
            e._startPoint = e._segments._inner[0].c;
            return e;
        }
        static g(a, b, c, d, e, f, g, h, i, j, k) {
            let l = g.an.c;
            let m = h.an.c;
            if (a > 1) {
                let n = new DelegateClipper(b, c, a, k);
                b = n.c;
                c = n.d;
                a = n.e;
            }
            if (i == 1) {
                let o = new List$1(Number_$type, 0);
                let p = l;
                let q = 0;
                o.add(0);
                for (let r = 0, s = 1; s < a; r = s++) {
                    let t = q;
                    let u = c(s) - c(r);
                    if (d && !isNaN_(u)) {
                        t = Math.sign(u);
                    }
                    if (t != 0 && t != q) {
                        p.add(IndicatorRenderer.h(o, b, c, j));
                        q = t;
                        p = q == 1 ? m : l;
                        o.clear();
                        o.add(r);
                    }
                    o.add(s);
                }
                p.add(IndicatorRenderer.h(o, b, c, j));
            }
            else {
                let v = new List$1(Number_$type, 0);
                let w = l;
                let x = 0;
                v.add(0);
                for (let y = 0, z = 1; z < a; y = z++) {
                    let aa = x;
                    let ab = c(z) - c(y);
                    if (d && !isNaN_(ab)) {
                        aa = Math.sign(ab);
                    }
                    if (aa != 0 && aa != x) {
                        if (v.count > 0) {
                            w.add(IndicatorRenderer.h(v, b, c, j));
                        }
                        x = aa;
                        w = x == 1 ? m : l;
                        v.clear();
                        v.add(y);
                    }
                    v.add(z);
                }
                if (v.count > 0) {
                    w.add(IndicatorRenderer.h(v, b, c, j));
                }
            }
        }
        static e(a, b, c, d, e, f, g, h, i, j, k, l, m, n) {
            let o = new List$1(List$1.$.specialize(Point_$type), 0);
            let p = new List$1(List$1.$.specialize(Point_$type), 0);
            let q = new List$1(List$1.$.specialize(Point_$type), 0);
            let r = new List$1(List$1.$.specialize(Point_$type), 0);
            if (a <= 1) {
                n = null;
            }
            k = Math.max(f.top, Math.min(f.bottom, k));
            if (l == 1) {
                let s = new List$1(Number_$type, 0);
                let t = o;
                let u = p;
                let v = 0;
                s.add(0);
                for (let w = 0, x = 1; x < a; w = x++) {
                    let y = v;
                    let z = c(x) - c(w);
                    if (d && !isNaN_(z)) {
                        y = Math.sign(z);
                    }
                    if (y != 0 && y != v) {
                        if (s.count > 0) {
                            let aa = new List$1(Point_$type, 1, IndicatorRenderer.b(s, b, c, m));
                            let ab = new List$1(Point_$type, 1, aa);
                            ab.add({ $type: Point_$type, x: aa._inner[aa.count - 1].x, y: k });
                            ab.add({ $type: Point_$type, x: aa._inner[0].x, y: k });
                            t.add(aa);
                            u.add(ab);
                        }
                        v = y;
                        t = v == 1 ? q : o;
                        u = v == 1 ? r : p;
                        s.clear();
                        s.add(w);
                    }
                    s.add(x);
                }
                let ac = new List$1(Point_$type, 1, IndicatorRenderer.b(s, b, c, m));
                let ad = new List$1(Point_$type, 1, ac);
                ad.add({ $type: Point_$type, x: ac._inner[ac.count - 1].x, y: k });
                ad.add({ $type: Point_$type, x: ac._inner[0].x, y: k });
                t.add(ac);
                u.add(ad);
            }
            else {
                let ae = new List$1(Number_$type, 0);
                let af = o;
                let ag = p;
                let ah = 0;
                ae.add(0);
                for (let ai = 0, aj = 1; aj < a; ai = aj++) {
                    let ak = ah;
                    let al = c(aj) - c(ai);
                    if (d && !isNaN_(al)) {
                        ak = Math.sign(al);
                    }
                    if (ak != 0 && ak != ah) {
                        if (ae.count > 0) {
                            let am = new List$1(Point_$type, 1, IndicatorRenderer.b(ae, b, c, m));
                            let an = new List$1(Point_$type, 1, am);
                            an.add({ $type: Point_$type, x: am._inner[am.count - 1].x, y: k });
                            an.add({ $type: Point_$type, x: am._inner[0].x, y: k });
                            af.add(am);
                            ag.add(an);
                        }
                        ah = ak;
                        af = ah == 1 ? q : o;
                        ag = ah == 1 ? r : p;
                        ae.clear();
                        ae.add(ai);
                    }
                    ae.add(aj);
                }
                let ao = new List$1(Point_$type, 1, IndicatorRenderer.b(ae, b, c, m));
                let ap = new List$1(Point_$type, 1, ao);
                ap.add({ $type: Point_$type, x: ao._inner[ao.count - 1].x, y: k });
                ap.add({ $type: Point_$type, x: ao._inner[0].x, y: k });
                af.add(ao);
                ag.add(ap);
            }
            if (n != null) {
                o = new List$1(List$1.$.specialize(Point_$type), 1, IndicatorRenderer.a(List$1.$.specialize(Point_$type), List$1.$.specialize(Point_$type), o, (aq) => IndicatorRenderer.c(n, aq, false)));
                p = new List$1(List$1.$.specialize(Point_$type), 1, IndicatorRenderer.a(List$1.$.specialize(Point_$type), List$1.$.specialize(Point_$type), p, (aq) => IndicatorRenderer.c(n, aq, true)));
                q = new List$1(List$1.$.specialize(Point_$type), 1, IndicatorRenderer.a(List$1.$.specialize(Point_$type), List$1.$.specialize(Point_$type), q, (aq) => IndicatorRenderer.c(n, aq, false)));
                r = new List$1(List$1.$.specialize(Point_$type), 1, IndicatorRenderer.a(List$1.$.specialize(Point_$type), List$1.$.specialize(Point_$type), r, (aq) => IndicatorRenderer.c(n, aq, true)));
            }
            let aq = g.an.c;
            let ar = h.an.c;
            let as = i.an.c;
            let at = j.an.c;
            IndicatorRenderer.d(aq, o);
            IndicatorRenderer.d(ar, p);
            IndicatorRenderer.d(as, q);
            IndicatorRenderer.d(at, r);
        }
        static f(a, b, c, d, e, f, g, h, i) {
            let j = typeCast(GeometryGroup.$, h.an);
            let k = typeCast(GeometryGroup.$, i.an);
            let l = c;
            let m = b;
            let n = (o) => Math.max(e.left, Math.min(e.right, o));
            let o = (p) => Math.max(e.top, Math.min(e.bottom, p));
            b = (p) => n(m(p));
            c = (p) => o(l(p));
            f = o(f);
            for (let p = 0; p < a; ++p) {
                let q = g.item(p);
                q.d = { $type: Point_$type, x: b(p), y: f };
                q.c = { $type: Point_$type, x: b(p), y: c(p) };
                let r = false;
                if (p > 0) {
                    if (c(p) <= c(p - 1)) {
                        r = true;
                    }
                }
                else {
                    if (a > 1) {
                        if (c(p + 1) <= c(p)) {
                            r = true;
                        }
                    }
                }
                if (r) {
                    j.d.add(q);
                }
                else {
                    k.d.add(q);
                }
            }
            g.count = a;
        }
        static *_b(a, b, c, d) {
            let e = Flattener.a(new List$1(Number_$type, 0), a, b, c, 0, a.count - 1, d);
            for (let f = 0; f < e.count; f++) {
                let g = e.item(f);
                yield { $type: Point_$type, x: b(g), y: c(g) };
            }
        }
        static b(a, b, c, d) {
            return toEnum(() => IndicatorRenderer._b(a, b, c, d));
        }
        static d(a, b) {
            for (let c of fromEnum(b)) {
                if (c.count == 0) {
                    continue;
                }
                let d = ((() => {
                    let $ret = new PathFigure();
                    $ret.startPoint = c._inner[0];
                    return $ret;
                })());
                for (let e of fromEnum(c)) {
                    d._segments.add(((() => {
                        let $ret = new LineSegment(1);
                        $ret.c = e;
                        return $ret;
                    })()));
                }
                a.add(d);
            }
        }
        static c(a, b, c) {
            let d = a.f;
            a.f = c;
            let e = new List$1(Point_$type, 0);
            a.i = e;
            a.k(b, false);
            a.i = null;
            a.f = d;
            return e;
        }
        static *_a($tSource, $tResult, a, b) {
            for (let c of fromEnum(a)) {
                yield b(c);
            }
        }
        static a($tSource, $tResult, a, b) {
            return toEnum(() => IndicatorRenderer._a($tSource, $tResult, a, b));
        }
    }
    IndicatorRenderer.$t = /*@__PURE__*/ markType(IndicatorRenderer, 'IndicatorRenderer');
    return IndicatorRenderer;
})();
