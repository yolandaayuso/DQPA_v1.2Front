/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { TickmarkValues } from "./TickmarkValues";
import { LinearNumericSnapper } from "./LinearNumericSnapper";
import { markType } from "igniteui-react-core";
import { truncate, isNaN_ } from "igniteui-react-core";
/**
 * @hidden
 */
export let LinearTickmarkValues = /*@__PURE__*/ (() => {
    class LinearTickmarkValues extends TickmarkValues {
        constructor() {
            super();
            this.y = 0;
            this.x = 0;
            this.t = null;
            this.u = null;
            this.y = 0;
        }
        s(a) {
            super.s(a);
            let b;
            if (this.y != 0) {
                b = new LinearNumericSnapper(1, a.n, a.m, a.k, this.y, a.h, a.p);
            }
            else {
                b = new LinearNumericSnapper(0, a.n, a.m, a.k, a.h, a.p);
            }
            this.m = b.g;
            if ((a.d) && a.l > 0 && (a.m - a.n) / a.l < 1000) {
                this.m = a.l;
            }
            if (a.i != -1) {
                this.m = a.i;
            }
            if (this.m == 0) {
                this.p = 0;
                this.q = 0;
            }
            else {
                this.p = truncate(Math.floor((a.n - a.g) / this.m));
                this.q = truncate(Math.ceil((a.m - a.g) / this.m));
            }
            this.r = b.j;
            if (a.q != -1) {
                this.r = a.q;
            }
            this.n = a.j;
            this.x = a.g;
        }
        j() {
            let a = 0;
            let b = this.p;
            if (!isNaN_(this.m)) {
                a = this.q - b + 1;
                if (a < 0) {
                    a = 0;
                }
            }
            if (this.t == null || this.t.length != a) {
                this.t = new Array(a);
            }
            let c = this.t;
            for (let d = 0; d < a; ++d) {
                let e = this.x + (d + b) * this.m;
                c[d] = e;
            }
            return c;
        }
        k() {
            if (this.n > 0) {
                return this.w();
            }
            return this.v();
        }
        v() {
            let a = this.p;
            let b = this.q;
            let c = this.r;
            let d = this.m;
            let e = this.x;
            let f = this.o;
            let g = d / c;
            let h = 0;
            for (let i = a; i < b; ++i) {
                if (c > 0) {
                    for (let j = 1; j < c; ++j) {
                        let k = e + i * d + (j * g);
                        if (k <= f) {
                            h++;
                        }
                    }
                }
            }
            if (this.u == null || this.u.length != h) {
                this.u = new Array(h);
            }
            let l = this.u;
            let m = 0;
            for (let n = a; n < b; ++n) {
                if (c > 0) {
                    for (let o = 1; o < c; ++o) {
                        let p = e + n * d + (o * g);
                        if (p <= this.o) {
                            l[m] = p;
                            m++;
                        }
                    }
                }
            }
            return l;
        }
        w() {
            let a = this.p;
            let b = this.q;
            let c = this.r;
            let d = this.m;
            let e = this.x;
            let f = this.o;
            let g = d / c;
            let h = 0;
            for (let i = a; i < b; ++i) {
                let j = e + i * this.m;
                let k = this.o;
                if (i + 1 <= this.q) {
                    k = this.x + ((i + 1) * this.m);
                }
                if (k > this.o) {
                    k = this.o;
                }
                while (j < k) {
                    j += this.n;
                    if (j < k) {
                        h++;
                    }
                }
            }
            if (this.u == null || this.u.length != h) {
                this.u = new Array(h);
            }
            let l = this.u;
            let m = 0;
            for (let n = a; n < b; ++n) {
                let o = e + n * this.m;
                let p = this.o;
                if (n + 1 <= this.q) {
                    p = this.x + ((n + 1) * this.m);
                }
                if (p > this.o) {
                    p = this.o;
                }
                while (o < p) {
                    o += this.n;
                    if (o < p) {
                        l[m] = o;
                        m++;
                    }
                }
            }
            return l;
        }
    }
    LinearTickmarkValues.$t = /*@__PURE__*/ markType(LinearTickmarkValues, 'LinearTickmarkValues', TickmarkValues.$);
    return LinearTickmarkValues;
})();
