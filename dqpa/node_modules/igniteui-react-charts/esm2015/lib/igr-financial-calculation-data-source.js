import { FinancialCalculationDataSource as FinancialCalculationDataSource_internal } from "./FinancialCalculationDataSource";
import { ensureBool } from "igniteui-react-core";
/**
 * Represents the data contract between a financial series and the
 * decoupled calculation responsibilities which implement its mathmatical logic.
 * The FinancialCalculationDataSource contract represents the subset
 * of data which needs to be provided in order to test or run a calculation,
 * and its intentionally a subset of the information available to the series,
 * in order to make calculation strategies more easily testable and usable in isolation to
 * the financial series container.
*/
export class IgrFinancialCalculationDataSource {
    createImplementation() {
        return new FinancialCalculationDataSource_internal();
    }
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor() {
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
    }
    _provideImplementation(i) {
        this._implementation = i;
        this._implementation.externalObject = this;
        this.onImplementationCreated();
    }
    get openColumn() {
        return this.i.series.getOpenColumnAsArray();
    }
    get highColumn() {
        return this.i.series.getHighColumnAsArray();
    }
    get lowColumn() {
        return this.i.series.getLowColumnAsArray();
    }
    get closeColumn() {
        return this.i.series.getCloseColumnAsArray();
    }
    get volumeColumn() {
        return this.i.series.getVolumeColumnAsArray();
    }
    get indicatorColumn() {
        return this.i.series.indicatorColumn.asArray();
    }
    /**
 * An enumerable list of typical prices provided by the series to use
 * in calculations.
*/
    get typicalColumn() {
        const r = this.i.typicalColumn;
        if (r == null) {
            return null;
        }
        return r.externalObject;
    }
    set typicalColumn(v) {
        v == null ? this.i.typicalColumn = null : this.i.typicalColumn = v.i;
    }
    /**
     * And enumerable list of true range values provided by the series to use
     * in calculations.
    */
    get trueRange() {
        const r = this.i.trueRange;
        if (r == null) {
            return null;
        }
        return r.externalObject;
    }
    set trueRange(v) {
        v == null ? this.i.trueRange = null : this.i.trueRange = v.i;
    }
    /**
     * An enumerable list of true low values provided by the series to use
     * in calculations.
    */
    get trueLow() {
        const r = this.i.trueLow;
        if (r == null) {
            return null;
        }
        return r.externalObject;
    }
    set trueLow(v) {
        v == null ? this.i.trueLow = null : this.i.trueLow = v.i;
    }
    /**
     * The period to use when calculating, if applicable.
    */
    get period() {
        return this.i.period;
    }
    set period(v) {
        this.i.period = +v;
    }
    /**
     * The short period to use when calculating, if applicable.
    */
    get shortPeriod() {
        return this.i.shortPeriod;
    }
    set shortPeriod(v) {
        this.i.shortPeriod = +v;
    }
    /**
     * The long period to use when calculating, if applicable.
    */
    get longPeriod() {
        return this.i.longPeriod;
    }
    set longPeriod(v) {
        this.i.longPeriod = +v;
    }
    /**
     * The count of the values in the series.
    */
    get count() {
        return this.i.count;
    }
    set count(v) {
        this.i.count = +v;
    }
    /**
     * The starting index from which to calculate
    */
    get calculateFrom() {
        return this.i.calculateFrom;
    }
    set calculateFrom(v) {
        this.i.calculateFrom = +v;
    }
    /**
     * The number of items from the starting index from which to calculate
    */
    get calculateCount() {
        return this.i.calculateCount;
    }
    set calculateCount(v) {
        this.i.calculateCount = +v;
    }
    /**
     * If the calculation supports some sort of scaling factor,
     * this value will be used.
    */
    get multiplier() {
        return this.i.multiplier;
    }
    set multiplier(v) {
        this.i.multiplier = +v;
    }
    /**
     * If the calculation determines the range of indicator values,
     * it will set the minimum and maximux properties.
     * This will contain the previous minimum value when the indicator
     * calculation is called again, in case this makes the update of the
     * value speedier.
    */
    get minimumValue() {
        return this.i.minimumValue;
    }
    set minimumValue(v) {
        this.i.minimumValue = +v;
    }
    /**
     * If the calculation determines the range of indicator values,
     * it will set the minimum and maximux properties.
     * This will contain the previous minimum value when the indicator
     * calculation is called again, in case this makes the update of the
     * value speedier.
    */
    get maximumValue() {
        return this.i.maximumValue;
    }
    set maximumValue(v) {
        this.i.maximumValue = +v;
    }
    /**
     * The calculation strategy should set this to true if it
     * specifes the minimum and maximum value properties.
    */
    get specifiesRange() {
        return this.i.specifiesRange;
    }
    set specifiesRange(v) {
        this.i.specifiesRange = ensureBool(v);
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        if (this.typicalColumn && this.typicalColumn.name && this.typicalColumn.name == name) {
            return this.typicalColumn;
        }
        if (this.trueRange && this.trueRange.name && this.trueRange.name == name) {
            return this.trueRange;
        }
        if (this.trueLow && this.trueLow.name && this.trueLow.name == name) {
            return this.trueLow;
        }
        return null;
    }
}
