/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { Base, typeCast, Number_$type, markType } from "igniteui-react-core";
import { Brush } from "igniteui-react-core";
import { Color } from "igniteui-react-core";
import { LinearGradientBrush } from "igniteui-react-core";
import { ColorUtil } from "igniteui-react-core";
import { Thickness } from "igniteui-react-core";
import { Axis } from "./Axis";
import { ScalerParams } from "./ScalerParams";
import { List$1 } from "igniteui-react-core";
import { Dictionary$2 } from "igniteui-react-core";
import { Pool$1 } from "igniteui-react-core";
import { AxisAnnotation } from "./AxisAnnotation";
import { HashSet$1 } from "igniteui-react-core";
import { truncate, isNaN_, log10 } from "igniteui-react-core";
import { round10N } from "igniteui-react-core";
/**
 * @hidden
 */
export let AxisAnnotationFrameManager = /*@__PURE__*/ (() => {
    class AxisAnnotationFrameManager extends Base {
        static e(a, b, c) {
            let d = new Color();
            if (typeCast(LinearGradientBrush.$, a) !== null) {
                if (a.gradientStops == null || a.gradientStops.length < 1) {
                    let e = new Brush();
                    e.color = b;
                    return e;
                }
                d = a.gradientStops[0].color;
            }
            else {
                d = a.color;
            }
            let f = ColorUtil.a(d);
            let g = ColorUtil.a(c);
            let h = ColorUtil.a(b);
            let i = (f[3] + 0.05) / (h[3] + 0.05);
            let j = (g[3] + 0.05) / (f[3] + 0.05);
            if (i > j) {
                let k = new Brush();
                k.color = b;
            }
            let l = new Brush();
            l.color = c;
            return l;
        }
        static c(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t) {
            let u = c.ai();
            let v = null;
            let w = null;
            for (let x = 0; x < u.length; x++) {
                if (u[x].cp) {
                    w = u[x];
                }
                else {
                    v = u[x];
                }
            }
            let y = Color.u(255, 102, 102, 102);
            let z = Color.u(255, 255, 255, 255);
            if (v != null) {
                let aa = new ScalerParams(1, d.v4, v.kh, v.ch);
                aa.c = e;
                let ab = v.eo(b.x, aa);
                a.q.add(ab);
                a.p.add(ab);
                if (g != null) {
                    a.h.add(g);
                }
                else {
                    a.h.add(f);
                }
                a.g.add(h);
                if (i != null) {
                    a.o.add(i);
                }
                else {
                    a.o.add(AxisAnnotationFrameManager.e(a.h._inner[a.h.count - 1], y, z));
                }
                a.k.add(k.left);
                a.m.add(k.top);
                a.l.add(k.right);
                a.j.add(k.bottom);
                if (!isNaN_(l)) {
                    a.n.add(l);
                }
                else {
                    a.n.add(NaN);
                }
                if (j != null) {
                    a.i.add(j);
                }
                else {
                    a.i.add(null);
                }
                if (s) {
                    a.f.add(v);
                }
                else {
                    a.f.add(null);
                }
            }
            if (w != null) {
                let ac = new ScalerParams(1, d.v4, w.kh, w.ch);
                ac.c = e;
                let ad = w.eo(b.y, ac);
                a.ac.add(ad);
                a.ab.add(ad);
                if (m != null) {
                    a.t.add(m);
                }
                else {
                    a.t.add(f);
                }
                a.s.add(n);
                if (o != null) {
                    a.aa.add(o);
                }
                else {
                    a.aa.add(AxisAnnotationFrameManager.e(a.t._inner[a.t.count - 1], y, z));
                }
                a.w.add(q.left);
                a.y.add(q.top);
                a.x.add(q.right);
                a.v.add(q.bottom);
                if (!isNaN_(r)) {
                    a.z.add(r);
                }
                else {
                    a.z.add(NaN);
                }
                if (p != null) {
                    a.u.add(p);
                }
                else {
                    a.u.add(null);
                }
                if (t) {
                    a.r.add(w);
                }
                else {
                    a.r.add(null);
                }
            }
        }
        static b(a) {
            a.f.clear();
            a.r.clear();
            a.q.clear();
            a.ac.clear();
            a.p.clear();
            a.ab.clear();
            a.h.clear();
            a.g.clear();
            a.i.clear();
            a.k.clear();
            a.m.clear();
            a.l.clear();
            a.j.clear();
            a.n.clear();
            a.o.clear();
            a.t.clear();
            a.s.clear();
            a.u.clear();
            a.w.clear();
            a.y.clear();
            a.x.clear();
            a.v.clear();
            a.z.clear();
            a.aa.clear();
        }
        static a(a, b, c) {
            if (!b.cj) {
                return a;
            }
            let d = 0;
            if (c >= 0) {
                d = c;
            }
            else {
                let e = b.ex();
                d = e == 0 ? 0 : truncate(Math.max(-Math.floor(log10(e)), 0));
                d += 1;
            }
            return round10N(a, d);
        }
        static d(a, b, c, d, e, f, g, h, i, j) {
            let k = new List$1(Axis.$, 0);
            let l = new HashSet$1(Axis.$, 0);
            let m = new Dictionary$2(Axis.$, Number_$type, 0);
            for (let n = 0; n < b.q.count; n++) {
                if (isNaN_(b.q._inner[n])) {
                    continue;
                }
                let o = b.f._inner[n];
                if (o != null) {
                    if (!l.contains(o)) {
                        k.add(o);
                        m.item(o, 0);
                        l.add_1(o);
                    }
                    let p;
                    if (!d.containsKey(o)) {
                        p = new Pool$1(AxisAnnotation.$);
                        p.create = () => new AxisAnnotation();
                        p.destroy = (q) => {
                        };
                        p.activate = (q) => o.ao.add(q);
                        p.disactivate = (q) => o.ao.remove(q);
                        d.item(o, p);
                        e.add(o);
                    }
                    else {
                        p = d.item(o);
                    }
                    let q = p.item(m.item(o));
                    m.item(o, m.item(o) + 1);
                    q.k = false;
                    q.value = b.p._inner[n];
                    let r = b.q._inner[n];
                    if (i != null) {
                        let s = i(r);
                        q.text = s;
                    }
                    else {
                        r = AxisAnnotationFrameManager.a(r, o, g);
                        if (o.bi != null) {
                            q.text = o.gf(r);
                        }
                    }
                    q.textColor = b.o._inner[n];
                    q.background = b.h._inner[n];
                    q.backgroundCornerRadius = b.g._inner[n];
                    q.backgroundPadding = new Thickness(1, b.k._inner[n], b.m._inner[n], b.l._inner[n], b.j._inner[n]);
                    q.outline = b.i._inner[n];
                    q.strokeThickness = b.n._inner[n];
                    if (q.k) {
                        q.k = false;
                        c = true;
                    }
                }
            }
            for (let t = 0; t < b.ac.count; t++) {
                if (isNaN_(b.ac._inner[t])) {
                    continue;
                }
                let u = b.r._inner[t];
                if (u != null) {
                    if (!l.contains(u)) {
                        k.add(u);
                        m.item(u, 0);
                        l.add_1(u);
                    }
                    let v;
                    if (!d.containsKey(u)) {
                        v = new Pool$1(AxisAnnotation.$);
                        v.create = () => new AxisAnnotation();
                        v.destroy = (w) => {
                        };
                        v.activate = (w) => u.ao.add(w);
                        v.disactivate = (w) => u.ao.remove(w);
                        d.item(u, v);
                        e.add(u);
                    }
                    else {
                        v = d.item(u);
                    }
                    let w = v.item(m.item(u));
                    m.item(u, m.item(u) + 1);
                    w.k = false;
                    let x = b.ac._inner[t];
                    w.value = b.ab._inner[t];
                    if (j != null) {
                        let y = j(x);
                        w.text = y;
                    }
                    else {
                        x = AxisAnnotationFrameManager.a(x, u, h);
                        if (u.bi != null) {
                            w.text = u.gf(x);
                        }
                    }
                    w.textColor = b.aa._inner[t];
                    w.background = b.t._inner[t];
                    w.backgroundCornerRadius = b.s._inner[t];
                    w.backgroundPadding = new Thickness(1, b.w._inner[t], b.y._inner[t], b.x._inner[t], b.v._inner[t]);
                    w.outline = b.u._inner[t];
                    w.strokeThickness = b.z._inner[t];
                    if (w.k) {
                        w.k = false;
                        c = true;
                    }
                }
            }
            for (let z = 0; z < k.count; z++) {
                if (d.containsKey(k._inner[z])) {
                    let aa = d.item(k._inner[z]);
                    aa.count = m.item(k._inner[z]);
                }
            }
            for (let ab = e.count - 1; ab >= 0; ab--) {
                if (!l.contains(e._inner[ab])) {
                    c = true;
                    let ac = d.item(e._inner[ab]);
                    ac.count = 0;
                    ac.activate = null;
                    ac.create = null;
                    ac.destroy = null;
                    ac.disactivate = null;
                    d.removeItem(e._inner[ab]);
                    e.removeAt(ab);
                }
            }
            if (c && f) {
                for (let ad = 0; ad < k.count; ad++) {
                    let ae = k._inner[ad];
                    if (ae.a6.c) {
                        ae.hn(true);
                        ae.a6.c = false;
                    }
                }
            }
        }
    }
    AxisAnnotationFrameManager.$t = /*@__PURE__*/ markType(AxisAnnotationFrameManager, 'AxisAnnotationFrameManager');
    return AxisAnnotationFrameManager;
})();
