import { delegateCombine, delegateRemove } from "igniteui-react-core";
import { IgrSeries } from "./igr-series";
import { IgrCalloutPlacementPositionsCollection } from "./igr-callout-placement-positions-collection";
import { HighlightedValueLabelMode_$type } from "igniteui-react-core";
import { AutoCalloutVisibilityMode_$type } from "./AutoCalloutVisibilityMode";
import { CalloutCollisionMode_$type } from "igniteui-react-core";
import { IgrCalloutStyleUpdatingEventArgs } from "./igr-callout-style-updating-event-args";
import { IgrCalloutRenderStyleUpdatingEventArgs } from "./igr-callout-render-style-updating-event-args";
import { IgrCalloutContentUpdatingEventArgs } from "./igr-callout-content-updating-event-args";
import { IgrCalloutLabelUpdatingEventArgs } from "./igr-callout-label-updating-event-args";
import { IgrCalloutSeriesSelectingEventArgs } from "./igr-callout-series-selecting-event-args";
import { IgrAnnotationLayer } from "./igr-annotation-layer";
import { CalloutLayer } from "./CalloutLayer";
import { ensureBool, ensureEnum, brushToString, stringToBrush, arrayFindByName } from "igniteui-react-core";
import { CalloutPlacementPositionsCollection as CalloutPlacementPositionsCollection_internal } from "./CalloutPlacementPositionsCollection";
import { CalloutPlacementPositions_$type } from "./CalloutPlacementPositions";
import { SyncableObservableCollection$1 } from "igniteui-react-core";
/**
 * Represents an annotation layer that displays crosshair lines that cross through the closest value of the target series under the cursor.
*/
export class IgrCalloutLayer extends IgrAnnotationLayer {
    createImplementation() {
        return new CalloutLayer();
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    constructor(props) {
        super(props);
        this._allowedPositions = null;
        this._calloutStyleUpdating = null;
        this._calloutStyleUpdating_wrapped = null;
        this._calloutRenderStyleUpdating = null;
        this._calloutRenderStyleUpdating_wrapped = null;
        this._calloutContentUpdating = null;
        this._calloutContentUpdating_wrapped = null;
        this._calloutLabelUpdating = null;
        this._calloutLabelUpdating_wrapped = null;
        this._calloutSeriesSelecting = null;
        this._calloutSeriesSelecting_wrapped = null;
    }
    /**
     * Gets whether the series is an callout annotation layer.
    */
    get isAnnotationCalloutLayer() {
        return this.i.eo;
    }
    /**
     * Gets or sets wether or not callout positions adjust auto margin .
    */
    get calloutExpandsAxisBufferEnabled() {
        return this.i.aa4;
    }
    set calloutExpandsAxisBufferEnabled(v) {
        this.i.aa4 = ensureBool(v);
    }
    /**
     * Gets or sets the minimum vertical axis buffer for posititing callouts.
     * This property does not take precedences over the CalloutExpandsAxisBufferMaxHeight property.
    */
    get calloutExpandsAxisBufferMinHeight() {
        return this.i.abs;
    }
    set calloutExpandsAxisBufferMinHeight(v) {
        this.i.abs = +v;
    }
    /**
     * Gets or sets the maximum vertical axis buffer for posititing callouts.
     * This property takes precedences over the CalloutExpandsAxisBufferMinHeight property.
    */
    get calloutExpandsAxisBufferMaxHeight() {
        return this.i.abq;
    }
    set calloutExpandsAxisBufferMaxHeight(v) {
        this.i.abq = +v;
    }
    /**
     * Gets or sets the minimum horizontal axis buffer for posititing callouts.
     * This property does not take precedences over the CalloutExpandsAxisBufferMaxWidth property.
    */
    get calloutExpandsAxisBufferMinWidth() {
        return this.i.abt;
    }
    set calloutExpandsAxisBufferMinWidth(v) {
        this.i.abt = +v;
    }
    /**
     * Gets or sets the maximum horizontal axis buffer for posititing callouts.
     * This property takes precedences over the CalloutExpandsAxisBufferMinWidth property.
    */
    get calloutExpandsAxisBufferMaxWidth() {
        return this.i.abr;
    }
    set calloutExpandsAxisBufferMaxWidth(v) {
        this.i.abr = +v;
    }
    /**
     * Gets or sets the label mapping property for the callouts.
    */
    get labelMemberPath() {
        return this.i.adb;
    }
    set labelMemberPath(v) {
        this.i.adb = v;
    }
    /**
     * Gets or sets the label mapping property for the callouts.
    */
    get xMemberPath() {
        return this.i.adr;
    }
    set xMemberPath(v) {
        this.i.adr = v;
    }
    /**
     * Gets or sets the label mapping property for the callouts.
    */
    get yMemberPath() {
        return this.i.adu;
    }
    set yMemberPath(v) {
        this.i.adu = v;
    }
    /**
     * Gets or sets the key mapping property for the callouts.
    */
    get keyMemberPath() {
        return this.i.ac5;
    }
    set keyMemberPath(v) {
        this.i.ac5 = v;
    }
    /**
     * Gets or sets whether to allow the callouts to be variable distances from the target points, for suppporting collision modes.
    */
    get isCalloutOffsettingEnabled() {
        return this.i.aa6;
    }
    set isCalloutOffsettingEnabled(v) {
        this.i.aa6 = ensureBool(v);
    }
    /**
     * Gets or sets the label format string to use for the label.
    */
    get labelFormat() {
        return this.i.ac8;
    }
    set labelFormat(v) {
        this.i.ac8 = v;
    }
    /**
     * Gets or sets the format specifiers to use with the LabelFormat string.
    */
    get labelFormatSpecifiers() {
        return this.i.zy;
    }
    set labelFormatSpecifiers(v) {
        if (v && !Array.isArray(v) && typeof (v) == "string") {
            const re = /\s*(?:,|\s|$)\s*/gm;
            v = v.split(re);
        }
        this.i.zy = v;
    }
    /**
     * Gets or sets the content mapping property for the callouts.
    */
    get contentMemberPath() {
        return this.i.acx;
    }
    set contentMemberPath(v) {
        this.i.acx = v;
    }
    /**
     * Gets or sets the name of the series series to target this annotation to. If null, this annotation targets all series simultaneously.
    */
    get targetSeriesName() {
        return this.i.ade;
    }
    set targetSeriesName(v) {
        this.i.ade = v;
    }
    /**
     * Gets or sets the series to target this annotation to. If null, this annotation targets all series simultaneously.
    */
    get targetSeries() {
        const r = this.i.aaf;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = IgrSeries._createFromInternal(r);
            if (e) {
                e._implementation = r;
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set targetSeries(v) {
        if (v != null && this._stylingContainer && v._styling)
            v._styling(this._stylingContainer, this, this);
        v == null ? this.i.aaf = null : this.i.aaf = v.i;
    }
    /**
     * Gets or sets a channel name to identify other callout layers within the chart to share collision information with.
    */
    get collisionChannel() {
        return this.i.acu;
    }
    set collisionChannel(v) {
        this.i.acu = v;
    }
    /**
     * Gets or sets the allowed positions that the callout layer is allowed to use.
    */
    get allowedPositions() {
        if (this._allowedPositions === null) {
            let coll = new IgrCalloutPlacementPositionsCollection();
            let innerColl = this.i.aaa;
            if (!innerColl) {
                innerColl = new CalloutPlacementPositionsCollection_internal();
            }
            this._allowedPositions = coll._fromInner(innerColl);
            this.i.aaa = innerColl;
        }
        return this._allowedPositions;
    }
    set allowedPositions(v) {
        if (this._allowedPositions !== null) {
            this._allowedPositions._setSyncTarget(null);
            this._allowedPositions = null;
        }
        let coll = new IgrCalloutPlacementPositionsCollection();
        this._allowedPositions = coll._fromOuter(v);
        let syncColl = new SyncableObservableCollection$1(CalloutPlacementPositions_$type);
        let innerColl = this.i.aaa;
        if (!innerColl) {
            innerColl = new CalloutPlacementPositionsCollection_internal();
        }
        syncColl._inner = innerColl;
        syncColl.clear();
        this._allowedPositions._setSyncTarget(syncColl);
        this.i.aaa = innerColl;
    }
    /**
     * Gets or sets how to select the final value to annotate.
    */
    get isAutoCalloutBehaviorEnabled() {
        return this.i.aa5;
    }
    set isAutoCalloutBehaviorEnabled(v) {
        this.i.aa5 = ensureBool(v);
    }
    /**
     * Gets or sets whether to use values, rather than labels for auto callout labels.
    */
    get useInterpolatedValueForAutoCalloutLabels() {
        return this.i.abb;
    }
    set useInterpolatedValueForAutoCalloutLabels(v) {
        this.i.abb = ensureBool(v);
    }
    /**
     * Gets or sets whether to the series color as the outline of the callout.
    */
    get useSeriesColorForOutline() {
        return this.i.abe;
    }
    set useSeriesColorForOutline(v) {
        this.i.abe = ensureBool(v);
    }
    /**
     * Gets or sets whether to the label color is automatically decided between a light and dark option for contrast.
    */
    get useAutoContrastingLabelColors() {
        return this.i.aba;
    }
    set useAutoContrastingLabelColors(v) {
        this.i.aba = ensureBool(v);
    }
    /**
     * Gets or sets whether to the series color as the outline of the callout.
    */
    get useItemColorForFill() {
        return this.i.abc;
    }
    set useItemColorForFill(v) {
        this.i.abc = ensureBool(v);
    }
    /**
     * Gets or sets whether to the series item color as the outline of the callout.
    */
    get useItemColorForOutline() {
        return this.i.abd;
    }
    set useItemColorForOutline(v) {
        this.i.abd = ensureBool(v);
    }
    /**
     * Gets or sets whether to use values, rather than labels for auto callout labels.
    */
    get useValueForAutoCalloutLabels() {
        return this.i.abf;
    }
    set useValueForAutoCalloutLabels(v) {
        this.i.abf = ensureBool(v);
    }
    /**
     * Gets or sets whether to use values, rather than labels for auto callout labels.
    */
    get highlightedValueLabelMode() {
        return this.i.aae;
    }
    set highlightedValueLabelMode(v) {
        this.i.aae = ensureEnum(HighlightedValueLabelMode_$type, v);
    }
    /**
     * Gets or sets the rules for when the callouts should be visible.
    */
    get autoCalloutVisibilityMode() {
        return this.i.z3;
    }
    set autoCalloutVisibilityMode(v) {
        this.i.z3 = ensureEnum(AutoCalloutVisibilityMode_$type, v);
    }
    /**
     * Gets or sets the corner radius to use for the callout borders.
    */
    get calloutCornerRadius() {
        return this.i.abp;
    }
    set calloutCornerRadius(v) {
        this.i.abp = +v;
    }
    /**
     * Gets or sets whether to allow for custom callout styles.
    */
    get isCustomCalloutStyleEnabled() {
        return this.i.aa8;
    }
    set isCustomCalloutStyleEnabled(v) {
        this.i.aa8 = ensureBool(v);
    }
    /**
     * Gets or sets whether to allow for custom callout styles.
    */
    get isCustomCalloutRenderStyleEnabled() {
        return this.i.aa7;
    }
    set isCustomCalloutRenderStyleEnabled(v) {
        this.i.aa7 = ensureBool(v);
    }
    /**
     * Gets or sets the precision to use when values are used for the auto callout labels.
    */
    get autoCalloutLabelPrecision() {
        return this.i.ab2;
    }
    set autoCalloutLabelPrecision(v) {
        this.i.ab2 = +v;
    }
    /**
     * Gets or sets the color to use for the callout text. Leave unset for an automatic value.
    */
    get calloutTextColor() {
        return brushToString(this.i.afr);
    }
    set calloutTextColor(v) {
        this.i.afr = stringToBrush(v);
    }
    /**
     * Gets or sets the light color to use for the callout text. Leave unset for an automatic value.
    */
    get calloutLightTextColor() {
        return brushToString(this.i.afp);
    }
    set calloutLightTextColor(v) {
        this.i.afp = stringToBrush(v);
    }
    /**
     * Gets or sets the dark color to use for the callout text. Leave unset for an automatic value.
    */
    get calloutDarkTextColor() {
        return brushToString(this.i.afn);
    }
    set calloutDarkTextColor(v) {
        this.i.afn = stringToBrush(v);
    }
    /**
     * Gets or sets the brush that specifies how the backgrounds for the callouts of the layer are painted. Leave unset for an automatic value.
    */
    get calloutBackground() {
        return brushToString(this.i.afm);
    }
    set calloutBackground(v) {
        this.i.afm = stringToBrush(v);
    }
    /**
     * Gets or sets whether the callouts that collide with the boundary should be truncated.
    */
    get shouldTruncateOnBoundaryCollisions() {
        return this.i.aa9;
    }
    set shouldTruncateOnBoundaryCollisions(v) {
        this.i.aa9 = ensureBool(v);
    }
    /**
     * Gets or sets the precision to use displaying values for interpolated crosshair positions.
    */
    get calloutInterpolatedValuePrecision() {
        return this.i.ab3;
    }
    set calloutInterpolatedValuePrecision(v) {
        this.i.ab3 = +v;
    }
    /**
     * Gets or sets the brush that specifies how the outlines for the callouts of the layer are painted.
    */
    get calloutOutline() {
        return brushToString(this.i.afq);
    }
    set calloutOutline(v) {
        this.i.afq = stringToBrush(v);
    }
    /**
     * Gets or sets the brush that specifies how the leader lines for the callouts of the layer are painted.
    */
    get calloutLeaderBrush() {
        return brushToString(this.i.afo);
    }
    set calloutLeaderBrush(v) {
        this.i.afo = stringToBrush(v);
    }
    /**
     * Gets or sets the left padding to use withing the callout. Leaving this NaN will use an automatic value related to the axis label margins.
    */
    get calloutPaddingLeft() {
        return this.i.abv;
    }
    set calloutPaddingLeft(v) {
        this.i.abv = +v;
    }
    /**
     * Gets or sets the top padding to use within the callout. Leaving this NaN will use an automatic value related to the axis label margins.
    */
    get calloutPaddingTop() {
        return this.i.abx;
    }
    set calloutPaddingTop(v) {
        this.i.abx = +v;
    }
    /**
     * Gets or sets the right padding to use within the callout. Leaving this NaN will use an automatic value related to the axis label margins.
    */
    get calloutPaddingRight() {
        return this.i.abw;
    }
    set calloutPaddingRight(v) {
        this.i.abw = +v;
    }
    /**
     * Gets or sets the bottom padding to use within the callout. Leaving this NaN will use an automatic value related to the axis label margins.
    */
    get calloutPaddingBottom() {
        return this.i.abu;
    }
    set calloutPaddingBottom(v) {
        this.i.abu = +v;
    }
    /**
     * Gets or sets the strategy to use for avoiding collisions between the callouts in this layer. Leave unset for an automatic value.
    */
    get calloutCollisionMode() {
        return this.i.z5;
    }
    set calloutCollisionMode(v) {
        this.i.z5 = ensureEnum(CalloutCollisionMode_$type, v);
    }
    /**
     * Gets or sets the padding to add to the callout positioning. Leave unset for an automatic value.
    */
    get calloutPositionPadding() {
        return this.i.aby;
    }
    set calloutPositionPadding(v) {
        this.i.aby = +v;
    }
    /**
     * Gets or sets the stroke thickness for the callout backing. Leave unset for an automatic value.
    */
    get calloutStrokeThickness() {
        return this.i.abz;
    }
    set calloutStrokeThickness(v) {
        this.i.abz = +v;
    }
    /**
     * Gets or sets the stroke thickness for the axis annotation backing. Leave unset for an automatic value.
    */
    get textStyle() {
        return this.i.adh;
    }
    set textStyle(v) {
        this.i.adh = v;
    }
    findByName(name) {
        var baseResult = super.findByName(name);
        if (baseResult) {
            return baseResult;
        }
        if (this.labelFormatSpecifiers != null && arrayFindByName(this.labelFormatSpecifiers, name)) {
            return arrayFindByName(this.labelFormatSpecifiers, name);
        }
        if (this.targetSeries && this.targetSeries.name && this.targetSeries.name == name) {
            return this.targetSeries;
        }
        if (this.allowedPositions != null && this.allowedPositions.findByName && this.allowedPositions.findByName(name)) {
            return this.allowedPositions.findByName(name);
        }
        return null;
    }
    _styling(container, component, parent) {
        super._styling(container, component, parent);
        this._inStyling = true;
        if (this.targetSeries && this.targetSeries._styling) {
            this.targetSeries._styling(container, component, this);
        }
        this._inStyling = false;
    }
    getItemValue(item, memberPathName) {
        let iv = this.i.kq(item, memberPathName);
        return (iv);
    }
    /**
     * Gets the value of a requested member path from the series.
    
    * @param memberPathName  * The property name of a valid member path for the series
    */
    getMemberPathValue(memberPathName) {
        let iv = this.i.md(memberPathName);
        return (iv);
    }
    /**
     * Invalidates content of callout layer
    
    */
    invalidateCalloutContent() {
        this.i.ad4();
    }
    /**
     * Event raised when updating style of callout layer
    */
    get calloutStyleUpdating() {
        return this._calloutStyleUpdating;
    }
    set calloutStyleUpdating(ev) {
        if (this._calloutStyleUpdating_wrapped !== null) {
            this.i.calloutStyleUpdating = delegateRemove(this.i.calloutStyleUpdating, this._calloutStyleUpdating_wrapped);
            this._calloutStyleUpdating_wrapped = null;
            this._calloutStyleUpdating = null;
        }
        this._calloutStyleUpdating = ev;
        this._calloutStyleUpdating_wrapped = (o, e) => {
            let outerArgs = new IgrCalloutStyleUpdatingEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeCalloutStyleUpdating) {
                this.beforeCalloutStyleUpdating(this, outerArgs);
            }
            if (this._calloutStyleUpdating) {
                this._calloutStyleUpdating(this, outerArgs);
            }
        };
        this.i.calloutStyleUpdating = delegateCombine(this.i.calloutStyleUpdating, this._calloutStyleUpdating_wrapped);
        ;
    }
    /**
     * Event raised when updating style of callout layer
    */
    get calloutRenderStyleUpdating() {
        return this._calloutRenderStyleUpdating;
    }
    set calloutRenderStyleUpdating(ev) {
        if (this._calloutRenderStyleUpdating_wrapped !== null) {
            this.i.calloutRenderStyleUpdating = delegateRemove(this.i.calloutRenderStyleUpdating, this._calloutRenderStyleUpdating_wrapped);
            this._calloutRenderStyleUpdating_wrapped = null;
            this._calloutRenderStyleUpdating = null;
        }
        this._calloutRenderStyleUpdating = ev;
        this._calloutRenderStyleUpdating_wrapped = (o, e) => {
            let outerArgs = new IgrCalloutRenderStyleUpdatingEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeCalloutRenderStyleUpdating) {
                this.beforeCalloutRenderStyleUpdating(this, outerArgs);
            }
            if (this._calloutRenderStyleUpdating) {
                this._calloutRenderStyleUpdating(this, outerArgs);
            }
        };
        this.i.calloutRenderStyleUpdating = delegateCombine(this.i.calloutRenderStyleUpdating, this._calloutRenderStyleUpdating_wrapped);
        ;
    }
    /**
     * Raised to allow you to decide on the content for an automatically created callout.
    */
    get calloutContentUpdating() {
        return this._calloutContentUpdating;
    }
    set calloutContentUpdating(ev) {
        if (this._calloutContentUpdating_wrapped !== null) {
            this.i.calloutContentUpdating = delegateRemove(this.i.calloutContentUpdating, this._calloutContentUpdating_wrapped);
            this._calloutContentUpdating_wrapped = null;
            this._calloutContentUpdating = null;
        }
        this._calloutContentUpdating = ev;
        this._calloutContentUpdating_wrapped = (o, e) => {
            let outerArgs = new IgrCalloutContentUpdatingEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeCalloutContentUpdating) {
                this.beforeCalloutContentUpdating(this, outerArgs);
            }
            if (this._calloutContentUpdating) {
                this._calloutContentUpdating(this, outerArgs);
            }
        };
        this.i.calloutContentUpdating = delegateCombine(this.i.calloutContentUpdating, this._calloutContentUpdating_wrapped);
        ;
    }
    /**
     * Raised to allow you to decide on the label for an automatically created callout.
    */
    get calloutLabelUpdating() {
        return this._calloutLabelUpdating;
    }
    set calloutLabelUpdating(ev) {
        if (this._calloutLabelUpdating_wrapped !== null) {
            this.i.calloutLabelUpdating = delegateRemove(this.i.calloutLabelUpdating, this._calloutLabelUpdating_wrapped);
            this._calloutLabelUpdating_wrapped = null;
            this._calloutLabelUpdating = null;
        }
        this._calloutLabelUpdating = ev;
        this._calloutLabelUpdating_wrapped = (o, e) => {
            let outerArgs = new IgrCalloutLabelUpdatingEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeCalloutLabelUpdating) {
                this.beforeCalloutLabelUpdating(this, outerArgs);
            }
            if (this._calloutLabelUpdating) {
                this._calloutLabelUpdating(this, outerArgs);
            }
        };
        this.i.calloutLabelUpdating = delegateCombine(this.i.calloutLabelUpdating, this._calloutLabelUpdating_wrapped);
        ;
    }
    /**
     * Raised to allow you to select a target series for a data bound callout.
    */
    get calloutSeriesSelecting() {
        return this._calloutSeriesSelecting;
    }
    set calloutSeriesSelecting(ev) {
        if (this._calloutSeriesSelecting_wrapped !== null) {
            this.i.calloutSeriesSelecting = delegateRemove(this.i.calloutSeriesSelecting, this._calloutSeriesSelecting_wrapped);
            this._calloutSeriesSelecting_wrapped = null;
            this._calloutSeriesSelecting = null;
        }
        this._calloutSeriesSelecting = ev;
        this._calloutSeriesSelecting_wrapped = (o, e) => {
            let outerArgs = new IgrCalloutSeriesSelectingEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeCalloutSeriesSelecting) {
                this.beforeCalloutSeriesSelecting(this, outerArgs);
            }
            if (this._calloutSeriesSelecting) {
                this._calloutSeriesSelecting(this, outerArgs);
            }
        };
        this.i.calloutSeriesSelecting = delegateCombine(this.i.calloutSeriesSelecting, this._calloutSeriesSelecting_wrapped);
        ;
    }
}
