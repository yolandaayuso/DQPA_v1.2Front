/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { Base, fromEnum, Number_$type, Point_$type, markType } from "igniteui-react-core";
import { PointCollection } from "igniteui-react-core";
import { List$1 } from "igniteui-react-core";
import { PathGeometry } from "igniteui-react-core";
import { PolyLineSegment } from "igniteui-react-core";
import { PathFigure } from "igniteui-react-core";
import { PathFigureCollection } from "igniteui-react-core";
import { FastFlattener } from "igniteui-react-core";
import { ArrayAccessHelper } from "igniteui-react-core";
import { isNaN_ } from "igniteui-react-core";
/**
 * @hidden
 */
export let CategoryLineRasterizer = /*@__PURE__*/ (() => {
    class CategoryLineRasterizer extends Base {
        constructor() {
            super(...arguments);
            this.a = false;
            this.n = new PointCollection(0);
        }
        get o() {
            return this.n;
        }
        set o(a) {
            this.n = a;
        }
        m(a, b, c, d, e, f, g, h, i, j) {
            let k = new PathGeometry();
            let l = new PathGeometry();
            let m = new PathGeometry();
            a.an = k;
            b.an = l;
            c.an = m;
            k.c = new PathFigureCollection();
            l.c = new PathFigureCollection();
            m.c = new PathFigureCollection();
            let n = new List$1(PolyLineSegment.$, 0);
            let o = new List$1(PolyLineSegment.$, 0);
            let p = new List$1(PolyLineSegment.$, 0);
            let q = new List$1(PolyLineSegment.$, 0);
            if (g == 0 || g == 1) {
                let r = g == 1 ? h : null;
                let s = 0;
                for (let t = 0; t < d; t++) {
                    if (isNaN_(e._inner[t][1])) {
                        let u = t - s;
                        let v = (g == 0 && u > 0) || (g == 1 && u > 1);
                        if (v) {
                            if (g == 1 || n.count == 0) {
                                let w = new PolyLineSegment();
                                let x = new PolyLineSegment();
                                let y = new PolyLineSegment();
                                let z = new PolyLineSegment();
                                n.add(w);
                                o.add(x);
                                p.add(y);
                                q.add(z);
                            }
                            this.l(n._inner[n.count - 1]._points, o._inner[o.count - 1]._points, p._inner[p.count - 1]._points, q._inner[q.count - 1]._points, s, t - 1, e, f, r, i, j);
                        }
                        s = t + 1;
                    }
                }
                if (g == 1 || n.count == 0) {
                    let aa = new PolyLineSegment();
                    let ab = new PolyLineSegment();
                    let ac = new PolyLineSegment();
                    let ad = new PolyLineSegment();
                    n.add(aa);
                    o.add(ad);
                    p.add(ab);
                    q.add(ac);
                }
                this.l(n._inner[n.count - 1]._points, o._inner[o.count - 1]._points, p._inner[p.count - 1]._points, q._inner[q.count - 1]._points, s, d - 1, e, f, r, i, j);
                if (r == null && n.count == 1 && h != null) {
                    this.d(n._inner[0], h);
                    if (o.count == 1) {
                        this.d(o._inner[0], h);
                    }
                }
            }
            else {
                n.add(new PolyLineSegment());
                o.add(new PolyLineSegment());
                p.add(new PolyLineSegment());
                q.add(new PolyLineSegment());
                this.k(n._inner[0]._points, o._inner[0]._points, p._inner[0]._points, q._inner[0]._points, d, e, f, h, i, j);
            }
            for (let ae = 0; ae < n.count; ae++) {
                let af = n._inner[ae];
                let ag = o._inner[ae];
                let ah = p._inner[ae];
                let ai = q._inner[ae];
                if (af._points.count > 0) {
                    let aj = ((() => {
                        let $ret = new PathFigure();
                        $ret.startPoint = af._points._inner[0];
                        return $ret;
                    })());
                    aj._segments.add(af);
                    k.c.add(aj);
                }
                if (ag._points.count > 0) {
                    let ak = ((() => {
                        let $ret = new PathFigure();
                        $ret.startPoint = ag._points._inner[0];
                        return $ret;
                    })());
                    ak._segments.add(ag);
                    m.c.add(ak);
                }
                if (ah._points.count > 0 && ai._points.count > 0) {
                    let al = new PolyLineSegment();
                    if (h != null) {
                        let am = h.f;
                        h.f = true;
                        h.i = al._points;
                        h.k(ah._points, false);
                        h.k(ai._points, true);
                        h.i = null;
                        h.f = am;
                    }
                    else {
                        for (let an of fromEnum(ah._points)) {
                            al._points.add(an);
                        }
                        for (let ao = ai._points.count - 1; ao >= 0; ao--) {
                            al._points.add(ai._points._inner[ao]);
                        }
                    }
                    if (al._points.count > 0) {
                        let ap = ((() => {
                            let $ret = new PathFigure();
                            $ret.startPoint = al._points._inner[0];
                            return $ret;
                        })());
                        ap._segments.add(al);
                        l.c.add(ap);
                    }
                }
            }
        }
        d(a, b) {
            let c = a._points;
            a._points = new PointCollection(0);
            b.i = a._points;
            b.k(c, false);
            b.i = null;
        }
        k(a, b, c, d, e, f, g, h, i, j) {
            this.l(a, b, c, d, 0, e - 1, f, g, h, i, j);
        }
        e(a, b, c, d, e, f, g) {
            let h = FastFlattener.a(new List$1(Number_$type, 0), d, e, f, b, c, g);
            let i = ArrayAccessHelper.c(h);
            let j = ArrayAccessHelper.a(d);
            let k = i != null;
            let l = j != null;
            let m = 0;
            let n = h.count;
            let o;
            let p;
            let q;
            if (e) {
                for (let r = 0; r < n; r++) {
                    m = k ? i[r] : h.item(r);
                    o = l ? j[m] : d._inner[m];
                    p = o[0];
                    q = o[1];
                    let s = { $type: Point_$type, x: p, y: q };
                    a.add(s);
                }
            }
            else if (f) {
                for (let t = 0; t < n; t++) {
                    m = k ? i[t] : h.item(t);
                    o = l ? j[m] : d._inner[m];
                    p = o[0];
                    q = o[2];
                    let u = { $type: Point_$type, x: p, y: q };
                    a.add(u);
                }
            }
            else {
                for (let v = 0; v < n; v++) {
                    m = k ? i[v] : h.item(v);
                    o = l ? j[m] : d._inner[m];
                    p = o[2];
                    q = o[3];
                    let w = { $type: Point_$type, x: p, y: q };
                    a.add(w);
                }
            }
        }
        b(a, b, c, d) {
            c.i = a;
            c.k(b, false);
            c.i = null;
        }
        c(a, b, c, d, e) {
            let f = c.f;
            c.f = e;
            this.b(a, b, c, d);
            c.f = f;
        }
        l(a, b, c, d, e, f, g, h, i, j, k) {
            if (f > -1) {
                if (j == 1 && !this.a) {
                    let l = new PointCollection(0);
                    this.e(l, e, f, g, true, h, k);
                    if (i != null) {
                        this.b(a, l, i, k);
                    }
                    else {
                        this.f(a, l);
                    }
                }
                else {
                    let m = new PointCollection(0);
                    let n = new PointCollection(0);
                    this.e(m, e, f, g, true, h, k);
                    this.e(n, e, f, g, false, h, k);
                    this.f(c, m);
                    this.f(d, n);
                    if (i != null) {
                        this.b(a, m, i, k);
                        this.b(b, n, i, k);
                    }
                    else {
                        this.f(a, m);
                        this.f(b, n);
                    }
                }
            }
        }
        i(a, b, c, d, e, f, g, h, i, j, k) {
            this.j(a, b, c, d, e, f, g, h, i, j, k, null);
        }
        j(a, b, c, d, e, f, g, h, i, j, k, l) {
            let m = new PathGeometry();
            let n = new PathGeometry();
            let o = new PathGeometry();
            let p = new PathGeometry();
            a.an = m;
            b.an = n;
            c.an = o;
            d.an = p;
            m.c = new PathFigureCollection();
            n.c = new PathFigureCollection();
            o.c = new PathFigureCollection();
            p.c = new PathFigureCollection();
            let q = new List$1(PolyLineSegment.$, 0);
            let r = new List$1(PolyLineSegment.$, 0);
            let s = new List$1(PolyLineSegment.$, 0);
            let t = new List$1(PolyLineSegment.$, 0);
            if (k == 0 || k == 1) {
                let u = k == 1 ? l : null;
                let v = 0;
                for (let w = 0; w < e; w++) {
                    if (isNaN_(f._inner[w][1])) {
                        let x = w - v;
                        let y = (k == 0 && x > 0) || (k == 1 && x > 1);
                        if (y) {
                            if (k == 1 || r.count == 0) {
                                let z = new PolyLineSegment();
                                let aa = new PolyLineSegment();
                                let ab = new PolyLineSegment();
                                let ac = new PolyLineSegment();
                                q.add(z);
                                r.add(aa);
                                s.add(ab);
                                t.add(ac);
                            }
                            let ad;
                            let ae;
                            let af;
                            let ag;
                            if (l != null && k == 1) {
                                ad = new PointCollection(0);
                                ae = new PointCollection(0);
                                af = new PointCollection(0);
                                ag = new PointCollection(0);
                            }
                            else {
                                ad = q._inner[q.count - 1]._points;
                                ae = r._inner[r.count - 1]._points;
                                af = s._inner[s.count - 1]._points;
                                ag = t._inner[t.count - 1]._points;
                            }
                            this.g(ad, ae, af, ag, v, w - 1, f, g, null, h, i);
                            if (k == 1) {
                                j(ad, ae, af, ag, false);
                                if (l != null) {
                                    this.c(q._inner[q.count - 1]._points, ad, l, i, true);
                                    this.c(r._inner[r.count - 1]._points, ae, l, i, false);
                                    this.c(s._inner[s.count - 1]._points, af, l, i, true);
                                    this.c(t._inner[t.count - 1]._points, ag, l, i, false);
                                }
                            }
                        }
                        v = w + 1;
                    }
                }
                if (k == 1 || r.count == 0) {
                    let ah = new PolyLineSegment();
                    let ai = new PolyLineSegment();
                    let aj = new PolyLineSegment();
                    let ak = new PolyLineSegment();
                    q.add(ah);
                    r.add(ai);
                    s.add(aj);
                    t.add(ak);
                }
                let al;
                let am;
                let an;
                let ao;
                if (l != null) {
                    al = new PointCollection(0);
                    this.f(al, q._inner[q.count - 1]._points);
                    am = new PointCollection(0);
                    this.f(am, r._inner[r.count - 1]._points);
                    an = new PointCollection(0);
                    this.f(an, s._inner[s.count - 1]._points);
                    ao = new PointCollection(0);
                    this.f(ao, t._inner[t.count - 1]._points);
                    q._inner[q.count - 1]._points.clear();
                    r._inner[r.count - 1]._points.clear();
                    s._inner[s.count - 1]._points.clear();
                    t._inner[t.count - 1]._points.clear();
                }
                else {
                    al = q._inner[q.count - 1]._points;
                    am = r._inner[r.count - 1]._points;
                    an = s._inner[s.count - 1]._points;
                    ao = t._inner[t.count - 1]._points;
                }
                this.g(al, am, an, ao, v, e - 1, f, g, null, h, i);
                j(al, am, an, ao, true);
                if (l != null) {
                    this.c(q._inner[q.count - 1]._points, al, l, i, true);
                    this.c(r._inner[r.count - 1]._points, am, l, i, false);
                    this.c(s._inner[s.count - 1]._points, an, l, i, true);
                    this.c(t._inner[t.count - 1]._points, ao, l, i, false);
                }
            }
            else {
                q.add(new PolyLineSegment());
                r.add(new PolyLineSegment());
                s.add(new PolyLineSegment());
                t.add(new PolyLineSegment());
                this.h(q._inner[0]._points, r._inner[0]._points, s._inner[0]._points, t._inner[0]._points, 0, e - 1, f, g, h, i);
                j(q._inner[0]._points, r._inner[0]._points, s._inner[0]._points, t._inner[0]._points, true);
            }
            for (let ap = 0; ap < r.count; ap++) {
                let aq = q._inner[ap];
                let ar = r._inner[ap];
                let as = s._inner[ap];
                let at = t._inner[ap];
                if (aq._points.count > 0) {
                    let au = ((() => {
                        let $ret = new PathFigure();
                        $ret.startPoint = aq._points._inner[0];
                        return $ret;
                    })());
                    au._segments.add(aq);
                    m.c.add(au);
                }
                if (ar._points.count > 0) {
                    let av = ((() => {
                        let $ret = new PathFigure();
                        $ret.startPoint = ar._points._inner[0];
                        return $ret;
                    })());
                    av._segments.add(ar);
                    n.c.add(av);
                }
                if (as._points.count > 0) {
                    let aw = ((() => {
                        let $ret = new PathFigure();
                        $ret.startPoint = as._points._inner[0];
                        return $ret;
                    })());
                    aw._segments.add(as);
                    o.c.add(aw);
                }
                if (at._points.count > 0) {
                    let ax = ((() => {
                        let $ret = new PathFigure();
                        $ret.startPoint = at._points._inner[0];
                        return $ret;
                    })());
                    ax._segments.add(at);
                    p.c.add(ax);
                }
            }
        }
        h(a, b, c, d, e, f, g, h, i, j) {
            this.g(a, b, c, d, e, f, g, h, null, i, j);
        }
        g(a, b, c, d, e, f, g, h, i, j, k) {
            this.o.clear();
            if (j == 1 && !this.a) {
                let l = FastFlattener.a(new List$1(Number_$type, 0), g, true, h, e, f, k);
                let m = l.count;
                let n = 0;
                let o;
                let p;
                let q;
                let r = new PointCollection(0);
                for (let s = 0; s < m; s++) {
                    n = l.item(s);
                    o = g._inner[n];
                    p = o[0];
                    q = o[1];
                    r.add({ $type: Point_$type, x: p, y: q });
                }
                if (i != null) {
                    this.c(a, r, i, k, true);
                    this.c(d, r, i, k, false);
                    this.c(this.o, r, i, k, false);
                }
                else {
                    this.f(a, r);
                    this.f(d, r);
                    this.f(this.o, r);
                }
            }
            else {
                let t = FastFlattener.a(new List$1(Number_$type, 0), g, true, h, e, f, k);
                let u = FastFlattener.a(new List$1(Number_$type, 0), g, false, h, e, f, k);
                let v = t.count;
                let w = u.count;
                let x = 0;
                let y;
                let z;
                let aa;
                let ab = new PointCollection(0);
                let ac = new PointCollection(0);
                for (let ad = 0; ad < v; ad++) {
                    x = t.item(ad);
                    y = g._inner[x];
                    z = y[0];
                    aa = y[1];
                    ab.add({ $type: Point_$type, x: z, y: aa });
                    ac.add({ $type: Point_$type, x: z, y: aa });
                }
                let ae = new PointCollection(0);
                let af;
                let ag;
                for (let ah = w - 1; ah >= 0; ah--) {
                    x = u.item(ah);
                    y = g._inner[x];
                    if (h) {
                        af = y[0];
                        ag = y[2];
                    }
                    else {
                        af = y[2];
                        ag = y[3];
                    }
                    ae.add({ $type: Point_$type, x: af, y: ag });
                    ac.add({ $type: Point_$type, x: af, y: ag });
                }
                if (i != null) {
                    this.c(a, ab, i, k, true);
                    this.c(b, ab, i, k, false);
                    this.c(d, ae, i, k, false);
                    this.c(c, ac, i, k, true);
                    this.c(this.o, ab, i, k, false);
                }
                else {
                    this.f(a, ab);
                    this.f(b, ab);
                    this.f(d, ae);
                    this.f(c, ac);
                    this.f(this.o, ab);
                }
            }
        }
        f(a, b) {
            let c = b.count;
            for (let d = 0; d < c; d++) {
                a.add(b._inner[d]);
            }
        }
    }
    CategoryLineRasterizer.$t = /*@__PURE__*/ markType(CategoryLineRasterizer, 'CategoryLineRasterizer');
    return CategoryLineRasterizer;
})();
