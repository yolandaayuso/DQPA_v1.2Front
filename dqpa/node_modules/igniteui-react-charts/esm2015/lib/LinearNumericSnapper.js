/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { Snapper } from "./Snapper";
import { markType } from "igniteui-react-core";
import { truncate, isInfinity, isNaN_, log10 } from "igniteui-react-core";
/**
 * @hidden
 */
export let LinearNumericSnapper = /*@__PURE__*/ (() => {
    class LinearNumericSnapper extends Snapper {
        constructor(a, ..._rest) {
            super();
            this.i = 0;
            this.g = 0;
            this.k = 0;
            this.j = 0;
            a = (a == void 0) ? 0 : a;
            switch (a) {
                case 0:
                    {
                        let c = _rest[0];
                        let d = _rest[1];
                        let e = _rest[2];
                        let f = _rest[3];
                        let g = _rest[4];
                        this.i = g;
                        if (f > 0) {
                            this.f = f;
                            this.b = true;
                        }
                        this.l(c, d, e, 10);
                    }
                    break;
                case 1:
                    {
                        let c = _rest[0];
                        let d = _rest[1];
                        let e = _rest[2];
                        let f = _rest[3];
                        let g = _rest[4];
                        let h = _rest[5];
                        this.i = h;
                        if (g > 0) {
                            this.f = g;
                            this.b = true;
                        }
                        this.l(c, d, e, f);
                    }
                    break;
            }
        }
        l(a, b, c, d) {
            this.g = NaN;
            this.k = 0;
            this.j = 0;
            let e = 0;
            if (c < 100 && !this.b) {
                e = 4;
            }
            else {
                e = Math.min(d, truncate((c / this.f)));
                if (this.b && !isInfinity(this.f) && !isNaN_(this.f)) {
                    e = Math.min(d + 1, truncate(((c + this.f) / this.f)));
                    if (e == 0) {
                        e = 1;
                    }
                }
            }
            if (e > 0) {
                let f = this.h(a, b, e, true);
                if (this.b && (f + 1) > e) {
                    this.g = NaN;
                    f = this.h(a, b, e - 1, true);
                    if (this.b && (f + 1) > e) {
                        this.g = NaN;
                        f = this.h(a, b, e - 1, false);
                    }
                }
                e = f;
                if (c / e > this.f * 10) {
                    this.j = 10;
                }
                else {
                    if (c / e > this.f * 5) {
                        this.j = 5;
                    }
                    else {
                        if (c / e > this.f * 2) {
                            this.j = 2;
                        }
                    }
                }
                this.k = Math.max(-truncate(Math.floor(log10(this.g))), 0);
            }
        }
        h(a, b, c, d) {
            let e = Snapper.e(b - a, false);
            let f = Math.max(1, c - 1);
            this.g = Snapper.e(e / f, d);
            if (this.i >= 0) {
                let g = Math.max(-truncate(Math.floor(log10(this.g))), 0);
                if (g > this.i) {
                    let h = Math.pow(10, this.i);
                    let i = this.g * h;
                    i = Math.round(i);
                    this.g = i / h;
                    if (this.i == 0 && this.g == 0) {
                        this.g = 1;
                    }
                }
            }
            let j = Math.floor(a / this.g) * this.g;
            let k = Math.ceil(b / this.g) * this.g;
            let l = truncate(Math.round((k - j) / this.g));
            return l;
        }
    }
    LinearNumericSnapper.$t = /*@__PURE__*/ markType(LinearNumericSnapper, 'LinearNumericSnapper', Snapper.$);
    return LinearNumericSnapper;
})();
