/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { AnchoredRadialSeries } from "./AnchoredRadialSeries";
import { DependencyProperty } from "igniteui-react-core";
import { enumGetBox, Point_$type, runOn, typeCast, markType, markDep, fromEnum } from "igniteui-react-core";
import { LegendEmptyValuesMode_$type } from "igniteui-react-core";
import { Defaults } from "./Defaults";
import { Pool$1 } from "igniteui-react-core";
import { Path } from "igniteui-react-core";
import { List$1 } from "igniteui-react-core";
import { Rect } from "igniteui-react-core";
import { RadialBaseView } from "./RadialBaseView";
import { ScalerParams } from "./ScalerParams";
import { PathGeometry } from "igniteui-react-core";
import { ViewportUtils } from "./ViewportUtils";
import { SliceCoords } from "./SliceCoords";
import { PathFigure } from "igniteui-react-core";
import { LineSegment } from "igniteui-react-core";
import { ArcSegment } from "igniteui-react-core";
import { PieSliceCollisionGeometry } from "igniteui-react-core";
import { Size } from "igniteui-react-core";
import { GeometryUtil } from "igniteui-react-core";
import { MathUtil } from "igniteui-react-core";
import { ProportionalCategoryAngleAxis } from "./ProportionalCategoryAngleAxis";
import { SeriesPointOfInterest } from "./SeriesPointOfInterest";
import { DataContext } from "igniteui-react-core";
import { ChartSelection } from "./ChartSelection";
import { CollisionRect } from "igniteui-react-core";
import { PropertyMetadata } from "igniteui-react-core";
import { intDivide, isNaN_ } from "igniteui-react-core";
import { AnchoredRadialSeriesView } from "./AnchoredRadialSeriesView";
/**
 * @hidden
 */
export let RadialPieSeries = /*@__PURE__*/ (() => {
    class RadialPieSeries extends AnchoredRadialSeries {
        bj() {
            return new RadialPieSeries();
        }
        get_fn() {
            return true;
        }
        get_fl() {
            return true;
        }
        jk() {
            if (!isNaN_(this.jj)) {
                return super.jk();
            }
            return Defaults.h;
        }
        cs() {
            return new RadialPieSeriesView(this);
        }
        q1(a) {
            super.q1(a);
            this.adr = a;
        }
        constructor() {
            super();
            this.ads = null;
            this.adx = null;
            this.adp = 0;
            this.ab = RadialPieSeries.$;
        }
        get adt() {
            return this.ads;
        }
        set adt(a) {
            if (this.ads != a) {
                let b = this.adt;
                this.ads = a;
                this.raisePropertyChanged("LegendLabelColumn", b, this.adt);
            }
        }
        get ad0() {
            return this.adx;
        }
        set ad0(a) {
            if (this.adx != a) {
                let b = this.adx;
                this.adx = a;
                this.raisePropertyChanged("LegendLabelMemberPath", b, this.adx);
            }
        }
        get adq() {
            return this.adp;
        }
        set adq(a) {
            if (this.adp != a) {
                let b = this.adp;
                this.adp = a;
                this.raisePropertyChanged("LegendEmptyValuesMode", enumGetBox(LegendEmptyValuesMode_$type, b), enumGetBox(LegendEmptyValuesMode_$type, this.adp));
            }
        }
        preferredCategoryMode(a) {
            return a != null && a == this.yz ? 2 : 0;
        }
        o5(a, b) {
            super.o5(a, b);
            let c = b;
            if (a && c.c6 != null) {
                c.c6.count = 0;
            }
        }
        iw() {
            return this.yz.k8(this.cv.by, this.cv.bx, this.getEffectiveViewport1(this.cv));
        }
        ar(a, b) {
            let c = new List$1(Rect.$, 0);
            let d = this.cv.by;
            let e = this.cv.bx;
            let f = this.getEffectiveViewport1(this.cv);
            let g = this.wj(this.cv);
            let h = this.y5.k5(e, d, f, g);
            let i = { $type: Point_$type, x: 0.5, y: 0.5 };
            let j = this.y5;
            let k = Math.max(0, 0.5 * j.n6);
            let l = k;
            l = Math.max(l, h.minLength);
            let m = this.yz.k8(d, e, f);
            let n = this.yz != null && this.yz.cl;
            let o = this.za;
            if (this.d3()) {
                o = this.zd;
            }
            {
                if (n) {
                    m = this.z0(a, d, e, f);
                }
                if (b < 0 || b > o.f.count - 1) {
                    return null;
                }
                let p = o.f._inner[b][0];
                let q = Math.min(o.f._inner[b][2], h.maxLength);
                return this.adu(d, e, f, p - (m * 0.5), p + (m * 0.5), l, q, i);
            }
        }
        get_ed() {
            return true;
        }
        get_acg() {
            return true;
        }
        get_aca() {
            return true;
        }
        abc(a, b) {
            super.abc(a, b);
            let c = b;
            let d = b.by;
            let e = b.bx;
            let f = this.getEffectiveViewport1(b);
            let g = this.wj(b);
            let h = this.y5.k5(e, d, f, g);
            let i = a.f;
            let j = this.y5;
            let k = Math.max(0, 0.5 * j.n6);
            let l = k;
            l = Math.max(l, h.minLength);
            let m = this.yz.k8(d, e, f);
            let n = this.yz.cl;
            let o = { $type: Point_$type, x: 0.5, y: 0.5 };
            let p = this.adv;
            let q = this.adw;
            let r = (p > 0 && q > 0);
            let s = this.ab8.count;
            this.zg.a2(this, this.zx(), runOn(this, this.yn), this.z6(b), this.z7(b));
            this.zg.r = this.adv;
            this.zg.s = this.adw;
            this.zg.k = this.adv;
            this.zg.l = this.adw;
            let t = false;
            let u = this.zg.b;
            if (u != null) {
                t = true;
            }
            let v = this.yz;
            let w = new ScalerParams(1, b.by, b.bx, v.ch);
            w.c = this.getEffectiveViewport();
            let x = 0;
            let y = 0;
            for (let z = 0; z < i.count; ++z) {
                let aa = i._inner[z][0];
                let ab = Math.min(i._inner[z][2], h.maxLength);
                let ac = i._inner[z][1];
                let ad = i._inner[z][2];
                let ae = i._inner[z][3];
                if (t) {
                    this.ac5(i, z, s, v, w, b.q);
                }
                if (n) {
                    if (isNaN_(aa) || isNaN_(ac) || isNaN_(ad)) {
                        continue;
                    }
                    let af = (b.cx.c + z) * b.cx.b;
                    if ((b.cx.c + z) * b.cx.b > this.yz.lk - 1) {
                        if ((af) * b.cx.b >= this.yz.lj) {
                            af = (af) - (intDivide((this.yz.lj), b.cx.b));
                        }
                    }
                    m = ae;
                    if (isNaN_(m)) {
                        continue;
                    }
                }
                let ag = c.c6.item(x);
                x++;
                let ah = this.zg.k;
                let ai = this.zg.l;
                r = (ah > 0 && ai > 0);
                let aj = null;
                if (r) {
                    aj = this.ad6(d, e, f, aa - (m * 0.5), aa + (m * 0.5), l, ab, o, ah, ai);
                }
                else {
                    aj = this.ad7(d, e, f, aa - (m * 0.5), aa + (m * 0.5), l, ab, o);
                }
                ag.an = aj;
                this.zg.ad(ag, false, false, false, false);
                let ak = i._inner[z][2];
                if (ak > y) {
                    y = ak;
                }
            }
            c.cz = ViewportUtils.f(y, d, e);
            c.c0 = { $type: Point_$type, x: ViewportUtils.e(o.x, d, e, f), y: ViewportUtils.i(o.y, d, e, f) };
            c.c6.count = x;
            c.db();
        }
        ad7(a, b, c, d, e, f, g, h) {
            let i = SliceCoords.b(a, b, c, d, e, f, g, h);
            let j = new PathFigure();
            j._startPoint = i.d;
            j._isClosed = true;
            j._segments.add(((() => {
                let $ret = new LineSegment(1);
                $ret.c = i.f;
                return $ret;
            })()));
            j._segments.add(((() => {
                let $ret = new ArcSegment();
                $ret.e = i.h;
                $ret.f = i.n;
                $ret.d = 1;
                $ret.b = i.c;
                return $ret;
            })()));
            j._segments.add(((() => {
                let $ret = new LineSegment(1);
                $ret.c = i.j;
                return $ret;
            })()));
            j._segments.add(((() => {
                let $ret = new ArcSegment();
                $ret.e = i.d;
                $ret.f = i.m;
                $ret.d = 0;
                $ret.b = i.c;
                return $ret;
            })()));
            let k = new PathGeometry();
            k.c.add(j);
            return k;
        }
        adu(a, b, c, d, e, f, g, h) {
            let i = SliceCoords.b(a, b, c, d, e, f, g, h);
            if (isNaN_(i.n.width) || isNaN_(d) || isNaN_(e)) {
                return null;
            }
            let j = ViewportUtils.e(0.5, a, b, c);
            let k = ViewportUtils.i(0.5, a, b, c);
            return new PieSliceCollisionGeometry(j, k, i.n.width, i.m.width, d, e);
        }
        ad6(a, b, c, d, e, f, g, h, i, j) {
            let k = SliceCoords.a(a, b, c, d, e, f, g, h, i, j);
            if (k == null) {
                return this.ad7(a, b, c, d, e, f, g, h);
            }
            let l = new PathFigure();
            l._startPoint = k.d;
            l._isClosed = true;
            let m = ((d + ((e - d) * 0.5)) * 180 / Math.PI) + 90;
            let n = new Size(1, k.l.width * (f / g), k.l.height * (f / g));
            l._segments.add(((() => {
                let $ret = new ArcSegment();
                $ret.e = k.e;
                $ret.f = n;
                $ret.c = m;
                $ret.d = 1;
                $ret.b = false;
                return $ret;
            })()));
            l._segments.add(((() => {
                let $ret = new LineSegment(1);
                $ret.c = k.f;
                return $ret;
            })()));
            l._segments.add(((() => {
                let $ret = new ArcSegment();
                $ret.e = k.g;
                $ret.f = k.l;
                $ret.c = m;
                $ret.d = 1;
                $ret.b = false;
                return $ret;
            })()));
            l._segments.add(((() => {
                let $ret = new ArcSegment();
                $ret.e = k.h;
                $ret.f = k.n;
                $ret.d = 1;
                $ret.b = k.c;
                return $ret;
            })()));
            l._segments.add(((() => {
                let $ret = new ArcSegment();
                $ret.e = k.i;
                $ret.f = k.l;
                $ret.c = m;
                $ret.d = 1;
                $ret.b = false;
                return $ret;
            })()));
            l._segments.add(((() => {
                let $ret = new LineSegment(1);
                $ret.c = k.j;
                return $ret;
            })()));
            l._segments.add(((() => {
                let $ret = new ArcSegment();
                $ret.e = k.k;
                $ret.f = n;
                $ret.c = m;
                $ret.d = 1;
                $ret.b = false;
                return $ret;
            })()));
            l._segments.add(((() => {
                let $ret = new ArcSegment();
                $ret.e = k.d;
                $ret.f = k.m;
                $ret.d = 0;
                $ret.b = k.c;
                return $ret;
            })()));
            let o = new PathGeometry();
            o.c.add(l);
            return o;
        }
        q9(a, b, c, d) {
            super.q9(a, b, c, d);
            switch (b) {
                case RadialPieSeries.$$p[0]:
                case RadialPieSeries.$$p[1]:
                    this.q3();
                    break;
                case "FastItemsSource":
                    if (c != null) {
                        if (this.adt != null) {
                            c.deregisterColumn(this.adt);
                        }
                    }
                    if (d != null) {
                        if (this.ad0 != null) {
                            this.adt = this.dm(this.ad0);
                        }
                    }
                    break;
                case "LegendLabelMemberPath":
                    if (this.dn != null) {
                        this.dn.deregisterColumn(this.adt);
                        this.adt = this.dm(this.ad0);
                        this.pe();
                        this.pt();
                    }
                    break;
            }
        }
        wn(a) {
            let b = this.adr.by;
            let c = this.adr.bx;
            let d = this.getEffectiveViewport1(this.adr);
            let e = this.wj(this.adr);
            let f = this.y5.k5(c, b, d, e);
            let g = { $type: Point_$type, x: 0.5, y: 0.5 };
            let h = GeometryUtil.j(g, a);
            let i = this.za.f;
            let j = 0;
            for (let k = 0; k < i.count; k++) {
                let l = i._inner[k][0];
                let m = Math.min(i._inner[k][2], f.maxLength);
                let n = i._inner[k][3];
                if (isNaN_(n)) {
                    continue;
                }
                l = l % 6.28318531;
                if (l < 0) {
                    l += 6.28318531;
                }
                if (h >= l - (n * 0.5) && h <= l + (n * 0.5)) {
                    let o = Math.max(0, 0.5 * this.y5.n6);
                    let p = o;
                    p = Math.max(p, f.minLength);
                    let q = SliceCoords.b(b, c, d, l - (n * 0.5), l + (n * 0.5), p, m, g);
                    let r = GeometryUtil.u({ $type: Point_$type, x: ViewportUtils.e(g.x, b, c, d), y: ViewportUtils.i(g.y, b, c, d) }, MathUtil.f(l), q.n.width);
                    let s = 1.7976931348623157E+308;
                    let t = 1.7976931348623157E+308;
                    let u = -1.7976931348623157E+308;
                    let v = -1.7976931348623157E+308;
                    s = Math.min(s, q.d.x);
                    s = Math.min(s, q.f.x);
                    s = Math.min(s, q.h.x);
                    s = Math.min(s, q.j.x);
                    s = Math.min(s, r.x);
                    t = Math.min(t, q.d.y);
                    t = Math.min(t, q.f.y);
                    t = Math.min(t, q.h.y);
                    t = Math.min(t, q.j.y);
                    t = Math.min(t, r.y);
                    u = Math.max(u, q.d.x);
                    u = Math.max(u, q.f.x);
                    u = Math.max(u, q.h.x);
                    u = Math.max(u, q.j.x);
                    u = Math.max(u, r.x);
                    v = Math.max(v, q.d.y);
                    v = Math.max(v, q.f.y);
                    v = Math.max(v, q.h.y);
                    v = Math.max(v, q.j.y);
                    v = Math.max(v, r.y);
                    return new Rect(0, s, t, u - s, v - t);
                }
                j++;
            }
            return new Rect(0, 0, 0, 0, 0);
        }
        ku(a) {
            if (this.yz != null && this.yz.cl && a == this.yz.othersIndex) {
                return null;
            }
            if (this.adt != null) {
                return this.adt.item(a);
            }
            return null;
        }
        eb(a, b, c, d, e) {
            if (super.eb(a, b, c, d, e)) {
                let f = typeCast(ProportionalCategoryAngleAxis.$, this.yz) !== null && this.yz.hasOthersCategory;
                if (e && (this.adq == 1 || (this.adq == 2 && !f))) {
                    let g = this.yz;
                    let h = new ScalerParams(1, this.db.v4, this.ws, g.ch);
                    h.c = this.getEffectiveViewport1(this.cv);
                    let i = this.y5;
                    let j = new ScalerParams(1, this.db.v4, this.ws, i.ch);
                    j.c = this.getEffectiveViewport1(this.cv);
                    let k = this.z5;
                    for (let l = 0; l < this.dn.count; l++) {
                        let m = this.dn.item(l);
                        let n = NaN;
                        if (m != null) {
                            n = this.jc(m);
                        }
                        if (n == 0) {
                            let o = new SeriesPointOfInterest();
                            o.f = this.aa5(n, m, l, d, k, c, b, false);
                            o.b = ((() => {
                                let $ret = new DataContext();
                                $ret.item = m;
                                $ret.series = this;
                                return $ret;
                            })());
                            o.g = this.vg;
                            o.c = l;
                            if (this.g9) {
                                o.g = this.vn(l);
                            }
                            let p = false;
                            for (let q = 0; q < a.count; q++) {
                                if (o.c < a._inner[q].c) {
                                    a.insert(q, o);
                                    p = true;
                                    break;
                                }
                            }
                            if (!p) {
                                a.add(o);
                            }
                        }
                    }
                }
                return true;
            }
            return false;
        }
        ak(a, b) {
            let c = new List$1(ChartSelection.$, 0);
            this.p4(a, c, b);
            return c.toArray();
        }
        p4(a, b, c) {
            if (this.y0 == 0) {
                super.p4(a, b, c);
                return;
            }
            let d = this.cv.by;
            let e = this.cv.bx;
            let f = this.getEffectiveViewport1(this.cv);
            let g = this.wj(this.cv);
            let h = this.y5.k5(e, d, f, g);
            let i = { $type: Point_$type, x: 0.5, y: 0.5 };
            let j = this.y5;
            let k = Math.max(0, 0.5 * j.n6);
            let l = k;
            l = Math.max(l, h.minLength);
            let m = this.yz.k8(d, e, f);
            let n = this.yz != null && this.yz.cl;
            let o = new CollisionRect(0, a);
            for (let p = 0; p < this.yz.lk; p++) {
                let q = typeCast(RadialBaseView.$, this.cv);
                let r = q.cx.getBucket(p);
                let s = this.acj(this.yz, d, e, f);
                if (n) {
                    m = this.z0(p, d, e, f);
                    s = this.aci(p, this.yz, d, e, f);
                    if (isNaN_(s)) {
                        s = 0;
                    }
                }
                r[0] = this.yz.getScaledAngle(r[0]) + s;
                let t = r[0];
                let u = Math.min(this.y8.b.od(r[2]), h.maxLength);
                let v = this.adu(d, e, f, t - (m * 0.5), t + (m * 0.5), l, u, i);
                if (v.collidesWithHeavy(o)) {
                    if (c == 7 || c == 6) {
                        b.add(((() => {
                            let $ret = new ChartSelection();
                            $ret.series = this;
                            return $ret;
                        })()));
                        return;
                    }
                    if (c == 2 || c == 1) {
                        b.add(((() => {
                            let $ret = new ChartSelection();
                            $ret.item = this.dn.item(p);
                            return $ret;
                        })()));
                    }
                    else {
                        b.add(((() => {
                            let $ret = new ChartSelection();
                            $ret.item = this.dn.item(p);
                            $ret.series = this;
                            return $ret;
                        })()));
                    }
                }
            }
        }
    }
    RadialPieSeries.$t = /*@__PURE__*/ markType(RadialPieSeries, 'RadialPieSeries', AnchoredRadialSeries.$);
    RadialPieSeries.$$p = /*@__PURE__*/ markDep(DependencyProperty, PropertyMetadata, RadialPieSeries, 'raisePropertyChanged', ['RadiusX:adv:ad4', [1, 2], 'RadiusY:adw:ad5', [1, 2]]);
    return RadialPieSeries;
})();
/**
 * @hidden
 */
export let RadialPieSeriesView = /*@__PURE__*/ (() => {
    class RadialPieSeriesView extends AnchoredRadialSeriesView {
        constructor(a) {
            super(a);
            this.c5 = null;
            this.c6 = null;
            this.c7 = null;
            this.dc = new Path();
            this.c5 = a;
            this.c6 = ((() => {
                let $ret = new Pool$1(Path.$);
                $ret.create = runOn(this, this.dd);
                $ret.activate = runOn(this, this.c8);
                $ret.disactivate = runOn(this, this.da);
                $ret.destroy = runOn(this, this.c9);
                return $ret;
            })());
        }
        au() {
            super.au();
            this.c7 = new List$1(Path.$, 0);
            if (!this.q) {
                this.cw.xa = Defaults.c;
                this.cw.jp = Defaults.i;
            }
        }
        dd() {
            let a = ((() => {
                let $ret = new Path();
                $ret.dataContext = ((() => {
                    let $ret = new DataContext();
                    $ret.series = this.e;
                    return $ret;
                })());
                return $ret;
            })());
            this.c7.add(a);
            a._visibility = 1;
            return a;
        }
        c8(a) {
            a._visibility = 0;
        }
        da(a) {
            a._visibility = 1;
        }
        c9(a) {
            this.c7.remove(a);
        }
        bg(a, b) {
            super.bg(a, b);
            let c = a;
        }
        ac(a) {
            return this.c7._inner[a];
        }
        ab(a) {
            let b = this.c7._inner[a];
            this.dc._visibility = b._visibility;
            this.dc.an = b.an;
            let c = this.bs(a);
            this.dc._fill = c;
            this.dc._stroke = c;
            this.dc.ad = this.e.ie;
            return this.dc;
        }
        a8(a, b) {
            super.a8(a, b);
            if (a.d) {
                for (let c = 0; c < this.c7.count; c++) {
                    let d = this.aa(c, b);
                    a.t(d);
                }
            }
        }
        db() {
            this.as();
        }
        an(a) {
            super.an(a);
            let b = 0;
            for (let c of fromEnum(this.c6.a)) {
                this.e.bc.exportPathData(a, c, "slice" + b, ["Main", "Fill"]);
                b++;
            }
        }
    }
    RadialPieSeriesView.$t = /*@__PURE__*/ markType(RadialPieSeriesView, 'RadialPieSeriesView', AnchoredRadialSeriesView.$);
    return RadialPieSeriesView;
})();
