/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { Base, Point_$type, markType } from "igniteui-react-core";
import { ViewportUtils } from "./ViewportUtils";
import { NumericScaler } from "./NumericScaler";
import { isNaN_ } from "igniteui-react-core";
/**
 * @hidden
 */
export let PolarAxes = /*@__PURE__*/ (() => {
    class PolarAxes extends Base {
        constructor(a, b) {
            super();
            this.b = null;
            this.a = null;
            this.g = { $type: Point_$type, x: 0.5, y: 0.5 };
            this.b = a;
            this.a = b;
        }
        c(a, b, c, d, e, f) {
            let g = this.g.x + (b * f(a));
            return ViewportUtils.e(g, c, d, e);
        }
        h(a, b, c, d, e, f, g, h, i, j, k) {
            let l = this.a.getScaledAngle1(a, f, g);
            let m = this.b.oe(b, h, i, j, k);
            let n = this.g.x;
            let o = this.g.y;
            let p = n + (m * Math.cos(l));
            let q = o + (m * Math.sin(l));
            p = ViewportUtils.e(p, c, d, e);
            q = ViewportUtils.i(q, c, d, e);
            return { $type: Point_$type, x: p, y: q };
        }
        e(a, b, c, d, e, f, g, h, i) {
            let j = Math.min(b != null ? b.count : 0, c != null ? c.count : 0);
            a.clear();
            let k;
            let l;
            let m = this.g.x;
            let n = this.g.y;
            let o;
            let p;
            let q = Math.min(this.a.l4, this.a.l3);
            let r = Math.max(this.a.l4, this.a.l3);
            let s = Math.min(this.b.l3, this.b.l4);
            let t = Math.max(this.b.l3, this.b.l4);
            let u = this.a.lp;
            let v = this.a.ch;
            let w = this.b.lp;
            let x = this.b.ch;
            let y = this.b.n7;
            let z = this.b.n6;
            let aa = NumericScaler.ac;
            for (let ab = 0; ab < j; ab++) {
                if ((b.item(ab) <= r && b.item(ab) >= q && c.item(ab) <= t && c.item(ab) >= s) || (isNaN_(b.item(ab)) || isNaN_(c.item(ab)))) {
                    k = this.a.getScaledAngle1(b.item(ab), u, v);
                    l = this.b.oe(c.item(ab), w, x, y, z);
                    o = m + (l * g(ab, k));
                    p = n + (l * h(ab, k));
                    if (!f.isEmpty) {
                        let ac = f.left + f.width * (o - aa.left) / aa.width;
                        ac = (ac - e.left) / e.width;
                        o = e.left + e.width * (ac - d.left) / d.width;
                    }
                    else {
                        o = e.left + e.width * (o - d.left) / d.width;
                    }
                    if (!f.isEmpty) {
                        let ad = f.top + f.height * (p - aa.top) / aa.height;
                        ad = (ad - e.top) / e.height;
                        p = e.top + e.height * (ad - d.top) / d.height;
                    }
                    else {
                        p = e.top + e.height * (p - d.top) / d.height;
                    }
                    a.add({ $type: Point_$type, x: o, y: p });
                }
                else {
                    a.add({ $type: Point_$type, x: NaN, y: NaN });
                }
            }
        }
        f(a, b, c, d, e, f, g) {
            let h = ViewportUtils.b(a, c, d, e);
            let i = ViewportUtils.g(b, c, d, e);
            let j = Math.sqrt(Math.pow(h - this.g.x, 2) + Math.pow(i - this.g.y, 2));
            let k = Math.acos((h - this.g.x) / j);
            if ((i - this.g.y) < 0) {
                k = (2 * Math.PI) - k;
            }
            f = this.a.getUnscaledAngle(k);
            g = this.b.of(j);
            return {
                p5: f,
                p6: g
            };
        }
        d(a, b, c, d, e, f) {
            let g = this.g.y + (b * f(a));
            return ViewportUtils.i(g, c, d, e);
        }
    }
    PolarAxes.$t = /*@__PURE__*/ markType(PolarAxes, 'PolarAxes');
    return PolarAxes;
})();
