/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { Series } from "./Series";
import { IHasCategoryModePreference_$type } from "./IHasCategoryModePreference";
import { Axis } from "./Axis";
import { DependencyProperty } from "igniteui-react-core";
import { CategoryAxisBase } from "./CategoryAxisBase";
import { Point_$type, typeCast, Delegate_$type, markType, markDep } from "igniteui-react-core";
import { Brush } from "igniteui-react-core";
import { Thickness } from "igniteui-react-core";
import { List$1 } from "igniteui-react-core";
import { Dictionary$2 } from "igniteui-react-core";
import { Pool$1 } from "igniteui-react-core";
import { AxisAnnotation } from "./AxisAnnotation";
import { SeriesView } from "./SeriesView";
import { NotImplementedException } from "igniteui-react-core";
import { AxisRange } from "./AxisRange";
import { NumericAxisBase } from "./NumericAxisBase";
import { AxisAnnotationFrame } from "./AxisAnnotationFrame";
import { ScalerParams } from "./ScalerParams";
import { CategoryXAxis } from "./CategoryXAxis";
import { AxisAnnotationFrameManager } from "./AxisAnnotationFrameManager";
import { PropertyMetadata } from "igniteui-react-core";
import { DeviceUtils } from "igniteui-react-core";
import { isNaN_, isInfinity } from "igniteui-react-core";
import { stringFormat } from "igniteui-react-core";
import { Path } from "igniteui-react-core";
/**
 * @hidden
 */
export let ValueOverlay = /*@__PURE__*/ (() => {
    class ValueOverlay extends Series {
        bj() {
            return new ValueOverlay();
        }
        constructor() {
            super();
            this.xf = 0;
            this.xg = 0;
            this.xc = 0;
            this.wz = null;
            this.w5 = null;
            this.w4 = null;
            this.ab = ValueOverlay.$;
        }
        i5(a, b, c) {
            return this.xh;
        }
        xd(a, b) {
            let c = Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
            let d = Math.acos((a.x - b.x) / c);
            if ((a.y - b.y) < 0) {
                d = (2 * Math.PI) - d;
            }
            return d;
        }
        wc(a, b, c) {
            if (this.wy == null) {
                return { $type: Point_$type, x: NaN, y: NaN };
            }
            let d = this.xe();
            let e = NaN;
            let f = NaN;
            let g = NaN;
            let h = { $type: Point_$type, x: 0.5, y: 0.5 };
            let i = NaN;
            switch (this.wy.a2) {
                case 2:
                    i = Math.sqrt(Math.pow(a.x - h.x, 2) + Math.pow(a.y - h.y, 2));
                    g = d;
                    e = h.x + Math.cos(g) * i;
                    f = h.y + Math.sin(g) * i;
                    f = this.cv.bx.top + this.cv.bx.height * (f - this.cv.by.top) / this.cv.by.height;
                    e = this.cv.bx.left + this.cv.bx.width * (e - this.cv.by.left) / this.cv.by.width;
                    break;
                case 0:
                    e = d;
                    f = a.y;
                    f = this.cv.bx.top + this.cv.bx.height * (f - this.cv.by.top) / this.cv.by.height;
                    break;
                case 1:
                    f = d;
                    e = a.x;
                    e = this.cv.bx.left + this.cv.bx.width * (e - this.cv.by.left) / this.cv.by.width;
                    break;
                case 3:
                    g = this.xd(a, h);
                    i = d;
                    e = h.x + Math.cos(g) * i;
                    f = h.y + Math.sin(g) * i;
                    f = this.cv.bx.top + this.cv.bx.height * (f - this.cv.by.top) / this.cv.by.height;
                    e = this.cv.bx.left + this.cv.bx.width * (e - this.cv.by.left) / this.cv.by.width;
                    break;
            }
            return { $type: Point_$type, x: e, y: f };
        }
        j3(a) {
            throw new NotImplementedException(0);
        }
        kn(a) {
            return this;
        }
        gd(a) {
            return false;
        }
        ay(a) {
            let b = typeCast(NumericAxisBase.$, a);
            let c = this.xh;
            if (isNaN_(c) || isInfinity(c)) {
                return null;
            }
            return new AxisRange(c, c);
        }
        rs(a) {
            this.o5(true, this.cv);
            if (!this.w3()) {
                if (this.wz != null) {
                    this.x0(NaN, this.d3());
                }
                return;
            }
            if (this.gf(a)) {
                if (this.d3()) {
                    if (this.dc.g) {
                        this.dc.t();
                    }
                    let b = this.xf;
                    this.xf = this.xg;
                    this.xg = b;
                }
                else {
                    this.xf = this.xc;
                }
                this.xc = this.xe();
                this.r7();
            }
            else {
                this.xc = this.xe();
                this.xz(this.xc, this.w1);
            }
        }
        xe() {
            let a, b;
            let c = this.getViewInfo(b, a);
            b = c.p0;
            a = c.p1;
            let d = this.getEffectiveViewport1(this.cv);
            let e = new ScalerParams(0, a, b, this.wy.ch, d);
            return this.wy.el(this.xh, e);
        }
        xz(a, b) {
            if (this.wy == null) {
                return;
            }
            let c = typeCast(CategoryAxisBase.$, this.wy);
            if (c != null && !c.ce) {
                if (this.xh > c.lk - 1) {
                    return;
                }
                if (c.categoryMode != 0) {
                    let d = this.getEffectiveViewport1(b);
                    let e = 0.5 * c.getCategorySize(b.by, b.bx, d);
                    let f = false;
                    if (c.cp && !c.ch) {
                        f = true;
                    }
                    if (typeCast(CategoryXAxis.$, c) !== null && c.ch) {
                        f = true;
                    }
                    if (f) {
                        e = -e;
                    }
                    a += e;
                }
            }
            let g = typeCast(NumericAxisBase.$, this.wy);
            if (g != null) {
                if (this.xh < g.l4 || this.xh > g.l3) {
                    return;
                }
                if (g.lp && this.xh < 0) {
                    return;
                }
            }
            let h;
            switch (this.wy.a2) {
                case 2:
                case 3:
                    h = this.wy.j8(a, b.by, b.bx, this.getEffectiveViewport1(b), this.wj(b));
                    break;
                default:
                    h = this.wy.j8(a, b.by, b.bx, this.getEffectiveViewport1(b), this.wj(b));
                    break;
            }
            if (h != null) {
                b.b1(h);
            }
            if (!b.q) {
                this.x0(a, this.d3());
            }
        }
        he(a, b, c) {
            let d = true;
            d = super.he(a, b, c);
            if (!c.o() || b.isEmpty || a.isEmpty || this.wy == null || this.wy.bi == null) {
                d = false;
            }
            return d;
        }
        sr(a, b) {
            this.rr(false);
        }
        sq(a, b) {
            this.rr(false);
        }
        pb(a, b, c, d) {
            throw new NotImplementedException(0);
        }
        q9(a, b, c, d) {
            super.q9(a, b, c, d);
            switch (b) {
                case ValueOverlay.$$p[11]:
                    if (c != null) {
                        c.b0(this);
                    }
                    if (d != null) {
                        d.ct(this);
                    }
                    this.rr(false);
                    this.ql();
                    break;
                case "TransitionProgress":
                    this.xg = this.xf + this.jq * (this.xc - this.xf);
                    if (this.d5(this.cv)) {
                        return;
                    }
                    if (this.jq == 1) {
                        this.xz(this.xc, this.w1);
                        this.qo();
                    }
                    else {
                        this.xz(this.xg, this.w1);
                    }
                    if (this.db != null) {
                        this.db.qo(this);
                    }
                    break;
                case ValueOverlay.$$p[13]:
                    let e = typeCast(NumericAxisBase.$, this.wy);
                    if (e != null) {
                        e.c1();
                    }
                    this.rr(true);
                    this.qm();
                    break;
                case ValueOverlay.$$p[12]:
                case ValueOverlay.$$p[10]:
                case ValueOverlay.$$p[1]:
                case ValueOverlay.$$p[0]:
                case ValueOverlay.$$p[3]:
                case ValueOverlay.$$p[4]:
                case ValueOverlay.$$p[9]:
                case ValueOverlay.$$p[5]:
                case ValueOverlay.$$p[6]:
                case ValueOverlay.$$p[7]:
                case ValueOverlay.$$p[8]:
                    this.rr(true);
                    break;
            }
        }
        qb() {
            super.qb();
            if (this.wy != null) {
                this.wy.ib(false);
            }
        }
        o5(a, b) {
            super.o5(a, b);
            let c = b;
            c.b0();
        }
        w3() {
            if (this.wy == null || this.wy.bi == null || isNaN_(this.xh) || this._visibility != 0) {
                return false;
            }
            let a = typeCast(CategoryAxisBase.$, this.wy);
            if (a != null && a.lk == 0) {
                return false;
            }
            return true;
        }
        preferredCategoryMode(a) {
            return 0;
        }
        get categoryAxis() {
            return typeCast(CategoryAxisBase.$, this.wy);
        }
        cs() {
            return new ValueOverlayView(this);
        }
        q1(a) {
            super.q1(a);
            this.w1 = typeCast(ValueOverlayView.$, a);
        }
        rt(a, b) {
            super.rt(a, b);
            if (!this.g0) {
                this.cv.a4(b);
                return;
            }
            this.cv.a4(b);
            if (this.d5(this.cu) || !this.w3()) {
                return;
            }
            let c = this.getEffectiveViewport1(this.cv);
            let d = this.wy.el(this.xh, new ScalerParams(0, this.cu.by, a, this.wy.ch, c));
            this.xz(d, typeCast(ValueOverlayView.$, this.cu));
            this.g0 = false;
        }
        getOffsetValue() {
            return 0;
        }
        getCategoryWidth() {
            return 0;
        }
        get yi() {
            return new Thickness(1, this.w8, this.xa, this.w9, this.w7);
        }
        ai() {
            return [this.wy];
        }
        x0(a, b) {
            if (isNaN_(a)) {
                if (this.wz != null) {
                    AxisAnnotationFrameManager.b(this.wz);
                    AxisAnnotationFrameManager.d(this, this.wz, true, this.w4, this.w5, b, this.xi, this.xi, this.w0, this.w0);
                }
                return;
            }
            let c = false;
            if (this.w4 == null) {
                c = true;
                this.w5 = new List$1(Axis.$, 0);
                this.w4 = new Dictionary$2(Axis.$, Pool$1.$.specialize(AxisAnnotation.$), 0);
            }
            this.wz = new AxisAnnotationFrame();
            let d = this.u9;
            if (d == null) {
                d = this.vf;
            }
            let e = this.wy.cp;
            AxisAnnotationFrameManager.c(this.wz, { $type: Point_$type, x: a, y: a }, this, this.db, this.getEffectiveViewport(), d, this.yf, this.w6, this.yh, this.yg, this.yi, this.xb, this.yf, this.w6, this.yh, this.yg, this.yi, this.xb, !e && this.w2, e && this.w2);
            AxisAnnotationFrameManager.d(this, this.wz, c, this.w4, this.w5, b, this.xi, this.xi, this.w0, this.w0);
        }
        get_isValueOverlay() {
            return true;
        }
        xv(a) {
            if (this.wy != null) {
                return this.wy.gf(a);
            }
            return null;
        }
        get xx() {
            let a = this.xv(this.xh);
            return a != null ? a : stringFormat("{0:0.##}", this.xh);
        }
    }
    ValueOverlay.$t = /*@__PURE__*/ markType(ValueOverlay, 'ValueOverlay', Series.$, [IHasCategoryModePreference_$type]);
    ValueOverlay.$$p = /*@__PURE__*/ markDep(DependencyProperty, PropertyMetadata, ValueOverlay, 'raisePropertyChanged', ['AxisAnnotationBackgroundCornerRadius:w6:x1', [1, /*@__PURE__*/ DeviceUtils.g(3)], 'AxisAnnotationBackground:yf:x2', [Brush.$, null], 'AxisAnnotationFormatLabel:w0:x3', [Delegate_$type], 'AxisAnnotationInterpolatedValuePrecision:xi:x4', [1, -1], 'AxisAnnotationOutline:yg:x5', [Brush.$, null], 'AxisAnnotationPaddingBottom:w7:x6', [1, NaN], 'AxisAnnotationPaddingLeft:w8:x7', [1, NaN], 'AxisAnnotationPaddingRight:w9:x8', [1, NaN], 'AxisAnnotationPaddingTop:xa:x9', [1, NaN], 'AxisAnnotationStrokeThickness:xb:ya', [1, NaN], 'AxisAnnotationTextColor:yh:yb', [Brush.$, null], 'Axis:wy:yc', [Axis.$, null], 'IsAxisAnnotationEnabled:w2:yd', [0, false], 'Value:xh:ye', [1, 0]]);
    return ValueOverlay;
})();
/**
 * @hidden
 */
export let ValueOverlayView = /*@__PURE__*/ (() => {
    class ValueOverlayView extends SeriesView {
        constructor(a) {
            super(a);
            this.b2 = null;
            this.b2 = new Path();
        }
        bd() {
            super.bd();
            this.b2._stroke = this.e.u9;
            this.b2.ad = this.e.ie;
            this.b2.ai = this.e.v2;
            this.b2.aj = this.e.v3;
        }
        be() {
            super.be();
            let a = this.br();
            this.b2._stroke = a;
            this.b2.ad = this.e.ie + 3;
            this.b2._stroke = a;
            this.b2.ad = this.e.ie + 3;
        }
        b1(a) {
            this.b2.an = a;
            this.as();
        }
        b0() {
            this.b2.an = null;
            this.as();
        }
        a8(a, b) {
            super.a8(a, b);
            if (a.d) {
                a.t(this.b2);
            }
        }
        an(a) {
            super.an(a);
            this.e.bc.exportPathData(a, this.b2, "ValueOverlayPath", []);
        }
    }
    ValueOverlayView.$t = /*@__PURE__*/ markType(ValueOverlayView, 'ValueOverlayView', SeriesView.$);
    return ValueOverlayView;
})();
