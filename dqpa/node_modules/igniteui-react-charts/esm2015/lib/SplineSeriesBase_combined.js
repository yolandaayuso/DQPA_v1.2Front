/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { HorizontalAnchoredCategorySeries } from "./HorizontalAnchoredCategorySeries";
import { DependencyProperty } from "igniteui-react-core";
import { SplineType_$type } from "./SplineType";
import { AxisRange } from "./AxisRange";
import { Array_$type, typeCast, Point_$type, enumGetBox, markType, markDep } from "igniteui-react-core";
import { List$1 } from "igniteui-react-core";
import { Rect } from "igniteui-react-core";
import { CategoryAxisBase } from "./CategoryAxisBase";
import { ISortingAxis_$type } from "./ISortingAxis";
import { CollisionAvoider } from "./CollisionAvoider";
import { AnchoredCategorySeriesView } from "./AnchoredCategorySeriesView";
import { ScalerParams } from "./ScalerParams";
import { SafeSortedReadOnlyDoubleCollection } from "./SafeSortedReadOnlyDoubleCollection";
import { Numeric } from "igniteui-react-core";
import { ChartSelection } from "./ChartSelection";
import { PropertyMetadata } from "igniteui-react-core";
import { truncate, isNaN_ } from "igniteui-react-core";
import { Color } from "igniteui-react-core";
/**
 * @hidden
 */
export let SplineSeriesBase = /*@__PURE__*/ (() => {
    class SplineSeriesBase extends HorizontalAnchoredCategorySeries {
        constructor() {
            super(...arguments);
            this.acy = null;
            this.ac4 = NaN;
            this.ac3 = NaN;
        }
        jk() {
            if (!isNaN_(this.jj)) {
                return super.jk();
            }
            return this.acz.dg();
        }
        cs() {
            return new SplineSeriesBaseView(this);
        }
        q1(a) {
            super.q1(a);
            this.acz = a;
        }
        r4(a) {
            super.r4(a);
            this.ac1 = true;
        }
        ay(a) {
            if (!this.ac1 || this.acy == null || this.acy.length == 0) {
                return super.ay(a);
            }
            if (this.valueColumn == null || this.valueColumn.count == 0) {
                return null;
            }
            if (a == this.fetchXAxis()) {
                return new AxisRange(0, this.valueColumn.count - 1);
            }
            this.adb(this.acz);
            if (this.acy == null || this.acy.length == 0) {
                return null;
            }
            if (a == this.fetchYAxis()) {
                if (isNaN_(this.ac7) || isNaN_(this.ac8)) {
                    return null;
                }
                return new AxisRange(this.ac8, this.ac7);
            }
            return null;
        }
        get_ev() {
            return true;
        }
        acw(a) {
            if (a.cw.d == 0) {
                return null;
            }
            let b = new List$1(Array_$type, 0);
            let c = a.by;
            let d = a.bx;
            let e = this.getEffectiveViewport1(a);
            let f = 0;
            let g = 0;
            let h = 0;
            let i = this;
            let j = typeCast(CategoryAxisBase.$, i.fetchXAxis());
            let k = i.wj(this.cv);
            let l = i.dn;
            if (c.isEmpty || d.isEmpty || j == null || l == null || l.count == 0) {
                f = 0;
                return null;
            }
            let m = this.id;
            let n = typeCast(ISortingAxis_$type, j);
            if (n == null || n.i$b == null) {
                let o = new ScalerParams(0, c, d, j.ch, e);
                let p = 0;
                let q = j.lk - 1;
                let r = Math.floor((q - p + 1) * m / k.width);
                f = truncate(Math.max(1, r));
                g = truncate(Math.max(0, Math.floor(p / f) - 1));
                h = truncate(Math.ceil(q / f));
            }
            else {
                g = 0;
                h = j.lk - 1;
                f = 1;
            }
            if (n != null && n.i$b.count != this.dn.count) {
                return null;
            }
            this.adb(a);
            let s = truncate(Math.ceil(d.width / (h - g)));
            let t = new CollisionAvoider();
            if (n != null) {
                return this.acx(a);
            }
            let u = (v) => v;
            let v = (w) => this.valueColumn.item(w);
            let w = a;
            w.db();
            for (let x = g; x <= h; ++x) {
                let y = null;
                if (f == 1) {
                    if (x >= (this.valueColumn.count - 1)) {
                        break;
                    }
                    let z = u(x);
                    let aa = v(x);
                    let ab = u(x + 1);
                    let ac = v(x + 1);
                    let ad = ab - z;
                    let ae = this.acy[x];
                    let af = this.acy[x + 1];
                    b.add([aa, ac]);
                    for (let ag = 1; ag < s; ++ag) {
                        let ah = z + ad * ag / s;
                        let ai = (ab - ah) / ad;
                        let aj = (ah - z) / ad;
                        let ak = ai * aa + aj * ac + ((ai * ai * ai - ai) * ae + (aj * aj * aj - aj) * af) * (ad * ad) / 6;
                        b.add([ak, ak]);
                    }
                }
                else {
                    y = a.cw.getBucket(x);
                    if (!isNaN_(y[0])) {
                        b.add([y[1], y[2]]);
                    }
                }
            }
            w.dd();
            return b.toArray();
        }
        acx(a) {
            let b = typeCast(ISortingAxis_$type, this.acd);
            let c = this.getEffectiveViewport1(a);
            let d = a.by;
            let e = a.bx;
            let f = new List$1(Array_$type, 0);
            if (b == null) {
                return null;
            }
            let g = this.acd;
            let h = 0;
            let i = 0;
            let j = 0;
            let k = this.id;
            let l = this.wj(this.cv);
            if (b == null || b.i$b == null) {
                let m = new ScalerParams(0, d, e, g.ch, c);
                let n = 0;
                let o = g.lk - 1;
                let p = Math.floor((o - n + 1) * k / l.width);
                h = truncate(Math.max(1, p));
                i = truncate(Math.max(0, Math.floor(n / h) - 1));
                j = truncate(Math.ceil(o / h));
            }
            else {
                i = 0;
                j = g.lk - 1;
                h = 1;
            }
            let q = (r) => r;
            let r = (s) => this.valueColumn.item(b.i$b._inner[s]);
            let s = truncate(Math.ceil(e.width / (j - i)));
            let t = new CollisionAvoider();
            if (h <= 0 || (i <= 0 && j <= 0)) {
                return null;
            }
            for (let u = i; u < j + 1; ++u) {
                let v = null;
                let w = u * h;
                if (b != null && b.i$b != null && w >= 0 && w < b.i$b.count) {
                    w = b.i$b._inner[w];
                }
                if (u >= (this.valueColumn.count - 1)) {
                    break;
                }
                let x = q(u);
                let y = r(u);
                let z = q(u + 1);
                let aa = r(u + 1);
                let ab = z - x;
                let ac = this.acy[u];
                let ad = this.acy[u + 1];
                f.add([y, y]);
                for (let ae = 1; ae < s; ++ae) {
                    let af = ae / s;
                    let ag = x + ab * af;
                    let ah = (z - ag) / ab;
                    let ai = (ag - x) / ab;
                    let aj = ah * y + ai * aa + ((ah * ah * ah - ah) * ac + (ai * ai * ai - ai) * ad) * (ab * ab) / 6;
                    f.add([aj, aj]);
                }
            }
            return f.toArray();
        }
        adc(a, b, c, d, e, f) {
            let g = typeCast(ISortingAxis_$type, d);
            let h = this.getEffectiveViewport1(f);
            if (g == null) {
                return;
            }
            let i = new ScalerParams(0, b, c, d.ch, h);
            let j = new ScalerParams(0, b, c, e.ch, h);
            j.b = this.iy();
            let k = this.xg();
            let l = 0;
            let m = this.ac6(d, b, c, h);
            let n = (o) => o;
            let o = (p) => this.valueColumn.item(g.i$b._inner[p]);
            let p = this.y3.cw.f;
            let q = this.y3.cw.e;
            let r = truncate(Math.ceil(c.width / (p - q)));
            let s = new CollisionAvoider();
            let t = this.y3.cw.d;
            if (t <= 0 || (q <= 0 && p <= 0)) {
                this.y3.cz.count = l;
                return;
            }
            let u = 0;
            let v = 0;
            for (let w = q; w < p + 1; ++w) {
                let x = null;
                let y = w * t;
                if (g != null && g.i$b != null && y >= 0 && y < g.i$b.count) {
                    y = g.i$b._inner[y];
                }
                if (w >= (this.valueColumn.count - 1)) {
                    if (k && this.ac2(a, a.f._inner[a.f.count - 1], s, Math.min(y, this.dn.count - 1), l, f, u - 1)) {
                        ++l;
                    }
                    break;
                }
                let z = n(w);
                let aa = o(w);
                let ab = n(w + 1);
                let ac = o(w + 1);
                let ad = ab - z;
                let ae = this.acy[w];
                let af = this.acy[w + 1];
                let ag = g.i$d(g.i$b._inner[w]);
                let ah = d.el(ag, i) + m;
                let ai = e.el(aa, j);
                a.f.add([ah, ai, ai]);
                u++;
                v = u;
                for (let aj = 1; aj < r; ++aj) {
                    let ak = aj / r;
                    let al = z + ad * ak;
                    let am = (ab - al) / ad;
                    let an = (al - z) / ad;
                    let ao = am * aa + an * ac + ((am * am * am - am) * ae + (an * an * an - an) * af) * (ad * ad) / 6;
                    let ap = g.i$d(g.i$b._inner[w]);
                    let aq = g.i$d(g.i$b._inner[w + 1]);
                    let ar = ap + (aq - ap) * ak;
                    al = d.el(ar, i) + m;
                    ao = e.el(ao, j);
                    a.f.add([al, ao, ao]);
                    u++;
                }
                if (k) {
                    x = [ah, ai, ai];
                }
                if (k && this.ac2(a, x, s, Math.min(y, this.dn.count - 1), l, f, v - 1)) {
                    ++l;
                }
            }
            f.cz.count = l;
        }
        ac2(a, b, c, d, e, f, g) {
            let h = b[0];
            let i = b[1];
            let j = new Rect(0, h - 5, i - 5, 11, 11);
            if (!isNaN_(h) && !isNaN_(i) && c.tryAdd(j)) {
                a.n.add({ $type: Point_$type, x: h, y: i });
                let k = f.cz.item(e);
                k.content.item = this.dn.item(d);
                k.al = g;
                k.ak = d;
                return true;
            }
            return false;
        }
        an(a, b, c, d, e, f) {
            if (a == null || a.cn || this.zv(this.cv) > 1 || this.zv(this.cv) == 0) {
                return super.an(this.ys(), this.yu.f, this.zv(this.cv), this.zw(this.cv), e, f);
            }
            if (this.yu.f.count == 0) {
                return null;
            }
            let g = this.acz.cw.f;
            let h = this.cv.bx;
            let i = truncate(Math.ceil(h.width));
            if (g != d) {
                i = truncate(Math.ceil(h.width / (g - d)));
            }
            let j = -1;
            let k = -1;
            let l = this.ir(e);
            let m = this.ka(e, f);
            let n = this.j8(e, f);
            let o = truncate(Math.floor(m / this.zv(this.cv)));
            let p = truncate(Math.floor(n / this.zv(this.cv)));
            j = o - this.zw(this.cv);
            k = p - this.zw(this.cv);
            let q = j * i;
            let r = k * i;
            let s = 0;
            if (m != n) {
                s = (l - m) / (n - m);
            }
            let t = truncate(Math.floor(q + s * (r - q)));
            j = t;
            k = t + 1;
            if (j < 0) {
                j = 0;
            }
            if (j > this.yu.f.count - 1) {
                j = this.yu.f.count - 1;
            }
            if (k < 0) {
                k = 0;
            }
            if (k > this.yu.f.count - 1) {
                k = this.yu.f.count - 1;
            }
            let u = this.yu.f._inner[j];
            let v = this.yu.f._inner[k];
            let w = new Array(2);
            w[0] = u;
            w[1] = v;
            return w;
        }
        aah(a, b) {
            super.aah(a, b);
            if (a.f.count <= 1) {
                return;
            }
            if (b.cw.d == 0) {
                return;
            }
            let c = b.by;
            let d = b.bx;
            let e = this.getEffectiveViewport1(b);
            let f = this.acd;
            let g = this.acj;
            let h = new ScalerParams(0, c, d, f.ch, e);
            let i = ((() => {
                let $ret = new ScalerParams(0, c, d, g.ch, e);
                $ret.b = this.iy();
                return $ret;
            })());
            a.f.clear();
            a.n.clear();
            let j = this.xg();
            let k = 0;
            let l = typeCast(ISortingAxis_$type, this.acd);
            if (l != null && l.i$b.count != this.dn.count) {
                return;
            }
            let m = this.ac6(f, c, d, e);
            let n = b.cw.d;
            this.adb(b);
            let o = b.cw.f;
            let p = b.cw.e;
            let q = truncate(Math.ceil(d.width / (o - p)));
            let r = new CollisionAvoider();
            if (l != null) {
                this.adc(a, c, d, f, g, b);
                return;
            }
            let s = (t) => t;
            let t = (u) => this.valueColumn.item(u);
            let u = b;
            u.db();
            let v = 0;
            let w = 0;
            for (let x = p; x <= o; ++x) {
                let y = null;
                if (n == 1) {
                    if (x >= (this.valueColumn.count - 1)) {
                        if (j && this.ac2(a, a.f._inner[a.f.count - 1], r, Math.min(x * n, this.dn.count - 1), k, b, v - 1)) {
                            ++k;
                        }
                        break;
                    }
                    let z = s(x);
                    let aa = t(x);
                    let ab = s(x + 1);
                    let ac = t(x + 1);
                    let ad = ab - z;
                    let ae = this.acy[x];
                    let af = this.acy[x + 1];
                    let ag = f.el(z, h) + m;
                    let ah = g.el(aa, i);
                    a.f.add([ag, ah, ah]);
                    v++;
                    w = v;
                    for (let ai = 1; ai < q; ++ai) {
                        let aj = z + ad * ai / q;
                        let ak = (ab - aj) / ad;
                        let al = (aj - z) / ad;
                        let am = ak * aa + al * ac + ((ak * ak * ak - ak) * ae + (al * al * al - al) * af) * (ad * ad) / 6;
                        aj = f.el(aj, h) + m;
                        am = g.el(am, i);
                        a.f.add([aj, am, am]);
                        v++;
                    }
                    if (j) {
                        y = b.cw.getBucket(x);
                        y[0] = (f.el(y[0], h) + m);
                        y[1] = g.el(y[1], i);
                        y[2] = g.el(y[2], i);
                    }
                }
                else {
                    y = b.cw.getBucket(x);
                    if (!isNaN_(y[0])) {
                        y[0] = (f.el(y[0], h) + m);
                        y[1] = g.el(y[1], i);
                        y[2] = g.el(y[2], i);
                        a.f.add(y);
                        v++;
                        w = v;
                    }
                }
                if (j && this.ac2(a, y, r, Math.min(x * n, this.dn.count - 1), k, b, w - 1)) {
                    ++k;
                }
            }
            u.dd();
            b.cz.count = k;
        }
        adb(a) {
            let b = a.cw.d;
            let c = (d) => d;
            let d = (e) => this.valueColumn.item(e);
            if (b < 1 || this.valueColumn == null || this.valueColumn.count == 0) {
                return;
            }
            if ((this.acy == null || this.acy.length != this.valueColumn.count) && b == 1) {
                let e = this.ac0 == 0 ? NaN : 0;
                if (this.acd != null && typeCast(ISortingAxis_$type, this.acd) !== null && this.acd.i$b != null) {
                    let f = new SafeSortedReadOnlyDoubleCollection(1, this.valueColumn, this.acd.i$b, NaN);
                    d = (g) => f.item(g);
                }
                this.acy = Numeric.c(this.valueColumn.count, c, d, e, e);
                if (this.ac1) {
                    let g = -1.7976931348623157E+308;
                    let h = 1.7976931348623157E+308;
                    let i = this.acw(a);
                    if (i == null) {
                        return;
                    }
                    for (let j = 0; j < i.length; j++) {
                        if (isNaN_(i[j][0]) || isNaN_(i[j][1])) {
                            continue;
                        }
                        if (i[j][1] > g) {
                            g = i[j][1];
                        }
                        if (i[j][0] < h) {
                            h = i[j][0];
                        }
                    }
                    this.ac8 = h;
                    this.ac7 = g;
                }
            }
        }
        ac5(a, b, c, d, e, f, g) {
            let h = d - b;
            let i = b + h * a;
            let j = (d - i) / h;
            let k = (i - b) / h;
            let l = j * c + k * e + ((j * j * j - j) * f + (k * k * k - k) * g) * (h * h) / 6;
            return l;
        }
        iv(a, b, c, d, e, f, g, h) {
            let i = NaN;
            if (c >= 0 && c < b.count) {
                i = b.item(c);
            }
            let j = NaN;
            if (d >= 0 && d < b.count) {
                j = b.item(d);
            }
            if (f == 0) {
                return j;
            }
            if (e == b.count - 1) {
                return i;
            }
            if (isNaN_(j) && g != 0 && a <= 0.5 && !h) {
                return i;
            }
            if (isNaN_(i) && g != 0 && a >= 0.5 && !h) {
                return j;
            }
            let k = e;
            let l = f;
            let m = i;
            let n = j;
            let o = NaN;
            let p = NaN;
            if (this.acy != null && e >= 0 && e < this.acy.length) {
                o = this.acy[e];
            }
            if (this.acy != null && f >= 0 && f < this.acy.length) {
                p = this.acy[f];
            }
            return this.ac5(a, k, m, l, n, o, p);
        }
        ac6(a, b, c, d) {
            let e = this.preferredCategoryMode(a);
            if (e == 0 && a.categoryMode != 0) {
                e = 1;
            }
            let f = 0;
            switch (e) {
                case 0:
                    f = 0;
                    break;
                case 1:
                    f = 0.5 * a.getCategorySize(b, c, d);
                    break;
                case 2:
                    f = a.getGroupCenter(this.index, b, c, d);
                    break;
            }
            if (a.ch) {
                f = -f;
            }
            return f;
        }
        get ac8() {
            return this.ac4;
        }
        set ac8(a) {
            this.ac4 = a;
        }
        get ac7() {
            return this.ac3;
        }
        set ac7(a) {
            this.ac3 = a;
        }
        add() {
            this.acy = null;
            this.ac8 = NaN;
            this.ac7 = NaN;
            if (this.yAxis != null) {
                this.yAxis.c1();
            }
        }
        q9(a, b, c, d) {
            switch (b) {
                case "ValueColumn":
                case "FastItemsSource":
                    this.add();
                    break;
            }
            super.q9(a, b, c, d);
            switch (b) {
                case SplineSeriesBase.$$p[1]:
                    this.add();
                    this.rr(false);
                    this.ql();
                    break;
            }
        }
        pb(a, b, c, d) {
            this.add();
            super.pb(a, b, c, d);
        }
        p4(a, b, c) {
            this.aac(a, b, c, this.yt, 0);
        }
        ak(a, b) {
            let c = new List$1(ChartSelection.$, 0);
            this.p4(a, c, b);
            return c.toArray();
        }
        get useHighMarkerFidelity() {
            return this.zq;
        }
    }
    SplineSeriesBase.$t = /*@__PURE__*/ markType(SplineSeriesBase, 'SplineSeriesBase', HorizontalAnchoredCategorySeries.$);
    SplineSeriesBase.$$p = /*@__PURE__*/ markDep(DependencyProperty, PropertyMetadata, SplineSeriesBase, 'raisePropertyChanged', ['IsSplineShapePartOfRange:ac1:ade', [0, false], 'SplineType:ac0:adf', [SplineType_$type, /*@__PURE__*/ enumGetBox(SplineType_$type, 0)]]);
    return SplineSeriesBase;
})();
/**
 * @hidden
 */
export let SplineSeriesBaseView = /*@__PURE__*/ (() => {
    class SplineSeriesBaseView extends AnchoredCategorySeriesView {
        constructor(a) {
            super(a);
            this.df = null;
            this.df = a;
        }
        dg() {
            let a = 1;
            if (this.df.db != null) {
                a = this.df.db.hi;
            }
            return Math.max(1 / (a * 3), 0.3);
        }
        af() {
            let a = new Color();
            a.colorString = "rgba(95,95,95,0.5)";
            this.e.v1 = a;
            this.e.jm = 3;
            this.e.jn = 1;
            this.e.jo = 4;
            this.e.hc = false;
        }
    }
    SplineSeriesBaseView.$t = /*@__PURE__*/ markType(SplineSeriesBaseView, 'SplineSeriesBaseView', AnchoredCategorySeriesView.$);
    return SplineSeriesBaseView;
})();
