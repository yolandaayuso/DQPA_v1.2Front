/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { AnnotationLayer } from "./AnnotationLayer";
import { DependencyProperty } from "igniteui-react-core";
import { Series } from "./Series";
import { ItemTooltipLayerFrame } from "./ItemTooltipLayerFrame";
import { Base, String_$type, fromEnum, Point_$type, markType, markDep, runOn } from "igniteui-react-core";
import { Pool$1 } from "igniteui-react-core";
import { List$1 } from "igniteui-react-core";
import { ItemTooltipCollisionInfo } from "./ItemTooltipCollisionInfo";
import { Rect } from "igniteui-react-core";
import { DataContext } from "igniteui-react-core";
import { Size } from "igniteui-react-core";
import { DeviceUtils } from "igniteui-react-core";
import { PropertyMetadata } from "igniteui-react-core";
import { isNaN_ } from "igniteui-react-core";
import { AnnotationLayerView } from "./AnnotationLayerView";
import { PointerTooltip } from "./PointerTooltip";
/**
 * @hidden
 */
export let ItemToolTipLayer = /*@__PURE__*/ (() => {
    class ItemToolTipLayer extends AnnotationLayer {
        bj() {
            return new ItemToolTipLayer();
        }
        get_er() {
            return true;
        }
        constructor() {
            super();
            let a = new ItemTooltipLayerFrame();
            let b = new ItemTooltipLayerFrame();
            let c = new ItemTooltipLayerFrame();
            let d = this.kd / 1000;
            this.xc = a;
            this.xb = b;
            this.xd = c;
            this.ab = ItemToolTipLayer.$;
        }
        cs() {
            return new ItemToolTipLayerView(this);
        }
        q1(a) {
            super.q1(a);
            this.zx = a;
        }
        get_e2() {
            return true;
        }
        gu(a) {
            if (this.zy == null) {
                return true;
            }
            if (this.zy == a) {
                return true;
            }
            return false;
        }
        q9(a, b, c, d) {
            super.q9(a, b, c, d);
            switch (b) {
                case ItemToolTipLayer.$$p[1]:
                case ItemToolTipLayer.$$p[2]:
                    this.rr(true);
                    break;
                case ItemToolTipLayer.$$p[3]:
                    this.rr(true);
                    break;
                case ItemToolTipLayer.$$p[0]:
                    this.rr(true);
                    break;
                case "SeriesViewer":
                    this.zx.cj();
                    break;
            }
        }
        yp(a, b) {
            if (this.zy == null || this.zy == a) {
                if (!this.a1.c) {
                    this.rr(b);
                }
            }
        }
        xi(a) {
            if (!super.xi(a)) {
                return false;
            }
            if (this.z4 != null) {
                if (a.fb) {
                    let b = a.nc();
                    if (!Base.equalsStatic(this.z4, b)) {
                        return false;
                    }
                }
                else {
                    if (!Base.equalsStatic(this.z4, a.name)) {
                        return false;
                    }
                }
            }
            let c = this.yk(a);
            if (!c.c) {
                return false;
            }
            return true;
        }
        yr(a, b) {
            super.yr(a, b);
            let c = a;
            let d = this.zx.b8;
            let e = this.z1;
            let f = this.z0;
            c.o.clear();
            c.i.clear();
            c.n.clear();
            c.g.clear();
            c.f.clear();
            c.l.clear();
            c.j.clear();
            c.m.clear();
            c.k.clear();
            c.h.clear();
            if (isNaN_(this.zu.x) && isNaN_(this.zu.y)) {
                d.count = 0;
                return;
            }
            let g = 0;
            if (this.xi(this.zy)) {
                this.z9(this.zy, c, e, f, 0);
                g++;
            }
            else {
                for (let h of fromEnum(this.db.series)) {
                    if (this.xi(h)) {
                        this.z9(h, c, e, f, g);
                        g++;
                    }
                    if (h.isStacked) {
                        h.p3((i) => {
                            if (this.xi(i)) {
                                this.z9(i, c, e, f, g);
                                g++;
                            }
                            if (i.eg) {
                                i.p1((j) => {
                                    if (this.xi(j)) {
                                        this.z9(j, c, e, f, g);
                                        g++;
                                    }
                                    return true;
                                });
                            }
                            return true;
                        });
                    }
                    if (h.eg) {
                        h.p1((i) => {
                            if (this.xi(i)) {
                                this.z9(i, c, e, f, g);
                                g++;
                            }
                            return true;
                        });
                    }
                }
                this.z8(c);
            }
            d.count = g;
        }
        z8(a) {
            let b = new List$1(ItemTooltipCollisionInfo.$, 0);
            for (let c = 0; c < a.f.count; c++) {
                let d = new ItemTooltipCollisionInfo();
                d.d = c;
                d.e = { $type: Point_$type, x: a.f._inner[c], y: a.g._inner[c] };
                d.c = a.m._inner[c];
                d.a = a.k._inner[c];
                d.b = a.o._inner[c];
                if (isNaN_(d.e.x) || isNaN_(d.e.y)) {
                    continue;
                }
                b.add(d);
            }
            b.aa((e, f) => {
                if (e.e.y < f.e.y) {
                    return -1;
                }
                if (e.e.y > f.e.y) {
                    return 1;
                }
                if (e.b < f.b) {
                    return -1;
                }
                if (e.b > f.b) {
                    return 1;
                }
                return 0;
            });
            let e = this.zz(b);
            if (!e) {
                return;
            }
            for (let f = 0; f < b.count - 1; f++) {
                let g = b._inner[f];
                let h = b._inner[f + 1];
                let i = new Rect(0, g.e.x, g.e.y, g.c, g.a);
                let j = new Rect(0, h.e.x, h.e.y, h.c, h.a);
                if (i.intersectsWith(j) || i.top > j.bottom) {
                    h.e = { $type: Point_$type, x: h.e.x, y: i.bottom + 1 };
                }
            }
            if (b._inner[b.count - 1].e.y + b._inner[b.count - 1].a > this.cv.bx.height) {
                b._inner[b.count - 1].e = { $type: Point_$type, x: b._inner[b.count - 1].e.x, y: b._inner[b.count - 1].e.y - ((b._inner[b.count - 1].e.y + b._inner[b.count - 1].a) - this.cv.bx.height) };
            }
            for (let k = b.count - 1; k >= 1; k--) {
                let l = b._inner[k];
                let m = b._inner[k - 1];
                let n = new Rect(0, l.e.x, l.e.y, l.c, l.a);
                let o = new Rect(0, m.e.x, m.e.y, m.c, m.a);
                if (n.intersectsWith(o) || n.top < o.bottom) {
                    m.e = { $type: Point_$type, x: m.e.x, y: n.top - (o.height + 1) };
                }
            }
            for (let p = 0; p < b.count; p++) {
                let q = b._inner[p].d;
                let r = b._inner[p];
                a.f._inner[q] = r.e.x;
                a.g._inner[q] = r.e.y;
            }
        }
        zz(a) {
            if (a.count <= 1) {
                return false;
            }
            let b = this.cv.bx;
            for (let c = 0; c < a.count - 1; c++) {
                let d = a._inner[c];
                let e = a._inner[c + 1];
                let f = new Rect(0, d.e.x, d.e.y, d.c, d.a);
                let g = new Rect(0, e.e.x, e.e.y, e.c, e.a);
                if (f.intersectsWith(g)) {
                    return true;
                }
            }
            return false;
        }
        z9(a, b, c, d, e) {
            let f = this.yk(a);
            if (!f.c) {
                return;
            }
            let g = a.wc(f.d, c, d);
            let h = this.zx.b8;
            let i = this.z2(a);
            let j = this.zu;
            if (!c) {
                j = this.wh(g);
            }
            let k = a.kn(j);
            let l = h.item(e);
            let m = this.cv.bx;
            let n = null;
            if (a.e3 && k != null) {
                n = a.a3(k);
            }
            else {
                n = new DataContext();
                n.item = k;
                n.series = a;
            }
            if (!this.zx.b9(a, l, i, n)) {
                return;
            }
            let o = this.zx.ck(l, i, n);
            b.i.add1(l);
            b.j.add1(n);
            b.l.add1(i);
            let p = g.x;
            let q = g.x;
            q = Math.max(q, m.left);
            q = Math.min(q, m.right);
            b.n.add(q);
            let r = g.y;
            r = Math.max(r, m.top);
            r = Math.min(r, m.bottom);
            b.o.add(r);
            let s = DeviceUtils.g(10);
            let t = g.x + s;
            if (t + o.width > m.right) {
                t = (p - o.width) - s;
            }
            if (t < m.left) {
                t = m.left;
            }
            b.f.add(t);
            let u = (g.y - o.height) - s;
            if (u + o.height > m.bottom) {
                u = (m.bottom - o.height) - s;
            }
            if (u < m.top) {
                u = m.top;
            }
            b.g.add(u);
            b.m.add(o.width);
            b.k.add(o.height);
            let v = this.u9;
            if (v == null) {
                v = this.vf;
            }
            if (v == null) {
                v = a.u9;
            }
            b.h.add(v);
        }
        z2(a) {
            return a.toolTip;
        }
        p7() {
            this.zu = { $type: Point_$type, x: NaN, y: NaN };
            this.rr(false);
            this.zx.ch(false);
        }
        p8() {
            this.zu = { $type: Point_$type, x: NaN, y: NaN };
            this.rr(false);
            this.zx.ch(true);
        }
        yu(a, b) {
            super.yu(a, b);
            let c = a;
            let d = c.o.count;
            let e = b.bx.left;
            let f = b.bx.right;
            let g = b.bx.top;
            let h = b.bx.bottom;
            for (let i = 0; i < d; i++) {
                if (isNaN_(c.n._inner[i]) || isNaN_(c.o._inner[i]) || isNaN_(c.f._inner[i]) || isNaN_(c.g._inner[i]) || c.l._inner[i] == null || c.j._inner[i] == null) {
                    this.zx.cg(c.i._inner[i]);
                    continue;
                }
                let j = c.f._inner[i];
                let k = c.g._inner[i];
                let l = c.m._inner[i];
                let m = c.k._inner[i];
                let n = false;
                if (j < e && Math.abs(j - e) > 1) {
                    n = true;
                }
                if (k < g && Math.abs(k - g) > 1) {
                    n = true;
                }
                if ((j + l) > f && Math.abs((j + l) - f) > 1) {
                    n = true;
                }
                if ((k + m) > h && Math.abs((k + m) - h) > 1) {
                    n = true;
                }
                if (n) {
                    this.zx.cg(c.i._inner[i]);
                    continue;
                }
                let o = c.i._inner[i];
                let p = Math.min(c.f._inner[i], c.n._inner[i]);
                let q = Math.min(c.g._inner[i], c.o._inner[i]);
                let r = c.n._inner[i] - c.f._inner[i];
                let s = c.o._inner[i] - c.g._inner[i];
                if (o != null) {
                    this.zx.ci(o, p, q, r, s);
                }
            }
        }
        ga() {
            return true;
        }
    }
    ItemToolTipLayer.$t = /*@__PURE__*/ markType(ItemToolTipLayer, 'ItemToolTipLayer', AnnotationLayer.$);
    ItemToolTipLayer.$$p = /*@__PURE__*/ markDep(DependencyProperty, PropertyMetadata, ItemToolTipLayer, 'raisePropertyChanged', ['SkipUnknownValues:z0:aaa', [0, true], 'TargetSeriesName:z4:aab', [2, null], 'TargetSeries:zy:aac', [Series.$, null], 'UseInterpolation:z1:aad', [0, false]]);
    return ItemToolTipLayer;
})();
/**
 * @hidden
 */
export let ItemToolTipLayerView = /*@__PURE__*/ (() => {
    class ItemToolTipLayerView extends AnnotationLayerView {
        constructor(a) {
            super(a);
            this.b7 = null;
            this.b8 = null;
            this.ca = null;
            this._htmlTest = null;
            this.b7 = a;
            this.ca = new List$1(PointerTooltip.$, 0);
        }
        au() {
            super.au();
            this.b8 = ((() => {
                let $ret = new Pool$1(Base.$);
                $ret.create = runOn(this, this.cb);
                $ret.activate = runOn(this, this.cd);
                $ret.disactivate = runOn(this, this.cf);
                $ret.destroy = runOn(this, this.ce);
                return $ret;
            })());
            this.htmlTest = /^[^<]*(<[\w\W]+>)[^>]*$/;
        }
        ak() {
            super.ak();
            for (let a = 0; a < this.b8.a.count; a++) {
                this.b8.a._inner[a].br();
            }
            for (let b = 0; b < this.b8.b.count; b++) {
                this.b8.b._inner[b].br();
            }
            this.b8.clear();
        }
        cb() {
            let a = new PointerTooltip();
            a.bw(this.e.jz);
            a._visibility = 1;
            a.ap = this.e.db.c9.k;
            this.ca.add(a);
            return a;
        }
        cd(a) {
            let b = a;
        }
        cf(a) {
            let b = a;
            b._visibility = 1;
        }
        ce(a) {
            let b = a;
            b.bz();
            b.content = null;
            this.ca.remove1(a);
        }
        get htmlTest() {
            return this._htmlTest;
        }
        set htmlTest(a) {
            this._htmlTest = a;
        }
        b9(a, b, c, d) {
            let e = b;
            if (a.k2 == "default") {
                a.k2 = a.cv.getDefaultTooltipTemplate();
            }
            let template_ = a.k2;
            let context_ = d;
            if (a.toolTip == null) {
                return false;
            }
            let tooltip_ = a.toolTip;
            if ((tooltip_.updateToolTip)) {
                tooltip_._inPointer = true;
                tooltip_.updateToolTip(context_, true);
                tooltip_.setStyleProperty('position', 'relative');
                tooltip_.setStyleProperty('left', '');
                tooltip_.setStyleProperty('top', '');
            }
            e.content = a.toolTip;
            return true;
        }
        ck(a, b, c) {
            let d = a;
            let e = d.content;
            let f = new Size(1, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);
            d.cy = 1;
            let g = d.cx(new Size(1, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY));
            d.cy = 0;
            return g;
        }
        ci(a, b, c, d, e) {
            let f = null;
            if (this.e.db != null) {
                f = this.e.db.c9.j.i();
            }
            let g = a;
            g.aq = f;
            let h = g.content;
            g.cs = { $type: Point_$type, x: d, y: e };
            g._visibility = 0;
            g.n = b;
            g.o = c;
        }
        cg(a) {
            if (a != null) {
                let b = a;
                b._visibility = 1;
            }
        }
        a8(a, b) {
            super.a8(a, b);
            if (b) {
                return;
            }
            let c = 0;
            let d = 0;
            let e = this.e.db;
            if (e != null) {
                let f = e.c9.j.b8();
                c += f.x;
                d += f.y;
            }
            for (let g = 0; g < this.ca.count; g++) {
                this.ca._inner[g].by(this.ca._inner[g].n + c, this.ca._inner[g].o + d);
            }
        }
        an(a) {
            super.an(a);
            for (let tooltip_ of fromEnum(this.b8.a)) {
                if (tooltip_._visibility != 0) {
                    continue;
                }
                let b = tooltip_;
                let c = b.a5();
                let d = b.n;
                let e = b.o;
                let f = new List$1(String_$type, 0);
                let g = b.content;
                if (g != null) {
                    let h = g.findByClass("ui-chart-default-tooltip-content");
                    if (h != null && h.length > 0 && h[0] != null && h[0].getChildCount() > 0) {
                        let i = h[0];
                        let j = i.getChildAt(0);
                        let k = j.getText();
                        f.add(k);
                    }
                    else {
                        let l = g.getText();
                        f.add(l);
                    }
                }
                this.e.bc.addPointerTooltipData(a, c, d, e, f);
            }
        }
        ch(a) {
            this.as();
            for (let b = 0; b < this.ca.count; b++) {
                this.cg(this.ca._inner[b]);
                if (a) {
                    this.ca._inner[b].bs();
                }
            }
        }
        cj() {
            if (this.e.db == null) {
                this.ch(true);
            }
        }
    }
    ItemToolTipLayerView.$t = /*@__PURE__*/ markType(ItemToolTipLayerView, 'ItemToolTipLayerView', AnnotationLayerView.$);
    return ItemToolTipLayerView;
})();
