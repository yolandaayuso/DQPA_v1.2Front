/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { Base, Point_$type, fromEnum, markType } from "igniteui-react-core";
import { List$1 } from "igniteui-react-core";
import { BezierPoint } from "./BezierPoint";
import { Stack$1 } from "igniteui-react-core";
import { BezierOp } from "./BezierOp";
import { CompareUtil } from "igniteui-react-core";
/**
 * @hidden
 */
export let Bezier = /*@__PURE__*/ (() => {
    class Bezier extends Base {
        get j() {
            return this.h;
        }
        get q() {
            return this.m;
        }
        get r() {
            return this.n;
        }
        get s() {
            return this.o;
        }
        get t() {
            return this.p;
        }
        constructor(a, b, c, d, e, f) {
            super();
            this.h = 0;
            this.m = null;
            this.n = null;
            this.o = null;
            this.p = null;
            this.i = 1.7976931348623157E+308;
            this.d = false;
            this.e = null;
            this.f = null;
            this.g = new Stack$1(BezierOp.$);
            this.m = a;
            this.n = b;
            this.o = c;
            this.p = d;
            this.h = e;
            this.i = f;
            this.d = this.c();
        }
        a(a) {
            let b = 1 - a;
            let c = b * b;
            let d = c * b;
            let e = a * a;
            let f = e * a;
            let g = { $type: Point_$type, x: d * this.m.x + 3 * c * a * this.n.x + 3 * b * e * this.o.x + f * this.p.x, y: d * this.m.y + 3 * c * a * this.n.y + 3 * b * e * this.o.y + f * this.p.y };
            let h = new BezierPoint();
            h.c = g;
            h.a = a;
            return h;
        }
        c() {
            this.e = new List$1(BezierPoint.$, 0);
            this.f = new List$1(BezierPoint.$, 0);
            let a = new BezierOp();
            a.b = 0;
            a.a = 1;
            this.g.g();
            this.g.h(a);
            let b = 0;
            while (this.g.f > 0) {
                let c = this.g.e();
                let d = this.a(c.b);
                let e = this.a(c.a);
                let f = (e.c.x - d.c.x) * (e.c.x - d.c.x) + (e.c.y - d.c.y) * (e.c.y - d.c.y);
                if (f < this.h) {
                    d.b = b++;
                    e.b = b++;
                    this.e.add(d);
                    this.e.add(e);
                    if (d.c.x > this.i || e.c.x > this.i) {
                        return false;
                    }
                }
                else {
                    let g = (c.b + c.a) / 2;
                    let h = new BezierOp();
                    h.b = c.b;
                    h.a = g;
                    let i = new BezierOp();
                    i.b = g;
                    i.a = c.a;
                    this.g.h(i);
                    this.g.h(h);
                }
            }
            for (let j of fromEnum(this.e)) {
                this.f.add(j);
            }
            this.l();
            return true;
        }
        l() {
            this.f.aa((a, b) => CompareUtil.compareToObject(a.c.y, b.c.y));
        }
        b(a) {
            let b = this.k((c) => {
                if (a < c.c.y) {
                    return -1;
                }
                if (a > c.c.y) {
                    return 1;
                }
                return 0;
            });
            if (b < 0) {
                b = ~b;
            }
            if (b < 0) {
                b = 0;
            }
            if (b > this.f.count - 1) {
                b = this.f.count - 1;
            }
            let c = 100000001;
            let d = 100000000;
            let e = 100000002;
            d = Math.abs(this.f._inner[b].c.y - a);
            if (b - 1 >= 0) {
                c = Math.abs(this.f._inner[b - 1].c.y - a);
            }
            if (b + 1 < this.f.count) {
                e = Math.abs(this.f._inner[b + 1].c.y - a);
            }
            if (d <= c && d <= e) {
                return this.f._inner[b];
            }
            if (c <= d && c <= e && b - 1 > 0) {
                return this.f._inner[b - 1];
            }
            if (e <= c && e <= d && b + 1 < this.f.count) {
                return this.f._inner[b + 1];
            }
            return this.f._inner[b];
        }
        k(a) {
            let b = 0;
            let c = this.f.count - 1;
            while (b <= c) {
                let d = (b + ((c - b) >> 1));
                let e = a(this.f._inner[d]);
                if (e < 0) {
                    c = d - 1;
                }
                else if (e > 0) {
                    b = d + 1;
                }
                else {
                    return d;
                }
            }
            return ~b;
        }
    }
    Bezier.$t = /*@__PURE__*/ markType(Bezier, 'Bezier');
    return Bezier;
})();
