/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { TrendLineManagerBase$1 } from "./TrendLineManagerBase$1";
import { Point_$type, fromEnum, markType } from "igniteui-react-core";
import { List$1 } from "igniteui-react-core";
import { TrendFitCalculator } from "./TrendFitCalculator";
import { TrendAverageCalculator } from "./TrendAverageCalculator";
import { PolarLinePlanner } from "./PolarLinePlanner";
import { isNaN_ } from "igniteui-react-core";
/**
 * @hidden
 */
export let PolarTrendLineManager = /*@__PURE__*/ (() => {
    class PolarTrendLineManager extends TrendLineManagerBase$1 {
        constructor() {
            super(Point_$type);
            this.i = false;
            this.h = 0;
            this.k = 0;
            this.j = 0;
            this.l = null;
            this.m = null;
        }
        get_g$a() {
            return 2;
        }
        get g$a() {
            return this.get_g$a();
        }
        n(a, b, c, d, e, f, g, h, i, j, k) {
            let l = j;
            let m = k;
            let n = new List$1(Point_$type, 0);
            if (!h.j.isEmpty && !h.i.isEmpty) {
                let o = c;
                let p = d;
                let q = 0;
                if (o != null) {
                    q = o.count;
                }
                if (p != null) {
                    q = Math.min(q, p.count);
                }
                if (b == 0) {
                    this.a = null;
                    this.d.clear();
                    return;
                }
                if (this.c(b)) {
                    this.d.clear();
                    this.a = TrendFitCalculator.a(n, b, h, this.a, q, (r) => o.item(r), (r) => p.item(r), f, g, l, m);
                }
                if (this.b(b)) {
                    this.a = null;
                    TrendAverageCalculator.c(b, this.d, c, d, e);
                    for (let r of fromEnum(this.d)) {
                        let s = f(r.x);
                        let t = g(r.y);
                        if (!isNaN_(s) && !isNaN_(t)) {
                            n.add({ $type: Point_$type, x: s, y: t });
                        }
                    }
                }
                if (n.count > 0) {
                    this.f(n, h, a, i);
                }
            }
        }
        f(a, b, c, d) {
            if (d != null) {
                d.i = c;
            }
            let e = ((() => {
                let $ret = new PolarLinePlanner();
                $ret.m = (f) => a.item(f).x;
                $ret.n = (f) => a.item(f).y;
                $ret.a = d;
                $ret.q = a.count;
                $ret.l = b.d;
                $ret.o = (f) => this.l(a.item(f).x, a.item(f).y);
                $ret.p = (f) => this.m(a.item(f).x, a.item(f).y);
                $ret.f = this.i;
                $ret.b = this.h;
                $ret.ad = b.i;
                $ret.ac = b.h;
                $ret.ae = b.j;
                return $ret;
            })());
            e.x(null, null);
        }
    }
    PolarTrendLineManager.$t = /*@__PURE__*/ markType(PolarTrendLineManager, 'PolarTrendLineManager', /*@__PURE__*/ TrendLineManagerBase$1.$.specialize(Point_$type));
    return PolarTrendLineManager;
})();
