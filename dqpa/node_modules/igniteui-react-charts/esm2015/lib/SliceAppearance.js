/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { Base, Point_$type, fromEnum, markType } from "igniteui-react-core";
import { PointList } from "./PointList";
import { PointCollection } from "igniteui-react-core";
import { Rect } from "igniteui-react-core";
import { BrushUtil } from "igniteui-react-core";
import { intDivide, isNaN_ } from "igniteui-react-core";
/**
 * @hidden
 */
export let SliceAppearance = /*@__PURE__*/ (() => {
    class SliceAppearance extends Base {
        constructor() {
            super();
            this.l = 0;
            this.k = 0;
            this.az = null;
            this.a0 = null;
            this.a = null;
            this.b = null;
            this.bb = null;
            this.ba = null;
            this.a1 = null;
            this.ay = null;
            this.ax = null;
            this.bi = null;
            this.ai = null;
            this.an = null;
            this.aj = null;
            this.ak = null;
            this.y = null;
            this.aw = null;
            this.g = false;
            this.z = null;
            this.x = null;
            this.bk = 1;
            this.n = 1;
            this.m = 0.5;
            this.au = null;
            this.av = null;
            this.v = 0;
            this.be = Rect.empty;
            this.bf = Rect.empty;
            this.al = null;
            this.am = null;
            this.bl = 0;
            this.h = false;
            this.u = 0;
            this.o = 1;
            this.ax = { $type: Point_$type, x: 0, y: 0 };
            this.ay = { $type: Point_$type, x: 0, y: 0 };
            this.a0 = { $type: Point_$type, x: 0, y: 0 };
            this.a1 = { $type: Point_$type, x: 0, y: 0 };
            this.az = { $type: Point_$type, x: 0, y: 0 };
        }
        get q() {
            return this.l;
        }
        set q(a) {
            this.l = a;
            this.ag();
        }
        get p() {
            return this.k;
        }
        set p(a) {
            this.k = a;
            this.ag();
        }
        get a7() {
            return this.az;
        }
        set a7(a) {
            this.az = a;
        }
        get a8() {
            return this.a0;
        }
        set a8(a) {
            this.a0 = a;
            this.ag();
        }
        get c() {
            return this.a;
        }
        set c(a) {
            this.a = a;
            this.ag();
        }
        get e() {
            return this.b;
        }
        set e(a) {
            this.b = a;
            this.ag();
        }
        get bd() {
            return this.bb;
        }
        set bd(a) {
            this.bb = a;
        }
        get bc() {
            return this.ba;
        }
        set bc(a) {
            this.ba = a;
        }
        ah() {
            this.ag();
        }
        ag() {
        }
        ad() {
            let a = new PointCollection(0);
            let b = !isNaN_(this.s);
            let c = b ? new PointCollection(0) : null;
            if (this.e != null) {
                for (let d of fromEnum(this.e)) {
                    a.add(d);
                    if (b && d.y < this.a2.y) {
                        c.add(d);
                    }
                }
            }
            else {
                a.add(this.a8);
                a.add(this.a9);
                if (b) {
                    c.add(this.a2);
                    c.add(this.a3);
                }
            }
            if (this.c != null) {
                for (let e of fromEnum(this.c)) {
                    a.add(e);
                    if (b && e.y > this.a2.y) {
                        c.add(e);
                    }
                }
                if (this.e != null && this.e.count > 0) {
                    a.add(this.e._inner[0]);
                    if (b && c.count > 0) {
                        c.add(c._inner[0]);
                    }
                }
            }
            else {
                a.add(this.a6);
                a.add(this.a5);
                a.add(this.a8);
                if (b) {
                    c.add(this.a6);
                    c.add(this.a5);
                    c.add(this.a2);
                }
            }
            let f = 0, g = Math.min(intDivide(a.count, 2), 5);
            if (g > 1) {
                let h = a._inner[0];
                let i = 0, j = h.x, k = h.y;
                while (++f < g && i < 2) {
                    h = a._inner[f];
                    i = Math.abs(h.x - j) + Math.abs(h.y - k);
                    if (i > 1) {
                        a.add({ $type: Point_$type, x: h.x, y: h.y });
                    }
                }
            }
            this.bd = a;
            this.bc = c;
        }
        get a9() {
            return this.a1;
        }
        set a9(a) {
            this.a1 = a;
            this.ag();
        }
        get a6() {
            return this.ay;
        }
        set a6(a) {
            this.ay = a;
            this.ag();
        }
        get a5() {
            return this.ax;
        }
        set a5(a) {
            this.ax = a;
            this.ag();
        }
        get bj() {
            return this.bi;
        }
        set bj(a) {
            this.bi = a;
        }
        get ao() {
            return this.ai;
        }
        set ao(a) {
            this.ai = a;
        }
        get at() {
            return this.an;
        }
        set at(a) {
            this.an = a;
        }
        get ap() {
            return this.aj;
        }
        set ap(a) {
            this.aj = a;
        }
        get aq() {
            return this.ak;
        }
        set aq(a) {
            this.ak = a;
        }
        ae(a, b, c, d) {
            if (a == null) {
                this.ao = null;
                this.ap = null;
            }
            else {
                this.ap = a;
                if (d) {
                    this.ao = BrushUtil.q(a, c);
                }
                else {
                    this.ao = a;
                }
            }
            if (b == null) {
                this.at = null;
                this.aq = null;
            }
            else {
                this.aq = b;
                if (d) {
                    this.at = BrushUtil.q(b, c);
                }
                else {
                    this.at = b;
                }
            }
        }
        get ab() {
            return this.y;
        }
        set ab(a) {
            this.y = a;
        }
        get a4() {
            return this.aw;
        }
        set a4(a) {
            this.aw = a;
        }
        get i() {
            return this.g && this.y != null;
        }
        set i(a) {
            this.g = a;
        }
        get item() {
            return this.z;
        }
        set item(a) {
            this.z = a;
        }
        get aa() {
            return this.x;
        }
        set aa(a) {
            this.x = a;
        }
        get bm() {
            return this.bk;
        }
        set bm(a) {
            this.bk = a;
        }
        get s() {
            return this.n;
        }
        set s(a) {
            this.n = a;
        }
        af() {
            if (this.x == null || isNaN_(this.x) || this.z == null || isNaN_(this.z) || this.bm != 0) {
                this.s = 1;
                return;
            }
            this.s = Math.min(1, Math.max(0, Math.abs(this.x / this.z)));
        }
        get r() {
            return this.m;
        }
        set r(a) {
            this.m = a;
        }
        get a2() {
            return this.au;
        }
        set a2(a) {
            this.au = a;
        }
        get a3() {
            return this.av;
        }
        set a3(a) {
            this.av = a;
        }
        get w() {
            return this.v;
        }
        set w(a) {
            this.v = a;
        }
        get bg() {
            return this.be;
        }
        set bg(a) {
            this.be = a;
        }
        get bh() {
            return this.bf;
        }
        set bh(a) {
            this.bf = a;
        }
        get ar() {
            return this.al;
        }
        set ar(a) {
            this.al = a;
        }
        get as() {
            return this.am;
        }
        set as(a) {
            this.am = a;
        }
        get bn() {
            return this.bl;
        }
        set bn(a) {
            this.bl = a;
        }
        get j() {
            return this.h;
        }
        set j(a) {
            this.h = a;
        }
        get t() {
            return this.o;
        }
        set t(a) {
            this.o = a;
        }
        static f(a, b, c, d, e) {
            if (a == null) {
                a = new SliceAppearance();
            }
            a.i = c.i;
            a.ab = c.ab;
            if (b.i && c.i) {
                a.a4 = { $type: Point_$type, x: (b.a4.x * e) + (c.a4.x * d), y: (b.a4.y * e) + (c.a4.y * d) };
            }
            else if (c.i) {
                a.a4 = { $type: Point_$type, x: c.a4.x * d, y: c.a4.y * d };
            }
            a.a5 = { $type: Point_$type, x: (b.a5.x * e) + (c.a5.x * d), y: (b.a5.y * e) + (c.a5.y * d) };
            a.a6 = { $type: Point_$type, x: (b.a6.x * e) + (c.a6.x * d), y: (b.a6.y * e) + (c.a6.y * d) };
            a.a8 = { $type: Point_$type, x: (b.a8.x * e) + (c.a8.x * d), y: (b.a8.y * e) + (c.a8.y * d) };
            a.a9 = { $type: Point_$type, x: (b.a9.x * e) + (c.a9.x * d), y: (b.a9.y * e) + (c.a9.y * d) };
            a.a7 = { $type: Point_$type, x: (b.a7.x * e) + (c.a7.x * d), y: (b.a7.y * e) + (c.a7.y * d) };
            a.a2 = { $type: Point_$type, x: (b.a2.x * e) + (c.a2.x * d), y: (b.a2.y * e) + (c.a2.y * d) };
            a.a3 = { $type: Point_$type, x: (b.a3.x * e) + (c.a3.x * d), y: (b.a3.y * e) + (c.a3.y * d) };
            if (c.c != null) {
                let f = b.c;
                if (f == null) {
                    f = new PointList();
                    f.add(b.a8);
                    f.add(b.a5);
                }
                a.c = SliceAppearance.d(a.c, f, c.c, d, e);
            }
            else {
                a.c = null;
            }
            if (c.e != null) {
                let g = b.e;
                if (g == null) {
                    g = new PointList();
                    g.add(b.a6);
                    g.add(b.a9);
                }
                a.e = SliceAppearance.d(a.e, g, c.e, d, e);
            }
            else {
                a.e = null;
            }
            a.bj = c.bj;
            a.item = c.item;
            a.aa = c.aa;
            a.bm = (b.bm == 0 || c.bm == 0) ? 0 : 1;
            if (a.bm == 0 && c.bm != 0) {
                a.ao = b.ao;
                a.at = b.at;
            }
            else {
                a.ao = c.ao;
                a.at = c.at;
            }
            a.w = c.w;
            a.ad();
            return a;
        }
        static d(a, b, c, d, e) {
            if (a == null) {
                a = new PointList();
            }
            if (b == null) {
                b = new PointList();
            }
            let f = b.count;
            let g = c.count;
            let h = Math.max(f, g);
            if (a.count < h) {
                a.s(a.count, new Array(h - a.count));
            }
            if (a.count > h) {
                a.v(h, a.count - h);
            }
            for (let i = 0; i < Math.min(f, g); ++i) {
                a._inner[i] = { $type: Point_$type, x: (b._inner[i].x * e) + (c._inner[i].x * d), y: (b._inner[i].y * e) + (c._inner[i].y * d) };
            }
            if (f < g) {
                let j = f > 0 ? b._inner[f - 1] : { $type: Point_$type, x: 0, y: 0 };
                for (let k = f; k < g; ++k) {
                    a._inner[k] = { $type: Point_$type, x: (j.x * e) + (c._inner[k].x * d), y: (j.y * e) + (c._inner[k].y * d) };
                }
            }
            if (f > g) {
                let l = g > 0 ? c._inner[g - 1] : { $type: Point_$type, x: 0, y: 0 };
                for (let m = g; m < f; ++m) {
                    a._inner[m] = { $type: Point_$type, x: (b._inner[m].x * e) + (l.x * d), y: (b._inner[m].y * e) + (l.y * d) };
                }
            }
            return a;
        }
    }
    SliceAppearance.$t = /*@__PURE__*/ markType(SliceAppearance, 'SliceAppearance');
    return SliceAppearance;
})();
