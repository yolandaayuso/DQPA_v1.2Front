import { IgrCategoryAxisBase } from "./igr-category-axis-base";
import { IgrNumericAxisBase } from "./igr-numeric-axis-base";
import { IgrFragmentBase } from "./igr-fragment-base";
import { ColumnFragment } from "./ColumnFragment";
import { toPoint, fromRect } from "igniteui-react-core";
/**
 * Represents one part of a StackedColumnSeries.
*/
export class IgrColumnFragment extends IgrFragmentBase {
    createImplementation() {
        return new ColumnFragment();
    }
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    constructor(props) {
        super(props);
    }
    /**
     * Gets whether the current series shows a column shape.
    */
    get isColumn() {
        return this.i.ez;
    }
    /**
     * Overridden by derived series classes to indicate when marker-less display is preferred or not.
    */
    get isMarkerlessDisplayPreferred() {
        return this.i.fl;
    }
    /**
     * Gets or sets the x-radius of the ellipse that is used to round the corners of the column.
    */
    get radiusX() {
        return this.i.adb;
    }
    set radiusX(v) {
        this.i.adb = +v;
    }
    /**
     * Gets or sets the y-radius of the ellipse that is used to round the corners of the column.
    */
    get radiusY() {
        return this.i.adc;
    }
    set radiusY(v) {
        this.i.adc = +v;
    }
    /**
     * Gets or sets the effective x-axis for this series.
    */
    get fragmentXAxis() {
        const r = this.i.fragmentXAxis;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = IgrCategoryAxisBase._createFromInternal(r);
            if (e) {
                e._implementation = r;
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    /**
     * Gets or sets the effective y-axis for this series.
    */
    get fragmentYAxis() {
        const r = this.i.fragmentYAxis;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = IgrNumericAxisBase._createFromInternal(r);
            if (e) {
                e._implementation = r;
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    _styling(container, component, parent) {
        super._styling(container, component, parent);
        this._inStyling = true;
        if (this.fragmentXAxis && this.fragmentXAxis._styling) {
            this.fragmentXAxis._styling(container, component, this);
        }
        if (this.fragmentYAxis && this.fragmentYAxis._styling) {
            this.fragmentYAxis._styling(container, component, this);
        }
        this._inStyling = false;
    }
    /**
     * If possible, will return the best available value bounding box within the series that has the best value match for the world position provided.
    
    * @param world  * The world coordinate for which to get a value bounding box for
    */
    getSeriesValueBoundingBox(world) {
        let iv = this.i.wn(toPoint(world));
        return fromRect(iv);
    }
    /**
     * Gets the item that is the best match for the specified world coordinates.
    
    * @param world  * The world coordinates to use.
    */
    getItem(world) {
        let iv = this.i.kn(toPoint(world));
        return (iv);
    }
    /**
     * Gets the index of the item that resides at the provided world coordinates.
    
    * @param world  * The world coordinates of the requested item.
    */
    getItemIndex(world) {
        let iv = this.i.j3(toPoint(world));
        return (iv);
    }
}
