/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { ScatterBase } from "./ScatterBase";
import { DependencyProperty } from "igniteui-react-core";
import { Point_$type, typeCast, runOn, markType, markDep } from "igniteui-react-core";
import { ScatterFrame } from "./ScatterFrame";
import { ScatterSplineSeriesView } from "./ScatterSplineSeriesView";
import { Defaults } from "./Defaults";
import { Clipper } from "igniteui-react-core";
import { OwnedPoint } from "./OwnedPoint";
import { ScalerParams } from "./ScalerParams";
import { PathGeometry } from "igniteui-react-core";
import { Numeric } from "igniteui-react-core";
import { PropertyMetadata } from "igniteui-react-core";
import { isNaN_ } from "igniteui-react-core";
/**
 * @hidden
 */
export let ScatterSplineSeries = /*@__PURE__*/ (() => {
    class ScatterSplineSeries extends ScatterBase {
        bj() {
            return new ScatterSplineSeries();
        }
        get_f0() {
            return true;
        }
        constructor() {
            super();
            this.ab = ScatterSplineSeries.$;
            this.y2 = new ScatterFrame();
            this.y4 = new ScatterFrame();
            this.y0 = new ScatterFrame();
        }
        cs() {
            return new ScatterSplineSeriesView(this);
        }
        zw() {
            return true;
        }
        jk() {
            if (!isNaN_(this.jj)) {
                return super.jk();
            }
            return Defaults.x;
        }
        q9(a, b, c, d) {
            super.q9(a, b, c, d);
            switch (b) {
                case ScatterSplineSeries.$$p[0]:
                    this.rr(false);
                    this.ql();
                    break;
            }
        }
        b2() {
            if (this.b3 == 0) {
                return 2;
            }
            else {
                return super.b2();
            }
        }
        abf(a, b) {
            super.abf(a, b);
            a.m.clear();
            a.u.clear();
            let c = b.by;
            let d = b.bx;
            let e = this.getEffectiveViewport1(b);
            let f = this.id * this.id;
            let g = Math.min(this.zh != null ? this.zh.count : 0, this.zi != null ? this.zi.count : 0);
            let h = new ScalerParams(0, c, d, this.yw.d, e);
            let i = ((() => {
                let $ret = new ScalerParams(0, c, d, this.yw.e, e);
                $ret.b = this.iy();
                return $ret;
            })());
            let j = (k) => this.yw.a.el(this.zh.item(k), h);
            let k = (l) => this.yw.b.el(this.zi.item(l), i);
            let l = ((() => {
                let $ret = new Clipper(0, d, false);
                $ret.i = a.m;
                return $ret;
            })());
            for (let m = 0; m < g;) {
                let n = m;
                ++m;
                while (m < g && this.acn(j, k, n, m) < f) {
                    ++m;
                }
                if (g > this.z9) {
                    l.j(this.acr(j, k, n, m - 1));
                }
                else {
                    let o = new OwnedPoint();
                    o.c = { $type: Point_$type, x: j(n), y: k(n) };
                    o.a = this.dn.item(n);
                    if (!a.u.containsKey(o.a)) {
                        a.u.addItem(o.a, o);
                    }
                }
            }
            if (g > this.z9) {
                l.i = null;
            }
        }
        acr(a, b, c, d) {
            if (c == d) {
                return { $type: Point_$type, x: a(c), y: b(c) };
            }
            let e = 0;
            let f = 0;
            let g = (d - c + 1);
            for (let h = c; h <= d; ++h) {
                e += a(h);
                f += b(h);
            }
            return { $type: Point_$type, x: e / g, y: f / g };
        }
        acn(a, b, c, d) {
            let e = a(d) - a(c);
            let f = b(d) - b(c);
            return e * e + f * f;
        }
        get_zq() {
            return true;
        }
        o5(a, b) {
            super.o5(a, b);
            let c = typeCast(ScatterSplineSeriesView.$, b);
            c.c9(false);
        }
        abq(a, b) {
            this.o5(false, b);
            super.abq(a, b);
            this.abi(a);
            let c = typeCast(ScatterSplineSeriesView.$, b);
            let d = c.dl;
            this.y9.az(this, this.zv(), runOn(this, this.yp));
            let e = false;
            let f = this.y9.b;
            if (f != null) {
                e = true;
            }
            if (e) {
                this.abb(-1, this.zh.count, b.q);
            }
            this.y9.ad(d, true, false, true, false);
            c.dl.an = new PathGeometry();
            c.dl.an.c = Numeric.h(a.m.count, (g) => a.m._inner[g].x, (g) => a.m._inner[g].y, this.aco);
        }
    }
    ScatterSplineSeries.$t = /*@__PURE__*/ markType(ScatterSplineSeries, 'ScatterSplineSeries', ScatterBase.$);
    ScatterSplineSeries.$$p = /*@__PURE__*/ markDep(DependencyProperty, PropertyMetadata, ScatterSplineSeries, 'raisePropertyChanged', ['Stiffness:aco:acq', [1, 0.5]]);
    return ScatterSplineSeries;
})();
