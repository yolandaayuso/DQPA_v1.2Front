/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { FinancialSeries } from "./FinancialSeries";
import { ITrendLineSeries_$type } from "./ITrendLineSeries";
import { TrendLineType_$type } from "igniteui-react-core";
import { DependencyProperty } from "igniteui-react-core";
import { Brush } from "igniteui-react-core";
import { PenLineCap_$type } from "igniteui-react-core";
import { DoubleCollection } from "igniteui-react-core";
import { PriceDisplayType_$type } from "./PriceDisplayType";
import { CategoryCollisionMode_$type } from "./CategoryCollisionMode";
import { Series } from "./Series";
import { Defaults } from "./Defaults";
import { enumGetBox, EnumUtil, Number_$type, typeCast, fromEnum, runOn, Point_$type, markType, markDep } from "igniteui-react-core";
import { CategoryFrame } from "./CategoryFrame";
import { ISortingAxis_$type } from "./ISortingAxis";
import { FinancialSeriesView } from "./FinancialSeriesView";
import { Rect } from "igniteui-react-core";
import { List$1 } from "igniteui-react-core";
import { RectUtil } from "igniteui-react-core";
import { CategoryTrendLineManagerFactory } from "./CategoryTrendLineManagerFactory";
import { AxisRange } from "./AxisRange";
import { ScalerParams } from "./ScalerParams";
import { TrendResolutionParams } from "./TrendResolutionParams";
import { Pool$1 } from "igniteui-react-core";
import { Path } from "igniteui-react-core";
import { Thickness } from "igniteui-react-core";
import { PathGeometry } from "igniteui-react-core";
import { PathFigure } from "igniteui-react-core";
import { LineSegment } from "igniteui-react-core";
import { GeometryGroup } from "igniteui-react-core";
import { LineGeometry } from "igniteui-react-core";
import { RectangleGeometry } from "igniteui-react-core";
import { DataLegendSeriesValueInfo } from "igniteui-react-core";
import { DataLegendSeriesContext } from "igniteui-react-core";
import { ChartSelection } from "./ChartSelection";
import { PropertyMetadata } from "igniteui-react-core";
import { truncate, isNaN_, isInfinity } from "igniteui-react-core";
import { boxArray$1 } from "igniteui-react-core";
import { round10N } from "igniteui-react-core";
import { FinancialPriceBucketCalculator } from "./FinancialPriceBucketCalculator";
import { Extensions } from "igniteui-react-core";
/**
 * @hidden
 */
export let FinancialPriceSeries = /*@__PURE__*/ (() => {
    class FinancialPriceSeries extends FinancialSeries {
        bj() {
            return new FinancialPriceSeries();
        }
        get_e9() {
            return true;
        }
        jk() {
            if (!isNaN_(this.jj)) {
                return super.jk();
            }
            return Defaults.k;
        }
        cs() {
            return new FinancialPriceSeriesView(this);
        }
        q1(a) {
            super.q1(a);
            this.aa2 = a;
        }
        constructor() {
            super();
            this.aa4 = true;
            this.aa5 = 0;
            this.aa6 = 0;
            this.ab = FinancialPriceSeries.$;
            this.xa = new CategoryFrame(5);
            this.xc = new CategoryFrame(5);
            this.w8 = new CategoryFrame(5);
        }
        get acl() {
            return this.c(FinancialPriceSeries.ab2);
        }
        set acl(a) {
            this.h(FinancialPriceSeries.ab2, a);
        }
        pb(a, b, c, d) {
            super.pb(a, b, c, d);
            if (this.w6 != null && typeCast(ISortingAxis_$type, this.w6) !== null) {
                this.w6.i$i();
            }
            this.aa2.b0.e(this.id);
            if (this.aa2.ca) {
                this.aa2.b8.g$e(a, b, c, d);
            }
            if (this.xp != null) {
                this.xp.c1();
            }
            this.rr(true);
            if (a == 0 || a == 2 || a == 3 || a == 4) {
                this.aa4 = true;
            }
            else if (a == 1) {
                for (let e = b; e < b + c; e++) {
                    let f = 0;
                    f += this.x0.item(e);
                    f += this.x1.item(e);
                    f += this.xz.item(e);
                    this.aa5 += f / 3;
                }
                this.aa6 = this.aa5 / this.x0.count;
            }
        }
        b2() {
            if (this.b3 == 0) {
                return 1;
            }
            else {
                return super.b2();
            }
        }
        wn(a) {
            if (this.w8 == null || this.w8.f.count == 0) {
                return Rect.empty;
            }
            let b = this.v7(a);
            let c = this.cv.by;
            let d = this.cv.bx;
            let e = this.getEffectiveViewport1(this.cv);
            let f = this.an(this.w6, this.w8.f, this.y3(this.cv), this.y5(this.cv), a, true);
            let g = f[0];
            let h = f[1];
            let i = Math.abs(b.x - g[0]);
            let j = Math.abs(b.x - h[0]);
            let k = this.aa7(this.xn, e);
            k = Math.max(k, 3);
            let l = (k - 1) / 2;
            if (i < j) {
                let m = g[0] - l;
                let n = g[0];
                let o = g[0] + l;
                let p = g[1];
                let q = g[2];
                let r = g[3];
                let s = g[4];
                let t = Math.min(Math.min(Math.min(p, q), r), s);
                let u = Math.max(Math.max(Math.max(p, q), r), s);
                return new Rect(0, m, t, Math.abs(o - m), u - t);
            }
            else {
                let v = h[0] - l;
                let w = h[0];
                let x = h[0] + l;
                let y = h[1];
                let z = h[2];
                let aa = h[3];
                let ab = h[4];
                let ac = Math.min(Math.min(Math.min(y, z), aa), ab);
                let ad = Math.max(Math.max(Math.max(y, z), aa), ab);
                return new Rect(0, v, ac, Math.abs(x - v), ad - ac);
            }
        }
        aa0(a, b) {
            let c = a[0] - b;
            let d = a[0];
            let e = a[0] + b;
            let f = a[1];
            let g = a[2];
            let h = a[3];
            let i = a[4];
            let j = Math.min(Math.min(Math.min(f, g), h), i);
            let k = Math.max(Math.max(Math.max(f, g), h), i);
            let l = Math.min(g, h);
            let m = Math.max(g, h);
            let n = Math.min(f, i);
            let o = Math.max(f, i);
            if (this.aa3 == 1) {
                let p = new Array(3);
                let q = new Rect(0, c, f, b, 0);
                let r = new Rect(0, d, i, b, 0);
                let s = new Rect(0, d, l, 0, m - l);
                p[0] = q;
                p[1] = r;
                p[2] = s;
                return p;
            }
            else {
                let t = new Array(2);
                let u = new Rect(0, d, l, 0, m - l);
                let v = new Rect(0, c, n, b * 2, o - n);
                t[0] = u;
                t[1] = v;
                return t;
            }
        }
        ao(a) {
            let b = new List$1(Rect.$, 0);
            let c = this.v7(a);
            let d = this.cv.by;
            let e = this.cv.bx;
            let f = this.getEffectiveViewport1(this.cv);
            let g = this.an(this.w6, this.w8.f, this.y3(this.cv), this.y5(this.cv), a, true);
            let h = g[0];
            let i = g[1];
            let j = Math.abs(c.x - h[0]);
            let k = Math.abs(c.x - i[0]);
            let l = this.aa7(this.xn, f);
            l = Math.max(l, 3);
            let m = (l - 1) / 2;
            if (j < k) {
                return this.aa0(h, m);
            }
            else {
                return this.aa0(i, m);
            }
        }
        gw(a, b) {
            if (this.gz(a, b)) {
                return true;
            }
            return false;
        }
        gz(a, b) {
            let c = this.wo(a);
            if (c.isEmpty) {
                return false;
            }
            let d = RectUtil.r(c, (this.ie / 2) + this.iu(b));
            if (d.containsPoint(a)) {
                let e = this.ap(a);
                if (e != null) {
                    for (let f = 0; f < e.length; f++) {
                        let g = e[f];
                        let h = RectUtil.r(g, (this.ie / 2) + this.iu(b));
                        if (h.containsPoint(a)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        q9(a, b, c, d) {
            switch (b) {
                case FinancialPriceSeries.$$p[4]:
                case FinancialPriceSeries.$$p[5]:
                case FinancialPriceSeries.$$p[6]:
                case FinancialPriceSeries.$$p[7]:
                case FinancialPriceSeries.$$p[1]:
                case FinancialPriceSeries.$$p[2]:
                case FinancialPriceSeries.$$p[9]:
                case FinancialPriceSeries.$$p[10]:
                    this.qf();
                    break;
                case FinancialSeries.$$p[14]:
                    this.aa2.cg();
                    if (this.db != null) {
                        this.db.n2();
                    }
                    break;
                case "TrendLineType":
                    let e = EnumUtil.getEnumValue(TrendLineType_$type, d);
                    if (e != 0) {
                        this.aa2.b8 = CategoryTrendLineManagerFactory.a(this.aa2.b8, this.w6, this.sv, this, this.dr);
                    }
                    break;
            }
            super.q9(a, b, c, d);
            if (this.aa2.ca && this.aa2.b8 != null && this.aa2.b8.g$b(a, b, c, d)) {
                this.rr(false);
                this.ql();
            }
            switch (b) {
                case FinancialPriceSeries.$$p[3]:
                    if (this.sv != null) {
                        this.ab1();
                        this.si();
                        this.w8.x();
                        this.aae(this.w8, this.aa2);
                    }
                    this.ql();
                    break;
                case "ActualHighlightingMode":
                case "ActualSelectionMode":
                case "ActualFocusMode":
                    this.rr(true);
                    break;
                case "TrendLineBrush":
                    this.rf(b);
                    break;
                case "TrendLineType":
                    this.ql();
                    break;
                case FinancialSeries.$$p[10]:
                case FinancialPriceSeries.$$p[8]:
                    this.q3();
                    break;
            }
        }
        ab1() {
            this.aa2.ck();
            if (this.cu != null) {
                this.cu.ck();
            }
        }
        ay(a) {
            if (a != null && a == this.xp && this.x1 != null && !isNaN_(this.x1.minimum) && this.x0 != null && !isNaN_(this.x0.maximum)) {
                return new AxisRange(this.x1.minimum, this.x0.maximum);
            }
            return null;
        }
        az(a) {
            if (a.isEmpty && this.db != null) {
                a = this.db.v4;
            }
            if (this.x1 == null || this.x0 == null) {
                return null;
            }
            let b = this.wj(this.cv);
            let c = new ScalerParams(0, a, this.db.wk, this.w6.ch, this.getEffectiveViewport());
            let d = (this.w6.eo(b.left, c));
            let e = (this.w6.eo(b.right, c));
            if (this.w6.ch) {
                let f = d;
                d = e;
                e = f;
            }
            let g = null;
            if (this.w6.cn) {
                g = this.w6;
                d = g.i$f(d);
                e = g.i$f(e);
            }
            else {
                d = Math.floor(d);
                e = Math.ceil(e);
            }
            d = Math.max(0, Math.min(this.x1.count - 1, d));
            e = Math.max(0, Math.min(this.x1.count - 1, e));
            let h = 1.7976931348623157E+308;
            let i = -1.7976931348623157E+308;
            for (let j = truncate(d); j <= truncate(e); j++) {
                let k = j;
                if (g != null) {
                    k = g.i$b._inner[j];
                }
                let l = this.x1.item(k);
                if (this.x1.mayContainUnknowns) {
                    if (isInfinity(l) || isNaN_(l)) {
                        continue;
                    }
                }
                let m = this.x0.item(k);
                if (this.x0.mayContainUnknowns) {
                    if (isInfinity(m) || isNaN_(m)) {
                        continue;
                    }
                }
                h = Math.min(h, l);
                i = Math.max(i, m);
            }
            let n = new AxisRange(h, i);
            n = this.ax(n, this.xp, a);
            return n;
        }
        iy() {
            return Series.iz(this.x2, typeCast(ISortingAxis_$type, this.w6));
        }
        gd(a) {
            let b = this.dn != null ? this.dn.indexOf(a) : -1;
            let c = this.cv.by;
            c = c.copy();
            let d = this.cv.bx;
            let e = new Rect(0, 0, 0, 1, 1);
            let f = this.wl(this.cv);
            if (b >= 0 && Rect.l_op_Inequality(c, null) && Rect.l_op_Inequality(d, null)) {
                if (this.w6 != null) {
                    let g = new ScalerParams(0, e, e, this.w6.ch, f);
                    let h = this.w6.el(b, g);
                    if (h < c.left + 0.1 * c.width) {
                        h = h + 0.4 * c.width;
                    }
                    if (h > c.right - 0.1 * c.width) {
                        h = h - 0.4 * c.width;
                    }
                    c.x = h - 0.5 * c.width;
                }
                if (this.xp != null && this.x1 != null && this.x0 != null && b < this.x1.count && b < this.x0.count) {
                    let i = new ScalerParams(0, e, e, this.xp.ch, f);
                    i.b = this.iy();
                    let j = this.xp.el(this.x1.item(b), i);
                    let k = this.xp.el(this.x0.item(b), i);
                    if (!isNaN_(j) && !isNaN_(k)) {
                        let l = Math.abs(j - k);
                        if (c.height < l) {
                            c.height = l;
                            c.y = Math.min(j, k);
                        }
                        else {
                            if (j < c.top + 0.1 * c.height) {
                                j = j + 0.4 * c.height;
                            }
                            if (j > c.bottom - 0.1 * c.height) {
                                j = j - 0.4 * c.height;
                            }
                            c.y = j - 0.5 * c.height;
                        }
                    }
                }
                this.c3.au(this.db, c, true);
            }
            return b >= 0;
        }
        he(a, b, c) {
            let d = super.he(a, b, c);
            if (this.x2 == null || this.xz == null || this.x0 == null || this.x1 == null) {
                d = false;
            }
            return d;
        }
        aac(a, b) {
            super.aac(a, b);
            let c = b.by;
            let d = b.bx;
            let e = this.getEffectiveViewport1(b);
            let f = this.w6;
            let g = this.xp;
            let h = new ScalerParams(0, c, d, f.ch, e);
            let i = ((() => {
                let $ret = new ScalerParams(0, c, d, g.ch, e);
                $ret.b = this.iy();
                return $ret;
            })());
            let j = this.w6.ag();
            let k = j[0];
            let l = j[1];
            a.f.clear();
            if (a.m != null) {
                a.m.clear();
            }
            a.n.clear();
            a.q.clear();
            let m = 0;
            let n = typeCast(ISortingAxis_$type, this.w6);
            if (n != null && (n.i$b == null || n.i$b.count != this.dn.count)) {
                return;
            }
            m = this.yx(c, d, e);
            let o = typeCast(FinancialPriceSeriesView.$, b);
            let p = this.id;
            let q = b.b0.b;
            if (this.trendLineType != 0) {
                let r = new Array(this.dn.count);
                let s = 0;
                for (let t of fromEnum(this.yo)) {
                    r[s] = t;
                    s++;
                }
                if (this.aa2.ca) {
                    this.aa2.b8.prepareLineCore(a.q, this.trendLineType, boxArray$1(r), this.trendLinePeriod, (u) => this.w6.el(u, h), (u) => this.xp.el(u, i), ((() => {
                        let $ret = new TrendResolutionParams();
                        $ret.e = b.b0.b;
                        $ret.f = b.b0.c;
                        $ret.g = b.b0.d;
                        $ret.a = m;
                        $ret.d = p;
                        $ret.i = d;
                        $ret.h = e;
                        $ret.c = k;
                        $ret.b = l;
                        return $ret;
                    })()));
                }
            }
            let u = this.w6.eo(2, h) - this.w6.eo(1, h);
            for (let v = b.b0.c; v <= b.b0.d; ++v) {
                let w;
                let x = v * q;
                if (n == null) {
                    w = b.b0.getBucket(v);
                }
                else {
                    let y = n.i$b._inner[v];
                    x = y;
                    let z = n.i$d(y);
                    let aa = this.x2.item(y);
                    let ab = this.x0.item(y);
                    let ac = this.x1.item(y);
                    let ad = this.xz.item(y);
                    let ae = aa;
                    let af = ab;
                    let ag = ac;
                    let ah = ad;
                    let ai = z;
                    while (v < b.b0.d) {
                        y = n.i$b._inner[v + 1];
                        ai = n.i$d(y);
                        if (ai - z > u * p) {
                            break;
                        }
                        x = y;
                        v++;
                        af = Math.max(af, this.x0.item(y));
                        ag = Math.min(ag, this.x1.item(y));
                        ah = this.xz.item(y);
                    }
                    let aj = NaN;
                    if (!isNaN_(z)) {
                        aj = this.w6.el(z, h);
                    }
                    w = [aj, ae, af, ag, ah];
                }
                if (!isNaN_(w[0])) {
                    if (n != null) {
                        w[0] = w[0] + m;
                    }
                    else {
                        w[0] = f.el(w[0], h) + m;
                    }
                    w[1] = g.el(w[1], i);
                    w[2] = g.el(w[2], i);
                    w[3] = g.el(w[3], i);
                    w[4] = g.el(w[4], i);
                    if (n != null) {
                        if (a.m == null) {
                            a.m = new List$1(Number_$type, 0);
                        }
                        a.m.add(x);
                    }
                    a.f.add(w);
                }
            }
            return;
        }
        o5(a, b) {
            super.o5(a, b);
            let c = typeCast(FinancialPriceSeriesView.$, b);
            c.ce();
            if (a) {
                c.b9.count = 0;
            }
            if (c.ca && c.b8 != null) {
                c.b8.g$d();
            }
        }
        sq(a, b) {
            super.sq(a, b);
            if (this.db != null) {
                this.db.n2();
            }
        }
        wv(a, b) {
            if (this.w6 != null && this.w6.categoryMode == 0) {
                let c = this.getEffectiveViewport1(this.cv);
                let d = this.aa7(this.xn, c) / 2;
                return new Thickness(1, d, 0, d, 0);
            }
            return super.wv(a, b);
        }
        get_ed() {
            return true;
        }
        aae(a, b) {
            super.aae(a, b);
            if (this.w6 == null || this.xp == null) {
                return;
            }
            let c = false;
            if (b.b3(a)) {
                c = true;
                b.b5(a);
            }
            this.xf.a2(this, this.ye(), runOn(this, this.wy), this.y3(b), this.y5(b));
            let d = false;
            let e = this.xf.b;
            if (e != null) {
                d = true;
            }
            let f = typeCast(FinancialPriceSeriesView.$, b);
            f.cd();
            f.cb = false;
            if (f.ca) {
                f.b8.g$d();
            }
            if (this.trendLineType != 0) {
                f.b8.g$g(a.q);
            }
            if (d) {
                this.abz(a, b, c);
            }
            else {
                f.b9.count = 0;
                this.aby(a, b);
            }
        }
        iw() {
            let a = this.getEffectiveViewport1(this.cv);
            return this.aa7(this.xn, a);
        }
        abz(a, b, c) {
            let d = this.aa3;
            let e = this.getEffectiveViewport1(b);
            let f = this.aa7(b, e);
            let g = (f - 1) / 2;
            let h = typeCast(ISortingAxis_$type, this.w6) !== null;
            let i = typeCast(FinancialPriceSeriesView.$, b);
            i.cb = true;
            let j = a.f;
            let k = 0;
            let l = this.dn.count;
            let m = this.w6;
            let n = new ScalerParams(0, b.by, b.bx, m.ch, e);
            let o = this.u9;
            let p = this.aaw;
            if (p == null) {
                p = o;
            }
            let q = this.vd;
            let r = this.acm;
            if (r == null) {
                r = q;
            }
            for (let s = 0; s < j.count; ++s) {
                let t = j._inner[s][0] - g;
                let u = j._inner[s][0];
                let v = j._inner[s][0] + g;
                let w = j._inner[s][1];
                let x = j._inner[s][2];
                let y = j._inner[s][3];
                let z = j._inner[s][4];
                if (isNaN_(w) || isNaN_(x) || isNaN_(y) || isNaN_(z)) {
                    continue;
                }
                let aa = i.b9.item(k);
                k++;
                let ab = w < z;
                let ac = new PathGeometry();
                if (c) {
                    switch (d) {
                        case 0:
                            if (ab) {
                                let ad = w;
                                w = z;
                                z = ad;
                            }
                            let ae = new PathFigure();
                            ae._startPoint = { $type: Point_$type, x: u, y: y };
                            ae._segments.add(((() => {
                                let $ret = new LineSegment(1);
                                $ret.c = { $type: Point_$type, x: u, y: w };
                                return $ret;
                            })()));
                            let af = new PathFigure();
                            af._startPoint = { $type: Point_$type, x: t, y: z };
                            af._segments.add(((() => {
                                let $ret = new LineSegment(1);
                                $ret.c = { $type: Point_$type, x: v, y: z };
                                return $ret;
                            })()));
                            af._segments.add(((() => {
                                let $ret = new LineSegment(1);
                                $ret.c = { $type: Point_$type, x: v, y: w };
                                return $ret;
                            })()));
                            af._segments.add(((() => {
                                let $ret = new LineSegment(1);
                                $ret.c = { $type: Point_$type, x: t, y: w };
                                return $ret;
                            })()));
                            af._segments.add(((() => {
                                let $ret = new LineSegment(1);
                                $ret.c = { $type: Point_$type, x: t, y: z };
                                return $ret;
                            })()));
                            let ag = new PathFigure();
                            ag._startPoint = { $type: Point_$type, x: u, y: z };
                            ag._segments.add(((() => {
                                let $ret = new LineSegment(1);
                                $ret.c = { $type: Point_$type, x: u, y: x };
                                return $ret;
                            })()));
                            ac.c.add(ae);
                            ac.c.add(af);
                            ac.c.add(ag);
                            break;
                        case 1:
                            let ah = new PathFigure();
                            ah._startPoint = { $type: Point_$type, x: t, y: w };
                            ah._segments.add(((() => {
                                let $ret = new LineSegment(1);
                                $ret.c = { $type: Point_$type, x: u, y: w };
                                return $ret;
                            })()));
                            let ai = new PathFigure();
                            ai._startPoint = { $type: Point_$type, x: u, y: y };
                            ai._segments.add(((() => {
                                let $ret = new LineSegment(1);
                                $ret.c = { $type: Point_$type, x: u, y: x };
                                return $ret;
                            })()));
                            let aj = new PathFigure();
                            aj._startPoint = { $type: Point_$type, x: u, y: z };
                            aj._segments.add(((() => {
                                let $ret = new LineSegment(1);
                                $ret.c = { $type: Point_$type, x: v, y: z };
                                return $ret;
                            })()));
                            ac.c.add(ah);
                            ac.c.add(ai);
                            ac.c.add(aj);
                            break;
                    }
                }
                if (ab) {
                    this.xf.ak = p;
                    this.xf.ag = p;
                    this.xf.ah = r;
                    this.xf.al = r;
                    this.xf.f = true;
                }
                else {
                    this.xf.ak = o;
                    this.xf.ag = o;
                    this.xf.ah = q;
                    this.xf.al = q;
                    this.xf.f = false;
                }
                let ak = this.xf.aw(l, s)[0];
                if (h && a.m != null && s >= 0 && s < a.m.count) {
                    ak = truncate(Math.round(a.m._inner[s]));
                }
                this.aab(j, s, l, m, n, b.q, ak);
                if (d == 1) {
                    this.xf.ad(aa, true, false, false, false);
                }
                else {
                    this.xf.ad(aa, false, false, false, false);
                }
                if (c) {
                    aa.an = ac;
                }
            }
            i.b9.count = k;
            i.cf();
        }
        aa7(a, b) {
            let c = this.w6.k8(a.by, a.bx, b);
            c = Math.max(c, this.id * 0.9);
            c = Math.max(c, 3);
            return c;
        }
        aby(a, b) {
            let c = this.aa3;
            let d = this.getEffectiveViewport1(b);
            let e = this.aa7(b, d);
            let f = (e - 1) / 2;
            let g = typeCast(FinancialPriceSeriesView.$, b);
            let h = g.cn();
            let i = g.cm();
            let j = a.f;
            for (let k = 0; k < j.count; ++k) {
                let l = j._inner[k][0] - f;
                let m = j._inner[k][0];
                let n = j._inner[k][0] + f;
                let o = j._inner[k][1];
                let p = j._inner[k][2];
                let q = j._inner[k][3];
                let r = j._inner[k][4];
                if (isNaN_(o) || isNaN_(p) || isNaN_(q) || isNaN_(r)) {
                    continue;
                }
                let s = o < r;
                let t = s ? i : h;
                switch (c) {
                    case 0:
                        if (s) {
                            let u = o;
                            o = r;
                            r = u;
                        }
                        t.d.add(((() => {
                            let $ret = new LineGeometry();
                            $ret.d = { $type: Point_$type, x: m, y: q };
                            $ret.c = { $type: Point_$type, x: m, y: o };
                            return $ret;
                        })()));
                        t.d.add(((() => {
                            let $ret = new RectangleGeometry();
                            $ret.e = new Rect(0, l, r, n - l, o - r);
                            return $ret;
                        })()));
                        t.d.add(((() => {
                            let $ret = new LineGeometry();
                            $ret.d = { $type: Point_$type, x: m, y: r };
                            $ret.c = { $type: Point_$type, x: m, y: p };
                            return $ret;
                        })()));
                        break;
                    case 1:
                        t.d.add(((() => {
                            let $ret = new LineGeometry();
                            $ret.d = { $type: Point_$type, x: l, y: o };
                            $ret.c = { $type: Point_$type, x: m, y: o };
                            return $ret;
                        })()));
                        t.d.add(((() => {
                            let $ret = new LineGeometry();
                            $ret.d = { $type: Point_$type, x: m, y: q };
                            $ret.c = { $type: Point_$type, x: m, y: p };
                            return $ret;
                        })()));
                        t.d.add(((() => {
                            let $ret = new LineGeometry();
                            $ret.d = { $type: Point_$type, x: m, y: r };
                            $ret.c = { $type: Point_$type, x: n, y: r };
                            return $ret;
                        })()));
                        break;
                }
            }
        }
        kx(a, b) {
            if (this.aa2.ca && a == this.aa2.b8.g$j) {
                return null;
            }
            return super.kx(a, b);
        }
        sh() {
            super.sh();
            if (this.index < 0) {
                return;
            }
            this.aa2.cl();
        }
        pz(a) {
            super.pz(a);
            if (this.aa2.ca) {
                this.bc.exportTrendlineData(this, a, this.aa2.b8.g$j);
            }
        }
        vx() {
            return this.acm;
        }
        r3(a, b) {
            super.r3(a, b);
            this.acm = b;
        }
        be(a) {
            if (this.aa3 == 0) {
                return 3;
            }
            else if (this.aa3 == 1) {
                if (this.bd == 1) {
                    return 3;
                }
                return 2;
            }
            return a;
        }
        getDataLegendSeriesContextAt(a, b) {
            let c = { $type: Point_$type, x: a, y: b };
            let d = this.i3(c, false, false);
            let e = this.i1(c, false, false);
            let f = new DataLegendSeriesValueInfo();
            f.a = 4;
            f.l = this.yy(c, false, false);
            f.q = "Close";
            f.r = this.za != null ? this.za : "Close";
            f.s = this.abb != null ? this.abb : "C:";
            f.t = this.abd != null ? this.abd : "";
            let g = new DataLegendSeriesValueInfo();
            g.l = this.yz(c, false, false);
            g.a = 3;
            g.q = "Open";
            g.r = this.zw != null ? this.zw : "Open";
            g.s = this.abp != null ? this.abp : "O:";
            g.t = this.abr != null ? this.abr : "";
            g.k = true;
            let h = new DataLegendSeriesValueInfo();
            h.l = (f.l - g.l) / g.l * 100;
            h.l = round10N(h.l, 1);
            h.a = 9;
            h.q = "Change";
            h.r = "Change";
            h.s = "";
            h.v = "";
            h.x = "+";
            h.w = "%";
            h.y = "%";
            h.t = null;
            h.c = false;
            h.k = true;
            h.e = false;
            h.f = true;
            h.h = false;
            h.g = false;
            h.d = false;
            h.n = 1;
            h.m = 1;
            g.z = h.l >= 0 ? this.u9 : this.aaw;
            f.z = h.l >= 0 ? this.u9 : this.aaw;
            h.z = h.l >= 0 ? this.u9 : this.aaw;
            let i = new DataLegendSeriesValueInfo();
            i.l = e > d ? d : e;
            i.a = 1;
            i.q = "Low";
            i.r = this.zs != null ? this.zs : "Low";
            i.s = this.abk != null ? this.abk : "L:";
            i.t = this.abm != null ? this.abm : "";
            i.k = true;
            let j = new DataLegendSeriesValueInfo();
            j.l = e > d ? e : d;
            j.a = 2;
            j.q = "High";
            j.r = this.zn != null ? this.zn : "High";
            j.s = this.abg != null ? this.abg : "H:";
            j.t = this.abi != null ? this.abi : "";
            j.k = true;
            let k = new DataLegendSeriesValueInfo();
            k.l = (j.l + i.l + f.l) / 3;
            k.l = round10N(k.l, 2);
            k.a = 5;
            k.q = "TypicalPrice";
            k.r = "TypicalPrice";
            k.s = "TP:";
            k.t = "";
            k.k = true;
            let l = new DataLegendSeriesValueInfo();
            l.l = this.y0(c, false, false);
            l.a = 8;
            l.q = "Volume";
            l.r = this.z0 != null ? this.z0 : "Volume";
            l.s = "VOL:";
            l.t = "";
            l.k = true;
            l.n = 0;
            l.m = 0;
            l.e = false;
            l.f = false;
            l.h = false;
            let m = new List$1(DataLegendSeriesValueInfo.$, 0);
            m.add(g);
            m.add(j);
            m.add(i);
            m.add(f);
            m.add(k);
            m.add(h);
            m.add(l);
            let n = new DataLegendSeriesContext();
            n.h = this.mc();
            n.e = m;
            return n;
        }
        ab0() {
            if (this.aa4) {
                this.aa5 = 0;
                for (let a = 0; a < this.x0.count; a++) {
                    let b = 0;
                    b += this.x0.item(a);
                    b += this.x1.item(a);
                    b += this.xz.item(a);
                    this.aa5 += b / 3;
                }
                this.aa6 = this.aa5 / this.x0.count;
                this.aa4 = false;
            }
        }
        aq(a) {
            let b = NaN;
            switch (a) {
                case 2:
                    b = this.x0.maximum;
                    break;
                case 1:
                    b = this.x1.minimum;
                    break;
                case 3:
                    if (this.aa4) {
                        this.ab0();
                    }
                    b = this.aa6;
                    break;
            }
            let c = this.xp;
            if (c.cp) {
                return [NaN, b];
            }
            else {
                return [b, NaN];
            }
        }
        wf(a) {
            let b = NaN;
            switch (a) {
                case 2:
                    b = this.x0.maximum;
                    break;
                case 1:
                    b = this.x1.minimum;
                    break;
                case 3:
                    if (this.aa4) {
                        this.ab0();
                    }
                    b = this.aa6;
                    break;
            }
            if (isNaN_(b)) {
                return { $type: Point_$type, x: NaN, y: NaN };
            }
            let c = this.xp;
            let d = this.getEffectiveViewport1(this.cv);
            let e = new ScalerParams(0, this.cv.by, this.cv.bx, c.ch, d);
            if (c.cp) {
                e.b = this.iy();
            }
            e.c = d;
            if (c.cp) {
                return { $type: Point_$type, x: NaN, y: c.el(b, e) };
            }
            else {
                return { $type: Point_$type, x: c.el(b, e), y: NaN };
            }
        }
        wg(a) {
            let b = this.xp;
            let c = this.getEffectiveViewport1(this.cv);
            let d = new ScalerParams(0, this.cv.by, this.cv.bx, b.ch, c);
            if (b.cp) {
                d.b = this.iy();
            }
            d.c = c;
            if (b.cp) {
                return { $type: Point_$type, x: NaN, y: b.el(a[1], d) };
            }
            else {
                return { $type: Point_$type, x: b.el(a[0], d), y: NaN };
            }
        }
        ak(a, b) {
            let c = new List$1(ChartSelection.$, 0);
            this.p4(a, c, b);
            return c.toArray();
        }
        p4(a, b, c) {
            let d = this.wr(a);
            let e = this.xp;
            let f = this.w6;
            let g = this.wj(this.cv);
            let h, i;
            let j = this.abv(d, f, true, g, h, i);
            h = j.p4;
            i = j.p5;
            if (this.aa1 == 0) {
                this.abx(b, h, i, c);
            }
            else {
                let k, l;
                let m = this.abu(d, e, true, g, k, l);
                k = m.p4;
                l = m.p5;
                this.abw(1, b, h, i, k, l, c);
            }
        }
        abv(a, b, c, d, e, f) {
            let g = new ScalerParams(0, a, this.db.wk, this.w6.ch, this.getEffectiveViewport());
            let h = (this.w6.eo(d.left, g));
            let i = (this.w6.eo(d.right, g));
            if (this.w6.ch) {
                let j = h;
                h = i;
                i = j;
            }
            if (this.w6.cn) {
                let k = this.w6;
                h = k.i$f(h);
                i = k.i$f(i);
            }
            else {
                h = Math.floor(h);
                i = Math.ceil(i);
            }
            e = truncate(Math.max(0, Math.min(this.x1.count - 1, h)));
            f = truncate(Math.max(0, Math.min(this.x1.count - 1, i)));
            return {
                p4: e,
                p5: f
            };
        }
        abu(a, b, c, d, e, f) {
            let g = new ScalerParams(0, a, this.db.wk, b.ch, this.getEffectiveViewport());
            let h = c ? (b.ch ? d.top : d.bottom) : (b.ch ? d.left : d.right);
            let i = c ? (b.ch ? d.bottom : d.top) : (b.ch ? d.right : d.left);
            e = b.eo(h, g);
            f = b.eo(i, g);
            return {
                p4: e,
                p5: f
            };
        }
        abt(a, b, c) {
            if (c == 2 || c == 1) {
                a.add(((() => {
                    let $ret = new ChartSelection();
                    $ret.item = this.dn.item(b);
                    return $ret;
                })()));
            }
            else {
                a.add(((() => {
                    let $ret = new ChartSelection();
                    $ret.item = this.dn.item(b);
                    $ret.series = this;
                    return $ret;
                })()));
            }
        }
        abx(a, b, c, d) {
            if (b == -1 || c == -1) {
                return;
            }
            if (d == 7 || d == 6) {
                a.add(((() => {
                    let $ret = new ChartSelection();
                    $ret.series = this;
                    return $ret;
                })()));
                return;
            }
            for (let e = b; e <= c; e++) {
                this.abt(a, e, d);
            }
        }
        abw(a, b, c, d, e, f, g) {
            if (c == -1 || d == -1) {
                return;
            }
            for (let h = c; h <= d; h++) {
                let i = Math.min(this.x2.item(h), this.x1.item(h));
                let j = Math.max(this.xz.item(h), this.x0.item(h));
                let k = Math.min(i, j);
                let l = Math.max(i, j);
                if (k < f && e < l) {
                    if (g == 7 || g == 6) {
                        b.add(((() => {
                            let $ret = new ChartSelection();
                            $ret.series = this;
                            return $ret;
                        })()));
                        return;
                    }
                    this.abt(b, h, g);
                }
            }
        }
    }
    FinancialPriceSeries.$t = /*@__PURE__*/ markType(FinancialPriceSeries, 'FinancialPriceSeries', FinancialSeries.$, [ITrendLineSeries_$type]);
    FinancialPriceSeries.ab2 = /*@__PURE__*/ DependencyProperty.i("ActualTrendLineBrush", Brush.$, FinancialPriceSeries.$, /*@__PURE__*/ new PropertyMetadata(2, null, (a, b) => a.raisePropertyChanged("ActualTrendLineBrush", b.oldValue, b.newValue)));
    FinancialPriceSeries.$$p = /*@__PURE__*/ markDep(DependencyProperty, PropertyMetadata, FinancialPriceSeries, 'raisePropertyChanged', ['CategoryCollisionMode:aa1:ab3', [CategoryCollisionMode_$type, /*@__PURE__*/ enumGetBox(CategoryCollisionMode_$type, 0)], 'CloseMemberAsLegendLabel:abb:ab4', [2, null], 'CloseMemberAsLegendUnit:abd:ab5', [2, null], 'DisplayType:aa3:ab6', [PriceDisplayType_$type, /*@__PURE__*/ enumGetBox(PriceDisplayType_$type, 0)], 'HighMemberAsLegendLabel:abg:ab7', [2, null], 'HighMemberAsLegendUnit:abi:ab8', [2, null], 'LowMemberAsLegendLabel:abk:ab9', [2, null], 'LowMemberAsLegendUnit:abm:aca', [2, null], 'NegativeOutline:acm:acb', [Brush.$, null], 'OpenMemberAsLegendLabel:abp:acc', [2, null], 'OpenMemberAsLegendUnit:abr:acd', [2, null], 'TrendLineType::acj', [TrendLineType_$type, /*@__PURE__*/ enumGetBox(TrendLineType_$type, 0)], 'TrendLineThickness::aci', [1, 1.5], 'TrendLinePeriod::ach', [1, 7], 'TrendLineBrush::ace', [Brush.$, null], 'TrendLineZIndex:aa9:ack', [1, 1001], 'TrendLineDashArray:acn:acf', [DoubleCollection.$], 'TrendLineDashCap:aco:acg', [PenLineCap_$type, /*@__PURE__*/ enumGetBox(PenLineCap_$type, 0)]]);
    return FinancialPriceSeries;
})();
/**
 * @hidden
 */
export let FinancialPriceSeriesView = /*@__PURE__*/ (() => {
    class FinancialPriceSeriesView extends FinancialSeriesView {
        constructor(a) {
            super(a);
            this.b6 = null;
            this.b9 = null;
            this.cc = null;
            this.cq = ((() => {
                let $ret = new Path();
                $ret.an = new GeometryGroup();
                return $ret;
            })());
            this.cp = ((() => {
                let $ret = new Path();
                $ret.an = new GeometryGroup();
                return $ret;
            })());
            this.b7 = null;
            this.co = new Path();
            this.cb = false;
            this.b6 = a;
            this.cc = new List$1(Path.$, 0);
            this.b9 = ((() => {
                let $ret = new Pool$1(Path.$);
                $ret.create = runOn(this, this.cr);
                $ret.activate = runOn(this, this.ch);
                $ret.disactivate = runOn(this, this.cj);
                $ret.destroy = runOn(this, this.ci);
                return $ret;
            })());
        }
        cr() {
            let a = new Path();
            this.cc.add(a);
            a._visibility = 1;
            return a;
        }
        ch(a) {
            a._visibility = 0;
        }
        cj(a) {
            a._visibility = 1;
        }
        ci(a) {
            this.cc.remove(a);
        }
        b1() {
            return new FinancialPriceBucketCalculator(this);
        }
        au() {
            super.au();
            if (!this.q) {
                this.b6.aa3 = Defaults.g;
                this.b6.aaw = Defaults.ah;
                this.b6.acm = Defaults.ai;
                this.b6.jp = Defaults.l;
                this.b6.vv = this.b6.vd;
            }
        }
        get b8() {
            if (this.b7 == null) {
                this.b7 = CategoryTrendLineManagerFactory.a(this.b7, this.e.a0(), this.e.sv, this.e, this.e.dr);
            }
            return this.b7;
        }
        set b8(a) {
            this.b7 = a;
        }
        get ca() {
            return this.b7 != null;
        }
        ck() {
            if (this.b6.aa3 == 1) {
                this.cq._stroke = this.e.u9;
            }
            else {
                this.cq._stroke = this.e.vd;
            }
            if (this.b6.aa3 == 1) {
                this.cp._stroke = this.b2.aaw;
            }
            else {
                this.cp._stroke = this.b6.acm;
            }
        }
        ce() {
            this.as();
            this.b9.count = 0;
            this.cd();
        }
        cd() {
            let a = typeCast(GeometryGroup.$, this.cq.an);
            let b = typeCast(GeometryGroup.$, this.cp.an);
            Extensions.d(a);
            Extensions.d(b);
        }
        cn() {
            this.as();
            return typeCast(GeometryGroup.$, this.cq.an);
        }
        cm() {
            this.as();
            return typeCast(GeometryGroup.$, this.cp.an);
        }
        cl() {
            this.b6.acl = null;
            if (this.b6.trendLineBrush != null) {
                this.b6.acl = this.b6.trendLineBrush;
            }
            else {
                this.b6.acl = this.b6.u9;
            }
        }
        bd() {
            super.bd();
            this.cq.ad = this.e.ie;
            this.cq.ai = this.e.v2;
            this.cq.aj = this.e.v3;
            if (this.b6.aa3 == 1) {
                this.cq._stroke = this.e.u9;
            }
            else {
                this.cq._stroke = this.e.vd;
                this.cq._fill = this.e.u9;
            }
            this.cp.ad = this.e.ie;
            this.cp.ai = this.e.v2;
            this.cp.aj = this.e.v3;
            if (this.b6.aa3 == 1) {
                this.cp._stroke = this.b2.aaw;
            }
            else {
                this.cp._stroke = this.b6.acm;
                this.cp._fill = this.b2.aaw;
            }
        }
        be() {
            super.be();
            let a = this.br();
            this.cq.ad = this.e.ie + 3;
            if (this.b6.aa3 == 1) {
                this.cq._stroke = a;
            }
            else {
                this.cq._stroke = a;
                this.cq._fill = a;
            }
            this.cp.ad = this.e.ie + 3;
            if (this.b6.aa3 == 1) {
                this.cp._stroke = a;
            }
            else {
                this.cp._stroke = a;
                this.cp._fill = a;
            }
        }
        ac(a) {
            return this.cc._inner[a];
        }
        ab(a) {
            let b = this.cc._inner[a];
            this.co._visibility = b._visibility;
            this.co.an = b.an;
            let c = this.bs(a);
            this.co._fill = c;
            this.co._stroke = c;
            this.co.ad = this.e.ie + 3;
            return this.co;
        }
        a8(a, b) {
            super.a8(a, b);
            if (a.d) {
                if (this.cb) {
                    for (let c = 0; c < this.cc.count; c++) {
                        let d = this.aa(c, b);
                        if (d._visibility == 0) {
                            a.t(d);
                        }
                    }
                }
                else {
                    a.t(this.cq);
                    a.t(this.cp);
                }
            }
        }
        a7(a, b) {
            if (a.d) {
                if (this.b6.trendLineType != 0 && !b) {
                    let c = this.b8.g$j;
                    c.ad = this.b6.trendLineThickness;
                    c._stroke = this.b6.acl;
                    c.ai = this.b6.acn;
                    c.aj = this.b6.aco;
                    a.v(c);
                }
            }
            super.a7(a, b);
        }
        an(a) {
            super.an(a);
            if (this.b6.ye()) {
                for (let b = 0; b < this.cc.count; b++) {
                    let c = this.cc._inner[b];
                    if (c._fill == this.b6.aaw) {
                        this.e.bc.exportPathData(a, c, "negativePathShape" + b, ["Negative"]);
                    }
                    else {
                        this.e.bc.exportPathData(a, c, "positivePathShape" + b, ["Positive", "Main"]);
                    }
                }
            }
            else {
                this.e.bc.exportPathData(a, this.cq, "positivePathShape", ["Positive", "Main"]);
                this.e.bc.exportPathData(a, this.cp, "negativePathShape", ["Negative"]);
            }
        }
        cf() {
            this.as();
        }
        cg() {
            if (this.ca) {
                this.b7 = CategoryTrendLineManagerFactory.a(this.b7, this.e.a0(), this.e.sv, this.e, this.e.dr);
            }
        }
    }
    FinancialPriceSeriesView.$t = /*@__PURE__*/ markType(FinancialPriceSeriesView, 'FinancialPriceSeriesView', FinancialSeriesView.$);
    return FinancialPriceSeriesView;
})();
