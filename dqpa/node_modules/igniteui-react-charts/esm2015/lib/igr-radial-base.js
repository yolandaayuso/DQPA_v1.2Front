import { delegateCombine, delegateRemove } from "igniteui-react-core";
import { RadialLabelMode_$type } from "igniteui-react-core";
import { CategoryCollisionMode_$type } from "./CategoryCollisionMode";
import { CategoryTransitionInMode_$type } from "./CategoryTransitionInMode";
import { IgrCategoryAngleAxis } from "./igr-category-angle-axis";
import { IgrNumericRadiusAxis } from "./igr-numeric-radius-axis";
import { IgrAssigningRadialStyleEventArgs } from "./igr-assigning-radial-style-event-args";
import { IgrAssigningRadialMarkerStyleEventArgs } from "./igr-assigning-radial-marker-style-event-args";
import { IgrMarkerSeries } from "./igr-marker-series";
import { ensureEnum, ensureBool, arrayFindByName, toPoint } from "igniteui-react-core";
/**
 * Represents the base class for all IgxDataChartComponent radial series
*/
export class IgrRadialBase extends IgrMarkerSeries {
    /**
                                 * @hidden
                                 */
    get i() {
        return this._implementation;
    }
    constructor(props) {
        super(props);
        this._angleAxisName = null;
        this._valueAxisName = null;
        this._assigningRadialStyle = null;
        this._assigningRadialStyle_wrapped = null;
        this._assigningRadialMarkerStyle = null;
        this._assigningRadialMarkerStyle_wrapped = null;
    }
    /**
     * Gets or sets the format string to use for the auto callout labels for the others category.
    */
    get autoCalloutLabelPrecision() {
        return this.i.z4;
    }
    set autoCalloutLabelPrecision(v) {
        this.i.z4 = +v;
    }
    /**
     * Gets or sets the format string to use for the auto callout labels for the others category.
    */
    get autoCalloutPercentagePrecision() {
        return this.i.z5;
    }
    set autoCalloutPercentagePrecision(v) {
        this.i.z5 = +v;
    }
    /**
     * Gets or sets the labelling mode to use for the auto callouts in preference to their mode.
    */
    get autoCalloutLabelValueSeparator() {
        return this.i.aad;
    }
    set autoCalloutLabelValueSeparator(v) {
        this.i.aad = v;
    }
    /**
     * Gets or sets the labelling mode to use for the auto callouts in preference to their mode.
    */
    get legendRadialLabelMode() {
        return this.i.zf;
    }
    set legendRadialLabelMode(v) {
        this.i.zf = ensureEnum(RadialLabelMode_$type, v);
    }
    /**
     * Gets or sets the category collision mode selection behavior to use for the series.
    */
    get categoryCollisionMode() {
        return this.i.y0;
    }
    set categoryCollisionMode(v) {
        this.i.y0 = ensureEnum(CategoryCollisionMode_$type, v);
    }
    /**
     * Gets or sets the labelling mode to use for the auto callouts in preference to their mode.
    */
    get autoCalloutRadialLabelMode() {
        return this.i.ze;
    }
    set autoCalloutRadialLabelMode(v) {
        this.i.ze = ensureEnum(RadialLabelMode_$type, v);
    }
    /**
     * Gets or sets the format string to use for the auto callout labels for the others category.
    */
    get autoCalloutOthersLabelFormat() {
        return this.i.aaf;
    }
    set autoCalloutOthersLabelFormat(v) {
        this.i.aaf = v;
    }
    /**
     * Gets or sets the format specifiers to use with the auto callouts for the others category.
    */
    get autoCalloutOthersLabelFormatSpecifiers() {
        return this.i.ym;
    }
    set autoCalloutOthersLabelFormatSpecifiers(v) {
        if (v && !Array.isArray(v) && typeof (v) == "string") {
            const re = /\s*(?:,|\s|$)\s*/gm;
            v = v.split(re);
        }
        this.i.ym = v;
    }
    /**
     * Gets or sets the format string to use for the auto callout labels for the others category.
    */
    get proportionalRadialLabelFormat() {
        return this.i.aa2;
    }
    set proportionalRadialLabelFormat(v) {
        this.i.aa2 = v;
    }
    /**
     * Gets or sets the format specifiers to use with the auto callouts for the others category.
    */
    get proportionalRadialLabelFormatSpecifiers() {
        return this.i.yr;
    }
    set proportionalRadialLabelFormatSpecifiers(v) {
        if (v && !Array.isArray(v) && typeof (v) == "string") {
            const re = /\s*(?:,|\s|$)\s*/gm;
            v = v.split(re);
        }
        this.i.yr = v;
    }
    /**
     * Gets or sets the format string to use for the auto callout labels for the others category.
    */
    get legendProportionalRadialLabelFormat() {
        return this.i.aas;
    }
    set legendProportionalRadialLabelFormat(v) {
        this.i.aas = v;
    }
    /**
     * Gets or sets the format specifiers to use with the auto callouts for the others category.
    */
    get legendProportionalRadialLabelFormatSpecifiers() {
        return this.i.yo;
    }
    set legendProportionalRadialLabelFormatSpecifiers(v) {
        if (v && !Array.isArray(v) && typeof (v) == "string") {
            const re = /\s*(?:,|\s|$)\s*/gm;
            v = v.split(re);
        }
        this.i.yo = v;
    }
    /**
     * Gets or sets the format string to use for the auto callout labels for the others category.
    */
    get othersProportionalRadialLabelFormat() {
        return this.i.aaz;
    }
    set othersProportionalRadialLabelFormat(v) {
        this.i.aaz = v;
    }
    /**
     * Gets or sets the format specifiers to use with the auto callouts for the others category.
    */
    get othersProportionalRadialLabelFormatSpecifiers() {
        return this.i.yq;
    }
    set othersProportionalRadialLabelFormatSpecifiers(v) {
        if (v && !Array.isArray(v) && typeof (v) == "string") {
            const re = /\s*(?:,|\s|$)\s*/gm;
            v = v.split(re);
        }
        this.i.yq = v;
    }
    /**
     * Gets or sets the format string to use for the auto callout labels for the others category.
    */
    get othersLegendProportionalRadialLabelFormat() {
        return this.i.aaw;
    }
    set othersLegendProportionalRadialLabelFormat(v) {
        this.i.aaw = v;
    }
    /**
     * Gets or sets the format specifiers to use with the auto callouts for the others category.
    */
    get othersLegendProportionalRadialLabelFormatSpecifiers() {
        return this.i.yp;
    }
    set othersLegendProportionalRadialLabelFormatSpecifiers(v) {
        if (v && !Array.isArray(v) && typeof (v) == "string") {
            const re = /\s*(?:,|\s|$)\s*/gm;
            v = v.split(re);
        }
        this.i.yp = v;
    }
    /**
     * Checks if this series is a radial series
    */
    get isRadial() {
        return this.i.ft;
    }
    /**
     * Gets or sets whether this Radial series should allow custom style overrides of its individual visuals.
    */
    get isCustomRadialStyleAllowed() {
        return this.i.zs;
    }
    set isCustomRadialStyleAllowed(v) {
        this.i.zs = ensureBool(v);
    }
    /**
     * Gets or sets whether this Radial series should allow custom style overrides of its individual marker visuals.
    */
    get isCustomRadialMarkerStyleAllowed() {
        return this.i.zr;
    }
    set isCustomRadialMarkerStyleAllowed(v) {
        this.i.zr = ensureBool(v);
    }
    /**
     * Gets or sets the method by which to animate the data into the chart when the chart data source is swapped.
     * Note: Transitions are not currently supported for stacked series.
    */
    get transitionInMode() {
        return this.i.y3;
    }
    set transitionInMode(v) {
        this.i.y3 = ensureEnum(CategoryTransitionInMode_$type, v);
    }
    /**
     * Gets or sets whether the series should transition into the plot area when a new data source is assigned.
     * Note: Transitions are not currently supported for stacked series.
    */
    get isTransitionInEnabled() {
        return this.i.zt;
    }
    set isTransitionInEnabled(v) {
        this.i.zt = ensureBool(v);
    }
    /**
     * Gets the effective angle axis for the current series object.
    */
    get angleAxis() {
        const r = this.i.yz;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = IgrCategoryAngleAxis._createFromInternal(r);
            if (e) {
                e._implementation = r;
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set angleAxis(v) {
        if (v != null && this._stylingContainer && v._styling)
            v._styling(this._stylingContainer, this, this);
        v == null ? this.i.yz = null : this.i.yz = v.i;
    }
    /**
    * Gets or sets the name to use to resolve angleAxis from markup.
    */
    get angleAxisName() {
        return this._angleAxisName;
    }
    set angleAxisName(v) {
        this._angleAxisName = v;
    }
    /**
     * Gets the effective value axis for the current series object.
    */
    get valueAxis() {
        const r = this.i.y5;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = IgrNumericRadiusAxis._createFromInternal(r);
            if (e) {
                e._implementation = r;
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set valueAxis(v) {
        if (v != null && this._stylingContainer && v._styling)
            v._styling(this._stylingContainer, this, this);
        v == null ? this.i.y5 = null : this.i.y5 = v.i;
    }
    /**
    * Gets or sets the name to use to resolve valueAxis from markup.
    */
    get valueAxisName() {
        return this._valueAxisName;
    }
    set valueAxisName(v) {
        this._valueAxisName = v;
    }
    /**
     * Gets or sets whether to clip the series to the bounds.
     * Setting this property to true will decrease chart performance.
    */
    get clipSeriesToBounds() {
        return this.i.zq;
    }
    set clipSeriesToBounds(v) {
        this.i.zq = ensureBool(v);
    }
    bindAxes(axes) {
        super.bindAxes(axes);
        for (let i = 0; i < axes.length; i++) {
            if (this.angleAxisName && this.angleAxisName.length > 0 &&
                axes[i].name == this.angleAxisName) {
                this.angleAxis = axes[i];
            }
        }
        for (let i = 0; i < axes.length; i++) {
            if (this.valueAxisName && this.valueAxisName.length > 0 &&
                axes[i].name == this.valueAxisName) {
                this.valueAxis = axes[i];
            }
        }
    }
    findByName(name) {
        var baseResult = super.findByName(name);
        if (baseResult) {
            return baseResult;
        }
        if (this.autoCalloutOthersLabelFormatSpecifiers != null && arrayFindByName(this.autoCalloutOthersLabelFormatSpecifiers, name)) {
            return arrayFindByName(this.autoCalloutOthersLabelFormatSpecifiers, name);
        }
        if (this.proportionalRadialLabelFormatSpecifiers != null && arrayFindByName(this.proportionalRadialLabelFormatSpecifiers, name)) {
            return arrayFindByName(this.proportionalRadialLabelFormatSpecifiers, name);
        }
        if (this.legendProportionalRadialLabelFormatSpecifiers != null && arrayFindByName(this.legendProportionalRadialLabelFormatSpecifiers, name)) {
            return arrayFindByName(this.legendProportionalRadialLabelFormatSpecifiers, name);
        }
        if (this.othersProportionalRadialLabelFormatSpecifiers != null && arrayFindByName(this.othersProportionalRadialLabelFormatSpecifiers, name)) {
            return arrayFindByName(this.othersProportionalRadialLabelFormatSpecifiers, name);
        }
        if (this.othersLegendProportionalRadialLabelFormatSpecifiers != null && arrayFindByName(this.othersLegendProportionalRadialLabelFormatSpecifiers, name)) {
            return arrayFindByName(this.othersLegendProportionalRadialLabelFormatSpecifiers, name);
        }
        if (this.angleAxis && this.angleAxis.name && this.angleAxis.name == name) {
            return this.angleAxis;
        }
        if (this.valueAxis && this.valueAxis.name && this.valueAxis.name == name) {
            return this.valueAxis;
        }
        return null;
    }
    _styling(container, component, parent) {
        super._styling(container, component, parent);
        this._inStyling = true;
        if (this.angleAxis && this.angleAxis._styling) {
            this.angleAxis._styling(container, component, this);
        }
        if (this.valueAxis && this.valueAxis._styling) {
            this.valueAxis._styling(container, component, this);
        }
        this._inStyling = false;
    }
    /**
     * Determine if object can be used as ValueAxis
    
    * @param axis  * The object to check
    */
    canUseAsValueAxis(axis) {
        let iv = this.i.zp(axis);
        return (iv);
    }
    /**
     * Determine if object can be used as AngleAxis
    
    * @param axis  * The object to check
    */
    canUseAsAngleAxis(axis) {
        let iv = this.i.zo(axis);
        return (iv);
    }
    /**
     * Gets the item that is the best match for the specified world coordinates.
    
    * @param world  * The world coordinates to use.
    */
    getItem(world) {
        let iv = this.i.kn(toPoint(world));
        return (iv);
    }
    /**
     * Gets the angle to the provided world position from the center of the radial series.
    
    * @param world  * The world position to get the angle for
    */
    getAngleFromWorld(world) {
        let iv = this.i.zz(toPoint(world));
        return (iv);
    }
    /**
     * Gets the precise item index, if possible, based on the closeness to the previous or next whole integer. If the series cannot provide this information, GetExactItemIndex will return the same integer value as GetItemIndex.
    
    * @param world  * The world position for which to return the index.
    */
    getExactItemIndex(world) {
        let iv = this.i.ir(toPoint(world));
        return (iv);
    }
    /**
     * Get the index of the item near the provided world coordinates.
    
    * @param world  * The world coordinates for which to getch the item index.
    */
    getItemIndex(world) {
        let iv = this.i.j3(toPoint(world));
        return (iv);
    }
    /**
     * Scrolls the specified item into the view.
    
    * @param item  * The item to scroll into view.
    */
    scrollIntoView(item) {
        let iv = this.i.gd(item);
        return (iv);
    }
    /**
     * Returns the offset value for this series if grouped on a category axis.
    
    */
    getOffsetValue() {
        let iv = this.i.getOffsetValue();
        return (iv);
    }
    /**
     * Returns the width of the category grouping this series is in.
    
    */
    getCategoryWidth() {
        let iv = this.i.getCategoryWidth();
        return (iv);
    }
    /**
     * Event raised when Assigning Category Style
    */
    get assigningRadialStyle() {
        return this._assigningRadialStyle;
    }
    set assigningRadialStyle(ev) {
        if (this._assigningRadialStyle_wrapped !== null) {
            this.i.assigningRadialStyle = delegateRemove(this.i.assigningRadialStyle, this._assigningRadialStyle_wrapped);
            this._assigningRadialStyle_wrapped = null;
            this._assigningRadialStyle = null;
        }
        this._assigningRadialStyle = ev;
        this._assigningRadialStyle_wrapped = (o, e) => {
            let outerArgs = new IgrAssigningRadialStyleEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeAssigningRadialStyle) {
                this.beforeAssigningRadialStyle(this, outerArgs);
            }
            if (this._assigningRadialStyle) {
                this._assigningRadialStyle(this, outerArgs);
            }
        };
        this.i.assigningRadialStyle = delegateCombine(this.i.assigningRadialStyle, this._assigningRadialStyle_wrapped);
        ;
    }
    /**
     * Event raised when Assigning Radial Marker Style
    */
    get assigningRadialMarkerStyle() {
        return this._assigningRadialMarkerStyle;
    }
    set assigningRadialMarkerStyle(ev) {
        if (this._assigningRadialMarkerStyle_wrapped !== null) {
            this.i.assigningRadialMarkerStyle = delegateRemove(this.i.assigningRadialMarkerStyle, this._assigningRadialMarkerStyle_wrapped);
            this._assigningRadialMarkerStyle_wrapped = null;
            this._assigningRadialMarkerStyle = null;
        }
        this._assigningRadialMarkerStyle = ev;
        this._assigningRadialMarkerStyle_wrapped = (o, e) => {
            let outerArgs = new IgrAssigningRadialMarkerStyleEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeAssigningRadialMarkerStyle) {
                this.beforeAssigningRadialMarkerStyle(this, outerArgs);
            }
            if (this._assigningRadialMarkerStyle) {
                this._assigningRadialMarkerStyle(this, outerArgs);
            }
        };
        this.i.assigningRadialMarkerStyle = delegateCombine(this.i.assigningRadialMarkerStyle, this._assigningRadialMarkerStyle_wrapped);
        ;
    }
}
