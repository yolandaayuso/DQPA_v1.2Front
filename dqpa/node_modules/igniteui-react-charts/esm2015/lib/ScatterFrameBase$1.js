/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { Frame } from "./Frame";
import { DictInterpolator$3 } from "./DictInterpolator$3";
import { Base, Point_$type, Array_$type, runOn, fromEnum, markType } from "igniteui-react-core";
import { OwnedPoint } from "./OwnedPoint";
import { Dictionary$2 } from "igniteui-react-core";
import { List$1 } from "igniteui-react-core";
import { isNaN_ } from "igniteui-react-core";
/**
 * @hidden
 */
export let ScatterFrameBase$1 = /*@__PURE__*/ (() => {
    class ScatterFrameBase$1 extends Frame {
        constructor($t) {
            super();
            this.$t = null;
            this.f = null;
            this.o = null;
            this.j = null;
            this.g = null;
            this.m = null;
            this.n = null;
            this.h = null;
            this.l = null;
            this.i = null;
            this.k = null;
            this.$t = $t;
            this.$type = this.$type.specialize(this.$t);
            this.m = new List$1(Point_$type, 0);
            this.g = new Dictionary$2(Base.$, OwnedPoint.$, 0);
            this.j = new Dictionary$2(Base.$, OwnedPoint.$, 0);
            this.n = new List$1(Point_$type, 0);
            this.h = new Dictionary$2(Base.$, OwnedPoint.$, 0);
            this.l = new Dictionary$2(Base.$, OwnedPoint.$, 0);
            this.i = new Dictionary$2(Base.$, Array_$type, 0);
            this.k = new Dictionary$2(Base.$, Array_$type, 0);
            this.o = (a, b, c) => a;
            this.f = new DictInterpolator$3(Base.$, OwnedPoint.$, ScatterFrameBase$1.$.specialize(this.$t), runOn(this, this.s), (a) => a.a, (a) => !isNaN_(a.c.x) && !isNaN_(a.c.y), () => new OwnedPoint());
        }
        c(a, b, c) {
            let d = b;
            let e = c;
            if (d == null || e == null) {
                return;
            }
            this.f.f(this.g, a, d.g, e.g, d, e);
            Frame.a(this.m, a, d.m, e.m);
            this.f.f(this.j, a, d.j, e.j, d, e);
            this.f.f(this.h, a, d.h, e.h, d, e);
            this.f.f(this.l, a, d.l, e.l, d, e);
            this.p(this.j, a, d, e);
            Frame.a(this.n, a, d.n, e.n);
            this.i = e.i;
            this.k = e.k;
            this.r(a, d, e);
        }
        r(a, b, c) {
        }
        p(a, b, c, d) {
            for (let e of fromEnum(c.g.values)) {
                if (a.containsKey(e.a)) {
                    continue;
                }
                let f;
                if (!((() => { let g = d.g.tryGetValue(e.a, f); f = g.p1; return g.ret; })()) || (f.b.x == e.b.x && f.b.y == e.b.y)) {
                    continue;
                }
                let g = new OwnedPoint();
                this.s(g, b, e, f, c, d);
                if (isNaN_(g.c.x) || isNaN_(g.c.y)) {
                    continue;
                }
                a.addItem(g.a, g);
            }
        }
        q(a, b, c, d) {
            if (c != null) {
                a.b = { $type: Point_$type, x: c.b.x, y: c.b.y };
            }
            else if (d != null) {
                a.b = { $type: Point_$type, x: d.b.x, y: d.b.y };
            }
        }
        s(a, b, c, d, e, f) {
            let g;
            let h;
            if (c == null) {
                if (d != null) {
                    let i;
                    if (((() => { let j = e.g.tryGetValue(d.a, i); i = j.p1; return j.ret; })())) {
                        g = i;
                    }
                    else {
                        g = this.o(d, e, f);
                    }
                }
                else {
                    a.c = { $type: Point_$type, x: NaN, y: NaN };
                    return;
                }
            }
            else {
                g = c;
                if (a.a == null) {
                    a.a = c.a;
                }
            }
            if (d == null) {
                if (c != null) {
                    let j;
                    if (((() => { let k = f.g.tryGetValue(c.a, j); j = k.p1; return k.ret; })())) {
                        h = j;
                    }
                    else {
                        a.c = { $type: Point_$type, x: NaN, y: NaN };
                        return;
                    }
                }
                else {
                    a.c = { $type: Point_$type, x: NaN, y: NaN };
                    return;
                }
            }
            else {
                h = d;
                if (a.a == null) {
                    a.a = d.a;
                }
            }
            this.q(a, b, g, h);
            if (isNaN_(g.c.x) || isNaN_(g.c.y)) {
                g = h;
            }
            this.t(a, b, g, h);
        }
        t(a, b, c, d) {
            let e = 1 - b;
            a.c = { $type: Point_$type, x: c.c.x * e + d.c.x * b, y: c.c.y * e + d.c.y * b };
        }
    }
    ScatterFrameBase$1.$t = /*@__PURE__*/ markType(ScatterFrameBase$1, 'ScatterFrameBase$1', Frame.$);
    return ScatterFrameBase$1;
})();
