/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { Base, BaseError, fromEnum, typeCast, runOn, delegateCombine, delegateRemove, markType, TypeRegistrar } from "igniteui-react-core";
import { IDataChartToolbarProvider_$type } from "./IDataChartToolbarProvider";
import { ToolActionIconButtonInfo } from "igniteui-react-core";
import { ToolActionIconMenuInfo } from "igniteui-react-core";
import { ToolActionGroupHeaderInfo } from "igniteui-react-core";
import { ToolActionSeparatorInfo } from "igniteui-react-core";
import { ToolActionLabelInfo } from "igniteui-react-core";
import { ToolActionCheckboxInfo } from "igniteui-react-core";
import { DeviceUtils } from "igniteui-react-core";
import { ToolActionRadioInfo } from "igniteui-react-core";
import { XamDataChart } from "./XamDataChart";
import { Axis } from "./Axis";
import { BrushUtilCore } from "igniteui-react-core";
import { ToolCommandArgument } from "igniteui-react-core";
import { AutomaticSeriesRequest } from "./AutomaticSeriesRequest";
import { AxisStrokeSettings } from "./AxisStrokeSettings";
import { FastIterationDictionary$2 } from "igniteui-react-core";
import { CaptureImageSettings } from "igniteui-react-core";
import { BrushUtil } from "igniteui-react-core";
import { isNaN_ } from "igniteui-react-core";
/**
 * @hidden
 */
export let DataChartToolbarProvider = /*@__PURE__*/ (() => {
    class DataChartToolbarProvider extends Base {
        constructor() {
            super(...arguments);
            this._container = null;
            this.k = null;
            this.i = null;
            this.g = null;
            this.q = null;
            this.r = new FastIterationDictionary$2(Axis.$, AxisStrokeSettings.$, 0);
        }
        get container() {
            return this._container;
        }
        set container(a) {
            this._container = a;
        }
        get l() {
            if (TypeRegistrar.isRegistered("HorizontalAnchoredCategorySeriesProxy")) {
                return TypeRegistrar.create("HorizontalAnchoredCategorySeriesProxy");
            }
            else {
                throw new BaseError(1, "category series module is not loaded, but is required.");
            }
        }
        get v() {
            return (TypeRegistrar.isRegistered("HorizontalAnchoredCategorySeriesProxy"));
        }
        get j() {
            if (TypeRegistrar.isRegistered("FinancialPriceSeriesProxy")) {
                return TypeRegistrar.create("FinancialPriceSeriesProxy");
            }
            else {
                throw new BaseError(1, "category series module is not loaded, but is required.");
            }
        }
        get u() {
            return (TypeRegistrar.isRegistered("HorizontalAnchoredCategorySeriesProxy"));
        }
        get h() {
            if (this.g == null) {
                if (TypeRegistrar.isRegistered("AnnotationLayerProxy")) {
                    this.g = TypeRegistrar.create("AnnotationLayerProxy");
                    this.g.container = this.container;
                }
                else {
                    throw new BaseError(1, "annotation layer module is not loaded, but is required.");
                }
            }
            return this.g;
        }
        get t() {
            return (TypeRegistrar.isRegistered("AnnotationLayerProxy"));
        }
        getDesiredToolbarActions(a) {
            let b = new ToolActionIconButtonInfo();
            b.name = "ZoomReset";
            b.iconName = "reset";
            b.iconCollectionName = "ChartToolbarIcons";
            b.iconWidth = 24;
            b.iconHeight = 24;
            b.title = "Reset";
            let c = new ToolActionIconMenuInfo();
            c.name = "ZoomMenu";
            c.iconName = "zoomin";
            c.iconCollectionName = "ChartToolbarIcons";
            c.iconWidth = 24;
            c.iconHeight = 25;
            c.actions = this.e();
            let d = new ToolActionGroupHeaderInfo();
            d.name = "AnalyzeHeader";
            d.title = "Analyze";
            let e = new ToolActionSeparatorInfo();
            e.name = "AnalyzeHeaderSeparator";
            e.isGroupHeaderSeparator = true;
            let f = new ToolActionLabelInfo();
            f.name = "LinesMenu";
            f.title = "Lines";
            f.iconName = "analyze-lines";
            f.iconCollectionName = "ChartToolbarIcons";
            f.iconWidth = 24;
            f.iconHeight = 25;
            f.actions = this.a();
            let g = new ToolActionSeparatorInfo();
            g.name = "LinesMenuSeparator";
            let h = new ToolActionLabelInfo();
            h.name = "TrendsMenu";
            h.title = "Trends";
            h.iconName = "analyze-trends";
            h.iconCollectionName = "ChartToolbarIcons";
            h.iconWidth = 24;
            h.iconHeight = 25;
            h.actions = this.c();
            let i = new ToolActionGroupHeaderInfo();
            i.name = "HelpersHeader";
            i.title = "Helpers";
            let j = new ToolActionSeparatorInfo();
            j.name = "HelpersHeaderSeparator";
            j.isGroupHeaderSeparator = true;
            let k = new ToolActionCheckboxInfo();
            k.name = "SeriesAvg";
            k.title = "Series Average";
            k.iconName = "analyze-seriesavg";
            k.iconCollectionName = "ChartToolbarIcons";
            k.iconWidth = 24;
            k.iconHeight = 25;
            let l = new ToolActionSeparatorInfo();
            l.name = "SeriesAvgSeparator";
            let m = new ToolActionLabelInfo();
            m.name = "ValueLabelsMenu";
            m.title = "Value Labels";
            m.iconName = "analyze-valuelabels";
            m.iconCollectionName = "ChartToolbarIcons";
            m.actions = this.d(a);
            m.iconWidth = 24;
            m.iconHeight = 24;
            let n = new ToolActionSeparatorInfo();
            n.name = "HelpersSectionSeparator";
            n.size = DeviceUtils.g(10);
            let o = new ToolActionCheckboxInfo();
            o.name = "ShowGridlines";
            o.title = "Grid";
            o.iconName = "analyze-grid";
            o.iconCollectionName = "ChartToolbarIcons";
            o.iconWidth = 24;
            o.iconHeight = 25;
            let p = new ToolActionSeparatorInfo();
            p.name = "GridSeparator";
            let q = new ToolActionCheckboxInfo();
            q.name = "ShowCrosshairs";
            q.title = "Crosshairs";
            q.iconName = "analyze-crosshairs";
            q.iconCollectionName = "ChartToolbarIcons";
            q.iconWidth = 24;
            q.iconHeight = 25;
            let r = new ToolActionIconMenuInfo();
            r.name = "AnalyzeMenu";
            r.iconName = "analyze";
            r.iconCollectionName = "ChartToolbarIcons";
            r.iconWidth = 24;
            r.iconHeight = 25;
            r.actions = [d, e, f, g, h, i, j, k, l, m, n, o, p, q];
            let s = new ToolActionGroupHeaderInfo();
            s.name = "CopyHeader";
            s.title = "Copy...";
            let t = new ToolActionLabelInfo();
            t.name = "CopyAsImage";
            t.title = "As Image";
            t.iconName = "copy-image";
            t.iconCollectionName = "ChartToolbarIcons";
            t.closeOnExecute = true;
            let u = new ToolActionLabelInfo();
            u.name = "CopyAsTable";
            u.title = "Table Data";
            u.iconName = "copy-table";
            u.iconCollectionName = "ChartToolbarIcons";
            let v = new ToolActionIconMenuInfo();
            v.name = "CopyMenu";
            v.iconName = "copy";
            v.iconCollectionName = "ChartToolbarIcons";
            v.iconWidth = 24;
            v.iconHeight = 24;
            v.actions = [s, t];
            let w = [b, c, ((() => {
                    let $ret = new ToolActionSeparatorInfo();
                    $ret.name = "ZoomMenuSeparator";
                    return $ret;
                })()), r, ((() => {
                    let $ret = new ToolActionSeparatorInfo();
                    $ret.name = "AnalyzeMenuSeparator";
                    return $ret;
                })()), v];
            for (let x = 0; x < w.length; x++) {
                this.a9(a, w[x]);
            }
            return w;
        }
        a9(a, b) {
            if (b.actions != null && b.actions.length > 0) {
                for (let c = 0; c < b.actions.length; c++) {
                    this.a9(a, b.actions[c]);
                }
            }
            switch (b.name) {
                case "ShowValueLabels":
                    {
                        let d = b;
                        let e = this.m(a);
                        d.isChecked = e != null && e._visibility == 0;
                    }
                    break;
                case "ShowLastValueLabel":
                    {
                        let f = b;
                        let g = this.o(a);
                        f.isChecked = g != null && g._visibility == 0;
                    }
                    break;
                case "Linear":
                    {
                        let h = b;
                        for (let i of fromEnum(a.series)) {
                            if (i.ey) {
                                if (this.v && this.l.matchesType(i)) {
                                    h.isChecked = this.l.getTrendLineType(i) == 1;
                                }
                            }
                            else if (i.e9) {
                                if (this.u && this.j.matchesType(i)) {
                                    h.isChecked = this.j.getTrendLineType(i) == 1;
                                }
                            }
                        }
                    }
                    break;
                case "Exponential":
                    {
                        let j = b;
                        for (let k of fromEnum(a.series)) {
                            if (k.ey) {
                                if (this.v && this.l.matchesType(k)) {
                                    j.isChecked = this.l.getTrendLineType(k) == 7;
                                }
                            }
                            else if (k.e9) {
                                if (this.u && this.j.matchesType(k)) {
                                    j.isChecked = this.j.getTrendLineType(k) == 7;
                                }
                            }
                        }
                    }
                    break;
                case "Logarithmic":
                    {
                        let l = b;
                        for (let m of fromEnum(a.series)) {
                            if (m.ey) {
                                if (this.v && this.l.matchesType(m)) {
                                    l.isChecked = this.l.getTrendLineType(m) == 6;
                                }
                            }
                            else if (m.e9) {
                                if (this.u && this.j.matchesType(m)) {
                                    l.isChecked = this.j.getTrendLineType(m) == 6;
                                }
                            }
                        }
                    }
                    break;
                case "NoTrends":
                    {
                        let n = b;
                        let o = 0;
                        let p = a.series.count;
                        for (let q of fromEnum(a.series)) {
                            if (q.ey) {
                                if (this.v && this.l.matchesType(q) && this.l.getTrendLineType(q) == 0) {
                                    o = o + 1;
                                }
                            }
                            else if (q.e9) {
                                if (this.u && this.j.matchesType(q) && this.j.getTrendLineType(q) == 0) {
                                    o = o + 1;
                                }
                            }
                            else if (q.es) {
                                p = p - 1;
                            }
                        }
                        n.isChecked = o == p;
                    }
                    break;
                case "MinValue":
                    {
                        let r = b;
                        let s = this.p(a, 4);
                        r.isChecked = s != null && s._visibility == 0;
                    }
                    break;
                case "MaxValue":
                    {
                        let t = b;
                        let u = this.p(a, 5);
                        t.isChecked = u != null && u._visibility == 0;
                    }
                    break;
                case "Average":
                    {
                        let v = b;
                        let w = this.p(a, 6);
                        v.isChecked = w != null && w._visibility == 0;
                    }
                    break;
                case "ShowCrosshairs":
                    {
                        let x = b;
                        let y = this.n(a);
                        x.isChecked = y != null && y._visibility == 0;
                    }
                    break;
                case "ShowGridlines":
                    {
                        let z = b;
                        z.isChecked = this.s(a);
                    }
                    break;
                case "SeriesAvg":
                    {
                        let aa = b;
                        let ab = this.p(a, 3);
                        aa.isChecked = ab != null && ab._visibility == 0;
                    }
                    break;
            }
        }
        e() {
            let a = new ToolActionGroupHeaderInfo();
            a.name = "ZoomHeader";
            a.title = "Zoom";
            let b = new ToolActionLabelInfo();
            b.name = "ZoomIn";
            b.iconName = "zoomin";
            b.iconCollectionName = "ChartToolbarIcons";
            b.iconWidth = 24;
            b.iconHeight = 25;
            b.title = "Zoom In";
            let c = new ToolActionLabelInfo();
            c.name = "ZoomOut";
            c.iconName = "zoomout";
            c.iconCollectionName = "ChartToolbarIcons";
            c.iconWidth = 24;
            c.iconHeight = 25;
            c.title = "Zoom Out";
            return [a, b, c];
        }
        a() {
            let a = new ToolActionGroupHeaderInfo();
            a.name = "LinesHeader";
            a.title = "Lines";
            let b = new ToolActionSeparatorInfo();
            b.isGroupHeaderSeparator = true;
            let c = new ToolActionCheckboxInfo();
            c.name = "MaxValue";
            c.title = "Max value";
            c.iconName = "analyze-lines-maxvalue";
            c.iconCollectionName = "ChartToolbarIcons";
            c.iconWidth = 24;
            c.iconHeight = 25;
            let d = new ToolActionCheckboxInfo();
            d.name = "MinValue";
            d.title = "Min value";
            d.iconName = "analyze-lines-minvalue";
            d.iconCollectionName = "ChartToolbarIcons";
            d.iconWidth = 24;
            d.iconHeight = 25;
            let e = new ToolActionCheckboxInfo();
            e.name = "Average";
            e.title = "Average";
            e.iconName = "analyze-seriesavg";
            e.iconCollectionName = "ChartToolbarIcons";
            e.iconWidth = 24;
            e.iconHeight = 25;
            return [a, b, c, d, e];
        }
        c() {
            let a = new ToolActionGroupHeaderInfo();
            a.name = "TrendsHeader";
            a.title = "Trends";
            let b = new ToolActionSeparatorInfo();
            b.name = "TrendsHeaderSeparator";
            b.isGroupHeaderSeparator = true;
            let c = new ToolActionRadioInfo();
            c.name = "Exponential";
            c.title = "Exponential";
            c.iconName = "analyze-trends-exp";
            c.iconCollectionName = "ChartToolbarIcons";
            c.channel = "trends";
            c.iconWidth = 24;
            c.iconHeight = 25;
            let d = new ToolActionRadioInfo();
            d.name = "Linear";
            d.title = "Linear";
            d.iconName = "analyze-trends-trendline";
            d.iconCollectionName = "ChartToolbarIcons";
            d.channel = "trends";
            d.iconWidth = 24;
            d.iconHeight = 25;
            let e = new ToolActionRadioInfo();
            e.name = "Logarithmic";
            e.title = "Logarithmic";
            e.iconName = "analyze-trends-log";
            e.iconCollectionName = "ChartToolbarIcons";
            e.channel = "trends";
            e.iconWidth = 24;
            e.iconHeight = 25;
            let f = new ToolActionRadioInfo();
            f.name = "NoTrends";
            f.title = "None";
            f.channel = "trends";
            f.iconName = "ig-NoIcon";
            return [a, b, c, d, e, f];
        }
        b() {
            let a = new ToolActionGroupHeaderInfo();
            a.name = "TimePeriodHighlightHeader";
            a.title = "TIME HIGHLIGHT";
            let b = new ToolActionSeparatorInfo();
            b.isGroupHeaderSeparator = true;
            let c = new ToolActionRadioInfo();
            c.name = "Quarters";
            c.title = "Quarters";
            c.channel = "time";
            let d = new ToolActionRadioInfo();
            d.name = "Seasons";
            d.title = "Seasons";
            d.channel = "time";
            let e = new ToolActionRadioInfo();
            e.name = "Weekends";
            e.title = "Weekends";
            e.channel = "time";
            let f = new ToolActionRadioInfo();
            f.name = "WorkDays";
            f.title = "Work days";
            f.channel = "time";
            return [a, b, c, d, e, f];
        }
        d(a) {
            let b = new ToolActionGroupHeaderInfo();
            b.name = "ValueLabelsHeader";
            b.title = "Value Labels";
            let c = new ToolActionSeparatorInfo();
            c.isGroupHeaderSeparator = true;
            let d = new ToolActionCheckboxInfo();
            d.name = "ShowValueLabels";
            d.title = "Show Value Labels";
            d.iconName = "analyze-valuelabels";
            d.iconCollectionName = "ChartToolbarIcons";
            d.iconWidth = 24;
            d.iconHeight = 24;
            let e = new ToolActionCheckboxInfo();
            e.name = "ShowLastValueLabel";
            e.title = "Show Last Value Label";
            e.iconName = "analyze-valuelabels-showlast";
            e.iconCollectionName = "ChartToolbarIcons";
            return [b, c, d, e];
        }
        m(a) {
            for (let b of fromEnum(a.series)) {
                if (this.h.isCalloutLayer(b) && this.h.getIsAutoCalloutBehaviorEnabled(b)) {
                    return b;
                }
            }
            return null;
        }
        o(a) {
            for (let b of fromEnum(a.series)) {
                if (this.h.isFinalValueLayer(b)) {
                    return b;
                }
            }
            return null;
        }
        p(a, b) {
            for (let c of fromEnum(a.series)) {
                if (this.h.isValueLayer(c) && this.h.getValueMode(c) == b) {
                    return c;
                }
            }
            return null;
        }
        n(a) {
            for (let b of fromEnum(a.series)) {
                if (this.h.isCrosshairLayer(b)) {
                    return b;
                }
            }
            return null;
        }
        s(a) {
            let b = typeCast(XamDataChart.$, a);
            if (b != null) {
                for (let c = 0; c < b.axes.count; c++) {
                    let d = b.axes._inner[c];
                    if (d.jw != null && !BrushUtilCore.a(d.jw) && d.et != 0) {
                        return true;
                    }
                }
            }
            return false;
        }
        onToolCommandExecuting(a, b) {
            switch (b.commandId) {
                case "ZoomReset":
                    this.bq(a, b);
                    break;
                case "ZoomIn":
                    this.bo(a, b);
                    break;
                case "ZoomOut":
                    this.bp(a, b);
                    break;
                case "ShowCrosshairs":
                    this.bc(a, b);
                    break;
                case "ShowGridlines":
                    this.be(a, b);
                    break;
                case "MaxValue":
                    this.bi(a, b);
                    break;
                case "MinValue":
                    this.bj(a, b);
                    break;
                case "Average":
                    this.ba(a, b);
                    break;
                case "Exponential":
                    this.bd(a, b);
                    break;
                case "Linear":
                    this.bg(a, b);
                    break;
                case "Logarithmic":
                    this.bh(a, b);
                    break;
                case "NoTrends":
                    this.bk(a, b);
                    break;
                case "SeriesAvg":
                    this.bl(a, b);
                    break;
                case "ShowValueLabels":
                    this.bn(a, b);
                    break;
                case "ShowLastValueLabel":
                    this.bm(a, b);
                    break;
                case "CopyAsImage":
                    this.bb(a, b);
                    return 2;
            }
            return 0;
        }
        w(a, b) {
            if (a.commandId == b) {
                let e = a.argumentsList;
                for (let d = 0; d < e.length; d++) {
                    let c = e[d];
                    if (c.argumentName == "IsChecked") {
                        return c.value;
                    }
                }
            }
            return false;
        }
        bc(a, b) {
            let c = this.n(a);
            if (this.x(a, c)) {
                return;
            }
            this.br(a, b, "ShowCrosshairs", 0, () => {
                let d = this.h.createCrosshairLayer();
                this.h.setCrosshairOnAxesEnabled(d, true);
                let e = new AutomaticSeriesRequest();
                e.a = 0;
                e.e = true;
                e.d = d;
                return e;
            });
        }
        f(a, b) {
            let c = new AxisStrokeSettings();
            c.b = a.jz == null || BrushUtilCore.a(a.jz) ? b : a.jz;
            c.a = isNaN_(a.et) || a.et == 0 ? DeviceUtils.g(1) : a.et;
            this.r.item(a, c);
            return c;
        }
        be(a, b) {
            let c = this.w(b, "ShowGridlines");
            if (!c) {
                let d = typeCast(XamDataChart.$, a);
                if (d != null) {
                    for (let e = 0; e < d.axes.count; e++) {
                        let f = d.axes._inner[e];
                        if (!this.r.d(f)) {
                            this.f(f, d.aaq);
                        }
                        f.et = 0;
                    }
                }
            }
            else {
                let g = typeCast(XamDataChart.$, a);
                if (g != null) {
                    for (let h = 0; h < g.axes.count; h++) {
                        let i = g.axes._inner[h];
                        let j = true;
                        if (this.r.d(i)) {
                            if (this.r.item(i).b != i.jz || i.et != 0) {
                                j = true;
                            }
                            else {
                                i.jz = this.r.item(i).b;
                                i.et = this.r.item(i).a;
                                j = false;
                            }
                        }
                        if (j) {
                            let k = this.f(i, g.aaq);
                            i.jz = k.b;
                            i.et = k.a;
                        }
                    }
                }
            }
        }
        bd(a, b) {
            if (!this.v) {
                return;
            }
            let c = this.w(b, "Exponential");
            if (c) {
                for (let d of fromEnum(a.series)) {
                    if (d.ey) {
                        if (this.v && this.l.matchesType(d)) {
                            this.l.setTrendLineType(d, 7);
                        }
                    }
                    else if (d.e9) {
                        if (this.u && this.j.matchesType(d)) {
                            this.j.setTrendLineType(d, 7);
                        }
                    }
                }
            }
        }
        bg(a, b) {
            if (!this.v) {
                return;
            }
            let c = this.w(b, "Linear");
            if (c) {
                for (let d of fromEnum(a.series)) {
                    if (d.ey) {
                        if (this.v && this.l.matchesType(d)) {
                            this.l.setTrendLineType(d, 1);
                        }
                    }
                    else if (d.e9) {
                        if (this.u && this.j.matchesType(d)) {
                            this.j.setTrendLineType(d, 1);
                        }
                    }
                }
            }
        }
        bh(a, b) {
            let c = this.w(b, "Logarithmic");
            if (c) {
                for (let d of fromEnum(a.series)) {
                    if (d.ey) {
                        if (this.v && this.l.matchesType(d)) {
                            this.l.setTrendLineType(d, 6);
                        }
                    }
                    else if (d.e9) {
                        if (this.u && this.j.matchesType(d)) {
                            this.j.setTrendLineType(d, 6);
                        }
                    }
                }
            }
        }
        bk(a, b) {
            let c = this.w(b, "NoTrends");
            if (c) {
                for (let d of fromEnum(a.series)) {
                    if (d.ey) {
                        if (this.v && this.l.matchesType(d)) {
                            this.l.setTrendLineType(d, 0);
                        }
                    }
                    else if (d.e9) {
                        if (this.u && this.j.matchesType(d)) {
                            this.j.setTrendLineType(d, 0);
                        }
                    }
                }
            }
        }
        br(a, b, c, d, e) {
            let f = this.w(b, c);
            let g = a.ao(a);
            if (f && !g.e(d)) {
                if (this.t && e != null) {
                    g.b.add(e());
                }
            }
            if (!f && g.e(d)) {
                g.l(d);
            }
        }
        bi(a, b) {
            let c = this.p(a, 5);
            if (c != null && this.h.getValueMode(c) == 5 && this.x(a, c)) {
                return;
            }
            this.br(a, b, "MaxValue", 1, () => {
                let d = this.h.createValueLayer();
                this.h.setValueMode(d, 5);
                this.h.setValueAxisAnnotationEnabled(d, true);
                this.h.setBrush(d, BrushUtil.h(255, 99, 208, 0));
                this.h.setUseLegend(d, true);
                this.h.setTitle(d, "Maximum");
                this.h.setLegendItemBadgeShape(d, 2);
                let e = new AutomaticSeriesRequest();
                e.a = 1;
                e.e = true;
                e.d = d;
                return e;
            });
        }
        bj(a, b) {
            let c = this.p(a, 4);
            if (c != null && this.x(a, c)) {
                return;
            }
            this.br(a, b, "MinValue", 2, () => {
                let d = this.h.createValueLayer();
                this.h.setValueMode(d, 4);
                this.h.setValueAxisAnnotationEnabled(d, true);
                this.h.setBrush(d, BrushUtil.h(255, 246, 93, 80));
                this.h.setUseLegend(d, true);
                this.h.setTitle(d, "Minimum");
                this.h.setLegendItemBadgeShape(d, 2);
                let e = new AutomaticSeriesRequest();
                e.a = 2;
                e.e = true;
                e.d = d;
                return e;
            });
        }
        ba(a, b) {
            let c = this.p(a, 6);
            if (c != null && this.x(a, c)) {
                return;
            }
            this.br(a, b, "Average", 3, () => {
                let d = this.h.createValueLayer();
                this.h.setValueMode(d, 6);
                this.h.setValueAxisAnnotationEnabled(d, true);
                this.h.setBrush(d, BrushUtil.h(255, 248, 173, 118));
                this.h.setUseLegend(d, true);
                this.h.setTitle(d, "Average");
                this.h.setLegendItemBadgeShape(d, 2);
                let e = new AutomaticSeriesRequest();
                e.a = 3;
                e.e = true;
                e.d = d;
                return e;
            });
        }
        bl(a, b) {
            let c = a.ao(a);
            let d = this.p(a, 3);
            if (d != null) {
                c.l(4);
                return;
            }
            if (!this.t) {
                return;
            }
            let e = a.series.count;
            for (let f = 0; f < e; f++) {
                let g = a.series._inner[f];
                if (g.es) {
                    continue;
                }
                let h = this.h.createValueLayer();
                this.h.setValueMode(h, 3);
                this.h.setValueAxisAnnotationEnabled(h, true);
                this.h.setUseLegend(h, a.f2);
                if (g.title != null && typeof g.title === 'string') {
                    let i = g.title;
                    this.h.setTitle(h, i + " Avg");
                }
                this.h.setLegendItemBadgeShape(h, 2);
                this.h.setTargetSeries(h, g);
                this.h.setBrush(h, g.u9);
                let j = new AutomaticSeriesRequest();
                j.a = 4;
                j.e = true;
                j.d = h;
                c.b.add(j);
            }
        }
        x(a, b) {
            if (b != null) {
                let c = false;
                let d = a.ao(a);
                for (let e of fromEnum(d.b)) {
                    if (e.d == b) {
                        c = true;
                        break;
                    }
                }
                if (!c) {
                    if (b._visibility == 0) {
                        let cl_ = b;
                        let v_ = 1;
                        cl_.visibility = v_;
                        return true;
                    }
                    else if (b._visibility == 1) {
                        let cl_ = b;
                        let v_ = 0;
                        cl_.visibility = v_;
                        return true;
                    }
                }
            }
            return false;
        }
        bn(a, b) {
            let c = this.m(a);
            if (this.x(a, c)) {
                return;
            }
            this.br(a, b, "ShowValueLabels", 5, () => {
                for (let d of fromEnum(a.series)) {
                    if (d.ey) {
                        if (this.v && this.l.matchesType(d)) {
                            let e = this.l.getMarkerType(d);
                            if (e == 1) {
                                this.l.setMarkerType(d, 13);
                            }
                        }
                    }
                }
                let f = this.h.createCalloutLayer();
                this.h.setIsAutoCalloutBehaviorEnabled(f, true);
                let g = new AutomaticSeriesRequest();
                g.a = 5;
                g.e = true;
                g.d = f;
                return g;
            });
        }
        bm(a, b) {
            let c = this.o(a);
            if (this.x(a, c)) {
                return;
            }
            this.br(a, b, "ShowLastValueLabel", 6, () => {
                for (let d of fromEnum(a.series)) {
                    let e = d.ai();
                    if (e != null) {
                        for (let g = 0; g < e.length; g++) {
                            let f = e[g];
                            if (f.cj) {
                                f.cu = true;
                            }
                        }
                    }
                }
                let h = this.h.createFinalValueLayer();
                let i = new AutomaticSeriesRequest();
                i.a = 6;
                i.e = true;
                i.d = h;
                return i;
            });
        }
        bb(a, b) {
            this.q = b;
            let c = new CaptureImageSettings();
            c.b = true;
            c.a = 0;
            a.imageCaptured = delegateCombine(a.imageCaptured, runOn(this, this.bf));
            a.nb(c);
            a.al.q();
        }
        bf(a, b) {
            this.q.argumentsList = [((() => {
                    let $ret = new ToolCommandArgument();
                    $ret.argumentName = "Image";
                    $ret.value = b.base64Data;
                    return $ret;
                })())];
            let c = a;
            c.imageCaptured = delegateRemove(c.imageCaptured, runOn(this, this.bf));
            if (c.commandCompleted != null) {
                c.commandCompleted(this.q);
            }
        }
        bo(a, b) {
            a.rz(0.05);
        }
        bp(a, b) {
            a.r0(0.05);
        }
        bq(a, b) {
            a.q8();
        }
    }
    DataChartToolbarProvider.$t = /*@__PURE__*/ markType(DataChartToolbarProvider, 'DataChartToolbarProvider', Base.$, [IDataChartToolbarProvider_$type]);
    return DataChartToolbarProvider;
})();
