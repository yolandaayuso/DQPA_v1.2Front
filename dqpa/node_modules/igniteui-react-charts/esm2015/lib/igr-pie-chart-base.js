import * as React from 'react';
import { delegateCombine, delegateRemove } from "igniteui-react-core";
import { LabelsPosition_$type } from "./LabelsPosition";
import { Visibility_$type } from "igniteui-react-core";
import { LeaderLineType_$type } from "./LeaderLineType";
import { OthersCategoryType_$type } from "igniteui-react-core";
import { IgrIndexCollection } from "./igr-index-collection";
import { SweepDirection_$type } from "igniteui-react-core";
import { LegendEmptyValuesMode_$type } from "igniteui-react-core";
import { SliceSelectionMode_$type } from "./SliceSelectionMode";
import { IgrObjectCollection } from "igniteui-react-core";
import { IgrLabelClickEventArgs } from "./igr-label-click-event-args";
import { IgrSelectedItemChangingEventArgs } from "./igr-selected-item-changing-event-args";
import { IgrSelectedItemsChangingEventArgs } from "./igr-selected-items-changing-event-args";
import { IgrSelectedItemChangedEventArgs } from "./igr-selected-item-changed-event-args";
import { IgrSelectedItemsChangedEventArgs } from "./igr-selected-items-changed-event-args";
import { IgrSliceClickEventArgs } from "./igr-slice-click-event-args";
import { IgrSliceEventArgs } from "./igr-slice-event-args";
import { TypeRegistrar, Number_$type, Base } from "igniteui-react-core";
import { NamePatcher, getModifiedProps, isValidProp, ensureEnum, brushToString, stringToBrush, ensureBool, toBrushCollection, fromBrushCollection, arrayFindByName, toSpinal, initializePropertiesFromCss, toPoint } from "igniteui-react-core";
import { IndexCollection as IndexCollection_internal } from "./IndexCollection";
import { SyncableObservableCollection$1 } from "igniteui-react-core";
import { Style } from "igniteui-react-core";
import { ObjectCollection as ObjectCollection_internal } from "igniteui-react-core";
/**
 * Represents the base class for the pie chart.
*/
export class IgrPieChartBase extends React.Component {
    createImplementation() {
        return null;
    }
    get nativeElement() {
        return this._implementation.nativeElement;
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    } /**
                                 * @hidden
                                 */
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    onImplementationCreated() {
    }
    constructor(props) {
        super(props);
        this.mounted = false;
        this._explodedSlices = null;
        this._selectedItems = null;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        this._labelClick = null;
        this._labelClick_wrapped = null;
        this._selectedItemChanging = null;
        this._selectedItemChanging_wrapped = null;
        this._selectedItemsChanging = null;
        this._selectedItemsChanging_wrapped = null;
        this._selectedItemChanged = null;
        this._selectedItemChanged_wrapped = null;
        this._selectedItemsChanged = null;
        this._selectedItemsChanged_wrapped = null;
        this._sliceClick = null;
        this._sliceClick_wrapped = null;
        this._sliceEnter = null;
        this._sliceEnter_wrapped = null;
        this._sliceLeave = null;
        this._sliceLeave_wrapped = null;
        this._sliceHover = null;
        this._sliceHover_wrapped = null;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
        if (this._initializeAdapters) {
            this._initializeAdapters();
        }
    }
    componentDidMount() {
        this.mounted = true;
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    render() {
        return null;
    }
    /**
     * Gets or sets the amount of space between the center and the start of the arc. This property should be set between 0 and 1.
     * If InnerExtent is set to a value greater than 1, it will be interpreted as a percentage, effectively divided by 100.
    */
    get innerExtent() {
        return this.i.da;
    }
    set innerExtent(v) {
        this.i.da = +v;
    }
    /**
     * Gets or Sets the property name that contains the values.
    */
    get valueMemberPath() {
        return this.i.fv;
    }
    set valueMemberPath(v) {
        this.i.fv = v;
    }
    /**
     * Gets or sets the property name that contains the labels.
    */
    get labelMemberPath() {
        return this.i.ej;
    }
    set labelMemberPath(v) {
        this.i.ej = v;
    }
    /**
     * Gets or sets the property name that contains the legend labels.
    */
    get legendLabelMemberPath() {
        return this.i.ez;
    }
    set legendLabelMemberPath(v) {
        this.i.ez = v;
    }
    /**
     * Gets or sets the position of chart labels.
    */
    get labelsPosition() {
        return this.i.az;
    }
    set labelsPosition(v) {
        this.i.az = ensureEnum(LabelsPosition_$type, v);
    }
    /**
     * Gets or sets the color for labels rendered outside of the pie chart.
    */
    get labelOuterColor() {
        return brushToString(this.i.i1);
    }
    set labelOuterColor(v) {
        this.i.i1 = stringToBrush(v);
    }
    /**
     * Gets or sets the color for labels rendered inside of the pie chart.
    */
    get labelInnerColor() {
        return brushToString(this.i.i0);
    }
    set labelInnerColor(v) {
        this.i.i0 = stringToBrush(v);
    }
    /**
     * Gets the actual color for labels rendered outside of the pie chart.
    */
    get actualLabelOuterColor() {
        return brushToString(this.i.iz);
    }
    set actualLabelOuterColor(v) {
        this.i.iz = stringToBrush(v);
    }
    /**
     * Gets the actual color for labels rendered inside of the pie chart.
    */
    get actualLabelInnerColor() {
        return brushToString(this.i.iy);
    }
    set actualLabelInnerColor(v) {
        this.i.iy = stringToBrush(v);
    }
    /**
     * Gets or sets whether the leader lines are visible.
    */
    get leaderLineVisibility() {
        return this.i.je;
    }
    set leaderLineVisibility(v) {
        this.i.je = ensureEnum(Visibility_$type, v);
    }
    /**
     * Gets or sets what type of leader lines will be used for the outside end labels.
    */
    get leaderLineType() {
        return this.i.a0;
    }
    set leaderLineType(v) {
        this.i.a0 = ensureEnum(LeaderLineType_$type, v);
    }
    /**
     * Gets or sets the margin between a label and the end of its leader line. The default is 6 pixels.
    */
    get leaderLineMargin() {
        return this.i.dc;
    }
    set leaderLineMargin(v) {
        this.i.dc = +v;
    }
    /**
     * Gets or sets the ToolTip for the chart.
    */
    get toolTip() {
        return this.i.dr;
    }
    set toolTip(v) {
        this.i.dr = v;
    }
    /**
     * Gets or sets the threshold value that determines if slices are grouped into the Others slice.
    */
    get othersCategoryThreshold() {
        return this.i.dd;
    }
    set othersCategoryThreshold(v) {
        this.i.dd = +v;
    }
    /**
     * Gets or sets whether to use numeric or percent-based threshold value.
    */
    get othersCategoryType() {
        return this.i.a2;
    }
    set othersCategoryType(v) {
        this.i.a2 = ensureEnum(OthersCategoryType_$type, v);
    }
    /**
     * Gets or sets the label of the Others slice.
    */
    get othersCategoryText() {
        return this.i.e6;
    }
    set othersCategoryText(v) {
        this.i.e6 = v;
    }
    /**
     * Determines how much the exploded slice is offset from the center. Value between 0 and 1.
    */
    get explodedRadius() {
        return this.i.c5;
    }
    set explodedRadius(v) {
        this.i.c5 = +v;
    }
    /**
     * Gets or sets the scaling factor of the chart's radius. Value between 0 and 1.
    */
    get radiusFactor() {
        return this.i.dg;
    }
    set radiusFactor(v) {
        this.i.dg = +v;
    }
    /**
     * Gets or sets whether the slices can be selected.
    */
    get allowSliceSelection() {
        return this.i.b9;
    }
    set allowSliceSelection(v) {
        this.i.b9 = ensureBool(v);
    }
    /**
     * Gets or sets whether the slices can be exploded.
    */
    get allowSliceExplosion() {
        return this.i.b8;
    }
    set allowSliceExplosion(v) {
        this.i.b8 = ensureBool(v);
    }
    /**
     * Gets or sets the collection of exploded slice indices.
    */
    get explodedSlices() {
        if (this._explodedSlices === null) {
            let coll = new IgrIndexCollection();
            let innerColl = this.i.explodedSlices;
            if (!innerColl) {
                innerColl = new IndexCollection_internal();
            }
            this._explodedSlices = coll._fromInner(innerColl);
            this.i.explodedSlices = innerColl;
        }
        return this._explodedSlices;
    }
    set explodedSlices(v) {
        if (this._explodedSlices !== null) {
            this._explodedSlices._setSyncTarget(null);
            this._explodedSlices = null;
        }
        let coll = new IgrIndexCollection();
        this._explodedSlices = coll._fromOuter(v);
        let syncColl = new SyncableObservableCollection$1(Number_$type);
        let innerColl = this.i.explodedSlices;
        if (!innerColl) {
            innerColl = new IndexCollection_internal();
        }
        syncColl._inner = innerColl;
        syncColl.clear();
        this._explodedSlices._setSyncTarget(syncColl);
        this.i.explodedSlices = innerColl;
    }
    /**
     * Gets or sets the pixel amount by which the labels are offset from the edge of the slices.
    */
    get labelExtent() {
        return this.i.db;
    }
    set labelExtent(v) {
        this.i.db = +v;
    }
    /**
     * Gets or sets the starting angle of the chart.
     * The default zero value is equivalent to 3 o'clock.
    */
    get startAngle() {
        return this.i.di;
    }
    set startAngle(v) {
        this.i.di = +v;
    }
    /**
     * Gets or sets the rotational direction of the chart.
    */
    get sweepDirection() {
        return this.i.i3;
    }
    set sweepDirection(v) {
        this.i.i3 = ensureEnum(SweepDirection_$type, v);
    }
    /**
     * Gets or sets the fill brush.
    */
    get othersCategoryFill() {
        return this.i.jb ? this.i.jb.fill : null;
    }
    set othersCategoryFill(v) {
        this.ensureOthersCategoryStyle();
        this.i.jb.fill = v;
    }
    /**
     * Gets or sets the stroke brush.
    */
    get othersCategoryStroke() {
        return this.i.jb ? this.i.jb.stroke : null;
    }
    set othersCategoryStroke(v) {
        this.ensureOthersCategoryStyle();
        this.i.jb.stroke = v;
    }
    /**
     * Gets or sets the stroke thickness.
    */
    get othersCategoryStrokeThickness() {
        return this.i.jb ? this.i.jb.strokeThickness : NaN;
    }
    set othersCategoryStrokeThickness(v) {
        this.ensureOthersCategoryStyle();
        this.i.jb.strokeThickness = +v;
    }
    /**
     * Gets or sets the opacity.
    */
    get othersCategoryOpacity() {
        return this.i.jb ? this.i.jb.opacity : NaN;
    }
    set othersCategoryOpacity(v) {
        this.ensureOthersCategoryStyle();
        this.i.jb.opacity = +v;
    }
    ensureOthersCategoryStyle() {
        if (this.i.jb) {
            return;
        }
        this.i.jb = new Style();
    }
    /**
     * Gets or sets the fill brush.
    */
    get selectedSliceFill() {
        return this.i.jc ? this.i.jc.fill : null;
    }
    set selectedSliceFill(v) {
        this.ensureSelectedStyle();
        this.i.jc.fill = v;
    }
    /**
     * Gets or sets the stroke brush.
    */
    get selectedSliceStroke() {
        return this.i.jc ? this.i.jc.stroke : null;
    }
    set selectedSliceStroke(v) {
        this.ensureSelectedStyle();
        this.i.jc.stroke = v;
    }
    /**
     * Gets or sets the stroke thickness.
    */
    get selectedSliceStrokeThickness() {
        return this.i.jc ? this.i.jc.strokeThickness : NaN;
    }
    set selectedSliceStrokeThickness(v) {
        this.ensureSelectedStyle();
        this.i.jc.strokeThickness = +v;
    }
    /**
     * Gets or sets the opacity.
    */
    get selectedSliceOpacity() {
        return this.i.jc ? this.i.jc.opacity : NaN;
    }
    set selectedSliceOpacity(v) {
        this.ensureSelectedStyle();
        this.i.jc.opacity = +v;
    }
    ensureSelectedStyle() {
        if (this.i.jc) {
            return;
        }
        this.i.jc = new Style();
    }
    /**
     * Gets or sets the palette of brushes to use for coloring the slices.
    */
    get brushes() {
        return fromBrushCollection(this.i.am);
    }
    set brushes(v) {
        this.i.am = toBrushCollection(v);
    }
    /**
     * Gets the actual palette of brushes to use for coloring the slices.
    */
    get actualBrushes() {
        return fromBrushCollection(this.i.ak);
    }
    set actualBrushes(v) {
        this.i.ak = toBrushCollection(v);
    }
    /**
     * Gets or sets the palette of brushes to use for outlines on the slices.
    */
    get outlines() {
        return fromBrushCollection(this.i.an);
    }
    set outlines(v) {
        this.i.an = toBrushCollection(v);
    }
    /**
     * Gets the actual palette of brushes to use for outlines on the slices.
    */
    get actualOutlines() {
        return fromBrushCollection(this.i.al);
    }
    set actualOutlines(v) {
        this.i.al = toBrushCollection(v);
    }
    /**
     * Gets or sets the label format string to use for the label.
    */
    get labelFormat() {
        return this.i.ef;
    }
    set labelFormat(v) {
        this.i.ef = v;
    }
    /**
     * Gets or sets the format specifiers to use with the LabelFormat string.
    */
    get labelFormatSpecifiers() {
        return this.i.ag;
    }
    set labelFormatSpecifiers(v) {
        if (v && !Array.isArray(v) && typeof (v) == "string") {
            const re = /\s*(?:,|\s|$)\s*/gm;
            v = v.split(re);
        }
        this.i.ag = v;
    }
    /**
     * Gets or sets the label format string to use for the label.
    */
    get othersLabelFormat() {
        return this.i.fa;
    }
    set othersLabelFormat(v) {
        this.i.fa = v;
    }
    /**
     * Gets or sets the format specifiers to use with the OthersLabelFormat string.
    */
    get othersLabelFormatSpecifiers() {
        return this.i.aj;
    }
    set othersLabelFormatSpecifiers(v) {
        if (v && !Array.isArray(v) && typeof (v) == "string") {
            const re = /\s*(?:,|\s|$)\s*/gm;
            v = v.split(re);
        }
        this.i.aj = v;
    }
    /**
     * Gets or sets the label format string to use for the label.
    */
    get legendLabelFormat() {
        return this.i.ew;
    }
    set legendLabelFormat(v) {
        this.i.ew = v;
    }
    /**
     * Gets or sets the format specifiers to use with the LegendLabelFormat string.
    */
    get legendLabelFormatSpecifiers() {
        return this.i.ah;
    }
    set legendLabelFormatSpecifiers(v) {
        if (v && !Array.isArray(v) && typeof (v) == "string") {
            const re = /\s*(?:,|\s|$)\s*/gm;
            v = v.split(re);
        }
        this.i.ah = v;
    }
    /**
     * Gets or sets the label format string to use for the label.
    */
    get legendOthersLabelFormat() {
        return this.i.e1;
    }
    set legendOthersLabelFormat(v) {
        this.i.e1 = v;
    }
    /**
     * Gets or sets the format specifiers to use with the LegendOthersLabelFormat string.
    */
    get legendOthersLabelFormatSpecifiers() {
        return this.i.ai;
    }
    set legendOthersLabelFormatSpecifiers(v) {
        if (v && !Array.isArray(v) && typeof (v) == "string") {
            const re = /\s*(?:,|\s|$)\s*/gm;
            v = v.split(re);
        }
        this.i.ai = v;
    }
    /**
     * Gets or sets the LegendItemTemplate property.
     * The legend item control content is created according to the LegendItemTemplate on-demand by
     * the chart object itself.
    */
    get legendItemTemplate() {
        return this.i.legendItemTemplate;
    }
    set legendItemTemplate(v) {
        this.i.legendItemTemplate = v;
    }
    /**
     * Gets or sets the LegendItemBadgeTemplate property.
     * The legend item badge is created according to the LegendItemBadgeTemplate on-demand by
     * the chart object itself.
    */
    get legendItemBadgeTemplate() {
        return this.i.legendItemBadgeTemplate;
    }
    set legendItemBadgeTemplate(v) {
        this.i.legendItemBadgeTemplate = v;
    }
    /**
     * Gets or sets whether the pie chart will handle drag interaction and make them avaiilable in its events.
    */
    get isDragInteractionEnabled() {
        return this.i.ce;
    }
    set isDragInteractionEnabled(v) {
        this.i.ce = ensureBool(v);
    }
    /**
     * Gets or sets whether all surface interactions with the plot area should be disabled.
    */
    get isSurfaceInteractionDisabled() {
        return this.i.cf;
    }
    set isSurfaceInteractionDisabled(v) {
        this.i.cf = ensureBool(v);
    }
    /**
     * Gets or sets whether the pie chart should display mock data when data isn't present.
    */
    get shouldDisplayMockData() {
        return this.i.ch;
    }
    set shouldDisplayMockData(v) {
        this.i.ch = ensureBool(v);
    }
    /**
     * Gets or sets whether the pie chart should use a skeleton style for mock data.
    */
    get shouldUseSkeletonStyleForMockData() {
        return this.i.ci;
    }
    set shouldUseSkeletonStyleForMockData(v) {
        this.i.ci = ensureBool(v);
    }
    /**
     * Determines display mode for zero values in the legend.
     * For example, handling zero values as valid slices and providing them with proper appearance settings.
    */
    get legendEmptyValuesMode() {
        return this.i.a1;
    }
    set legendEmptyValuesMode(v) {
        this.i.a1 = ensureEnum(LegendEmptyValuesMode_$type, v);
    }
    /**
     * Sets or gets a function which takes an object that produces a formatted label for displaying in the chart.
    */
    get formatLabel() {
        return this.i.a5;
    }
    set formatLabel(v) {
        this.i.a5 = v;
    }
    /**
     * Sets or gets a function which takes an object that produces a formatted label for displaying in the chart's legend.
    */
    get formatLegendLabel() {
        return this.i.a6;
    }
    set formatLegendLabel(v) {
        this.i.a6 = v;
    }
    /**
     * Gets or sets the scaling value used to affect the pixel density of the control.
     * A higher scaling ratio will produce crisper visuals at the expense of memory.  Lower values will cause the control
     * to appear blurry.
    */
    get pixelScalingRatio() {
        return this.i.df;
    }
    set pixelScalingRatio(v) {
        this.i.df = +v;
    }
    /**
     * Resolved pixel scaling ratio. Unless explicitly overridden by the
     * PieChartBase.PixelScalingRatio property,
     * this one returns the default ratio enforced by device. High resolution devices will initialize this property
     * to a higher value.
    */
    get actualPixelScalingRatio() {
        return this.i.c2;
    }
    set actualPixelScalingRatio(v) {
        this.i.c2 = +v;
    }
    /**
     * Gets or sets which mode to use for selecting slices.
    */
    get selectionMode() {
        return this.i.bk;
    }
    set selectionMode(v) {
        this.i.bk = ensureEnum(SliceSelectionMode_$type, v);
    }
    /**
     * Gets or sets the currently selected data item.  If a different data item is provided the pie chart
     * will select the slice associated with the new item.
    */
    get selectedItem() {
        return this.i.selectedItem;
    }
    set selectedItem(v) {
        this.i.selectedItem = v;
    }
    /**
     * Gets the currently selected data items.  Adding or removing data items from this collection will
     * select or deselect the slices associated with those items.
    */
    get selectedItems() {
        if (this._selectedItems === null) {
            let coll = new IgrObjectCollection();
            let innerColl = this.i.selectedItems;
            if (!innerColl) {
                innerColl = new ObjectCollection_internal(0);
            }
            this._selectedItems = coll._fromInner(innerColl);
            this.i.selectedItems = innerColl;
        }
        return this._selectedItems;
    }
    set selectedItems(v) {
        if (this._selectedItems !== null) {
            this._selectedItems._setSyncTarget(null);
            this._selectedItems = null;
        }
        let coll = new IgrObjectCollection();
        this._selectedItems = coll._fromOuter(v);
        let syncColl = new SyncableObservableCollection$1(Base.$type);
        let innerColl = this.i.selectedItems;
        if (!innerColl) {
            innerColl = new ObjectCollection_internal(0);
        }
        syncColl._inner = innerColl;
        syncColl.clear();
        this._selectedItems._setSyncTarget(syncColl);
        this.i.selectedItems = innerColl;
    }
    /**
     * Manually overrides the style to use for the labels.
    */
    get textStyle() {
        return this.i.fq;
    }
    set textStyle(v) {
        this.i.fq = v;
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        if (this.legend && this.legend.name && this.legend.name == name) {
            return this.legend;
        }
        if (this.labelFormatSpecifiers != null && arrayFindByName(this.labelFormatSpecifiers, name)) {
            return arrayFindByName(this.labelFormatSpecifiers, name);
        }
        if (this.othersLabelFormatSpecifiers != null && arrayFindByName(this.othersLabelFormatSpecifiers, name)) {
            return arrayFindByName(this.othersLabelFormatSpecifiers, name);
        }
        if (this.legendLabelFormatSpecifiers != null && arrayFindByName(this.legendLabelFormatSpecifiers, name)) {
            return arrayFindByName(this.legendLabelFormatSpecifiers, name);
        }
        if (this.legendOthersLabelFormatSpecifiers != null && arrayFindByName(this.legendOthersLabelFormatSpecifiers, name)) {
            return arrayFindByName(this.legendOthersLabelFormatSpecifiers, name);
        }
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("PieChartBase");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    /**
     * Use to force the pie chart to finish any deferred work before printing or evaluating its visual.
     * This should only be called if the visual of the pie chart needs to be synchronously saved or evaluated.
     * Calling this method too often will hinder the performance of the pie chart.
    
    */
    flush() {
        this.i.f0();
    }
    /**
     * Returns the chart visuals expressed as a serialized string.
    
    */
    exportSerializedVisualData() {
        let iv = this.i.d4();
        return (iv);
    }
    /**
     * Simulates a mouse click action at the specified point.
    
    * @param point  * The point to click at.
    */
    simulateLeftClick(point) {
        this.i.g5(toPoint(point));
    }
    /**
     * Invoked by the containing object to provide reference to the container.
    
    * @param container  * Reference to the container.
    */
    provideContainer(container) {
        this.i.provideContainer(container);
    }
    /**
     * Notification from the containing object that the container has been resized.
    
    */
    notifyContainerResized() {
        this.i.notifyContainerResized();
    }
    /**
     * Invoked when the instance is being destroyed.
    
    */
    destroy() {
        this.i.destroy();
    }
    notifySetItem(source_, index, oldItem, newItem) {
        this.i.f9(source_, index, oldItem, newItem);
    }
    /**
     * Manually notifies the pie chart's data source that the data it has bound to has been cleared and needs to be re-examined.
     * This should not be called if the data that the pie chart is bound to is already observable.
    
    * @param source_  * The data source.
    */
    notifyClearItems(source_) {
        this.i.f5(source_);
    }
    notifyInsertItem(source_, index, newItem) {
        this.i.f7(source_, index, newItem);
    }
    notifyRemoveItem(source_, index, oldItem) {
        this.i.f8(source_, index, oldItem);
    }
    /**
     * Assigns data source for the items.
    
    * @param source_  * Array of the data source items.
    */
    setWidgetLevelDataSource(source_) {
        this.i.g4(source_);
    }
    /**
     * Resets items data source.
    
    */
    removeWidgetLevelDataSource() {
        this.i.gv();
    }
    /**
     * Invoked when style is updated.
    
    */
    styleUpdated() {
        this.i.g9();
    }
    /**
     * Raised when the slice's label is clicked.
    */
    get labelClick() {
        return this._labelClick;
    }
    set labelClick(ev) {
        if (this._labelClick_wrapped !== null) {
            this.i.labelClick = delegateRemove(this.i.labelClick, this._labelClick_wrapped);
            this._labelClick_wrapped = null;
            this._labelClick = null;
        }
        this._labelClick = ev;
        this._labelClick_wrapped = (o, e) => {
            let outerArgs = new IgrLabelClickEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeLabelClick) {
                this.beforeLabelClick(this, outerArgs);
            }
            if (this._labelClick) {
                this._labelClick(this, outerArgs);
            }
        };
        this.i.labelClick = delegateCombine(this.i.labelClick, this._labelClick_wrapped);
        ;
    }
    /**
     * Raised when the SelectedItem property is changing.  This event is cancelable.
    */
    get selectedItemChanging() {
        return this._selectedItemChanging;
    }
    set selectedItemChanging(ev) {
        if (this._selectedItemChanging_wrapped !== null) {
            this.i.selectedItemChanging = delegateRemove(this.i.selectedItemChanging, this._selectedItemChanging_wrapped);
            this._selectedItemChanging_wrapped = null;
            this._selectedItemChanging = null;
        }
        this._selectedItemChanging = ev;
        this._selectedItemChanging_wrapped = (o, e) => {
            let outerArgs = new IgrSelectedItemChangingEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeSelectedItemChanging) {
                this.beforeSelectedItemChanging(this, outerArgs);
            }
            if (this._selectedItemChanging) {
                this._selectedItemChanging(this, outerArgs);
            }
        };
        this.i.selectedItemChanging = delegateCombine(this.i.selectedItemChanging, this._selectedItemChanging_wrapped);
        ;
    }
    /**
     * Raised when the SelectedItems collection is changing.  This event is cancelable.
    */
    get selectedItemsChanging() {
        return this._selectedItemsChanging;
    }
    set selectedItemsChanging(ev) {
        if (this._selectedItemsChanging_wrapped !== null) {
            this.i.selectedItemsChanging = delegateRemove(this.i.selectedItemsChanging, this._selectedItemsChanging_wrapped);
            this._selectedItemsChanging_wrapped = null;
            this._selectedItemsChanging = null;
        }
        this._selectedItemsChanging = ev;
        this._selectedItemsChanging_wrapped = (o, e) => {
            let outerArgs = new IgrSelectedItemsChangingEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeSelectedItemsChanging) {
                this.beforeSelectedItemsChanging(this, outerArgs);
            }
            if (this._selectedItemsChanging) {
                this._selectedItemsChanging(this, outerArgs);
            }
        };
        this.i.selectedItemsChanging = delegateCombine(this.i.selectedItemsChanging, this._selectedItemsChanging_wrapped);
        ;
    }
    /**
     * Raised when the SelectedItem property has changed.
    */
    get selectedItemChanged() {
        return this._selectedItemChanged;
    }
    set selectedItemChanged(ev) {
        if (this._selectedItemChanged_wrapped !== null) {
            this.i.selectedItemChanged = delegateRemove(this.i.selectedItemChanged, this._selectedItemChanged_wrapped);
            this._selectedItemChanged_wrapped = null;
            this._selectedItemChanged = null;
        }
        this._selectedItemChanged = ev;
        this._selectedItemChanged_wrapped = (o, e) => {
            let outerArgs = new IgrSelectedItemChangedEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeSelectedItemChanged) {
                this.beforeSelectedItemChanged(this, outerArgs);
            }
            if (this._selectedItemChanged) {
                this._selectedItemChanged(this, outerArgs);
            }
        };
        this.i.selectedItemChanged = delegateCombine(this.i.selectedItemChanged, this._selectedItemChanged_wrapped);
        ;
    }
    /**
     * Raised when the SelectedItems collection has changed.
    */
    get selectedItemsChanged() {
        return this._selectedItemsChanged;
    }
    set selectedItemsChanged(ev) {
        if (this._selectedItemsChanged_wrapped !== null) {
            this.i.selectedItemsChanged = delegateRemove(this.i.selectedItemsChanged, this._selectedItemsChanged_wrapped);
            this._selectedItemsChanged_wrapped = null;
            this._selectedItemsChanged = null;
        }
        this._selectedItemsChanged = ev;
        this._selectedItemsChanged_wrapped = (o, e) => {
            let outerArgs = new IgrSelectedItemsChangedEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeSelectedItemsChanged) {
                this.beforeSelectedItemsChanged(this, outerArgs);
            }
            if (this._selectedItemsChanged) {
                this._selectedItemsChanged(this, outerArgs);
            }
        };
        this.i.selectedItemsChanged = delegateCombine(this.i.selectedItemsChanged, this._selectedItemsChanged_wrapped);
        ;
    }
    /**
     * Raised when the slice is clicked.
    */
    get sliceClick() {
        return this._sliceClick;
    }
    set sliceClick(ev) {
        if (this._sliceClick_wrapped !== null) {
            this.i.sliceClick = delegateRemove(this.i.sliceClick, this._sliceClick_wrapped);
            this._sliceClick_wrapped = null;
            this._sliceClick = null;
        }
        this._sliceClick = ev;
        this._sliceClick_wrapped = (o, e) => {
            let outerArgs = new IgrSliceClickEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeSliceClick) {
                this.beforeSliceClick(this, outerArgs);
            }
            if (this._sliceClick) {
                this._sliceClick(this, outerArgs);
            }
        };
        this.i.sliceClick = delegateCombine(this.i.sliceClick, this._sliceClick_wrapped);
        ;
    }
    /**
     * Raised when a slice is entered by the pointer.
    */
    get sliceEnter() {
        return this._sliceEnter;
    }
    set sliceEnter(ev) {
        if (this._sliceEnter_wrapped !== null) {
            this.i.sliceEnter = delegateRemove(this.i.sliceEnter, this._sliceEnter_wrapped);
            this._sliceEnter_wrapped = null;
            this._sliceEnter = null;
        }
        this._sliceEnter = ev;
        this._sliceEnter_wrapped = (o, e) => {
            let outerArgs = new IgrSliceEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeSliceEnter) {
                this.beforeSliceEnter(this, outerArgs);
            }
            if (this._sliceEnter) {
                this._sliceEnter(this, outerArgs);
            }
        };
        this.i.sliceEnter = delegateCombine(this.i.sliceEnter, this._sliceEnter_wrapped);
        ;
    }
    /**
     * Raised when a slice is left by the pointer;
    */
    get sliceLeave() {
        return this._sliceLeave;
    }
    set sliceLeave(ev) {
        if (this._sliceLeave_wrapped !== null) {
            this.i.sliceLeave = delegateRemove(this.i.sliceLeave, this._sliceLeave_wrapped);
            this._sliceLeave_wrapped = null;
            this._sliceLeave = null;
        }
        this._sliceLeave = ev;
        this._sliceLeave_wrapped = (o, e) => {
            let outerArgs = new IgrSliceEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeSliceLeave) {
                this.beforeSliceLeave(this, outerArgs);
            }
            if (this._sliceLeave) {
                this._sliceLeave(this, outerArgs);
            }
        };
        this.i.sliceLeave = delegateCombine(this.i.sliceLeave, this._sliceLeave_wrapped);
        ;
    }
    /**
     * Raised when a pointer moves over a slice.
    */
    get sliceHover() {
        return this._sliceHover;
    }
    set sliceHover(ev) {
        if (this._sliceHover_wrapped !== null) {
            this.i.sliceHover = delegateRemove(this.i.sliceHover, this._sliceHover_wrapped);
            this._sliceHover_wrapped = null;
            this._sliceHover = null;
        }
        this._sliceHover = ev;
        this._sliceHover_wrapped = (o, e) => {
            let outerArgs = new IgrSliceEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeSliceHover) {
                this.beforeSliceHover(this, outerArgs);
            }
            if (this._sliceHover) {
                this._sliceHover(this, outerArgs);
            }
        };
        this.i.sliceHover = delegateCombine(this.i.sliceHover, this._sliceHover_wrapped);
        ;
    }
}
