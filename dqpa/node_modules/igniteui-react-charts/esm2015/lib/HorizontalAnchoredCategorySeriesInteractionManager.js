/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { Base, Point_$type, markType } from "igniteui-react-core";
import { IHorizontalAnchoredCategorySeriesInteractionManager_$type } from "./IHorizontalAnchoredCategorySeriesInteractionManager";
import { Rect } from "igniteui-react-core";
import { ArrayExtension } from "igniteui-react-core";
import { isNaN_ } from "igniteui-react-core";
/**
 * @hidden
 */
export let HorizontalAnchoredCategorySeriesInteractionManager = /*@__PURE__*/ (() => {
    class HorizontalAnchoredCategorySeriesInteractionManager extends Base {
        d$a(a, b, c, d, e) {
            let f = a.an(a.a0(), b, c, d, a.wh(e), true);
            if (f == null) {
                return null;
            }
            let g = f[0];
            let h = f[1];
            let i = new Array(1);
            let j = new Array(2);
            j[0] = { $type: Point_$type, x: g[0], y: g[2] };
            j[1] = { $type: Point_$type, x: h[0], y: h[2] };
            i[0] = j;
            return i;
        }
        d$b(a, b, c, d, e) {
            let f = a.an(a.a0(), b, c, d, a.wh(e), true);
            if (f == null) {
                return null;
            }
            let g = f[0];
            let h = f[1];
            let i = new Array(1);
            let j = new Array(2);
            j[0] = { $type: Point_$type, x: g[0], y: g[1] };
            j[1] = { $type: Point_$type, x: h[0], y: h[1] };
            i[0] = j;
            return i;
        }
        d$d(a, b, c, d) {
            if (b == null || b.count == 0) {
                return Rect.empty;
            }
            let e = a.v7(c);
            let f = -1;
            let g = a.a0();
            let h = g.ch;
            let i = a.cv.bx.right * 2;
            if (h) {
                f = ArrayExtension.binarySearch$11(Point_$type, b, (j) => (i - e.x) < (i - j.x) ? -1 : ((i - e.x) > (i - j.x) ? 1 : 0));
            }
            else {
                f = ArrayExtension.binarySearch$11(Point_$type, b, (j) => e.x < j.x ? -1 : (e.x > j.x ? 1 : 0));
            }
            if (f < 0) {
                f = ~f;
            }
            if (f < 0) {
                f = 0;
            }
            if (f > b.count - 1) {
                f = b.count - 1;
            }
            let j = f;
            let k = f;
            if (j > 0) {
                j--;
            }
            if (k < b.count - 1) {
                k++;
            }
            let l = b._inner[j].x;
            let m = b._inner[f].x;
            let n = b._inner[k].x;
            let o = Math.abs(l - e.x);
            let p = Math.abs(m - e.x);
            let q = Math.abs(n - e.x);
            let r = d(j);
            let s = d(f);
            let t = d(k);
            let u = r.containsPoint(e);
            let v = s.containsPoint(e);
            let w = t.containsPoint(e);
            if (p <= o && p <= q) {
                if (!h && w) {
                    return t;
                }
                if (h && u) {
                    return r;
                }
                return s;
            }
            if (o <= p && o <= q) {
                if (!h && v) {
                    return s;
                }
                return d(j);
            }
            if (q <= p && q <= o) {
                if (h && v) {
                    return s;
                }
                return d(k);
            }
            return Rect.empty;
        }
        d$c(a, b, c, d, e) {
            if (isNaN_(d.x) || isNaN_(d.y)) {
                return false;
            }
            let f = 0;
            if (b != null) {
                f = b.e6(b.me);
            }
            if ((c.y >= f && c.y <= d.y) || (c.y <= f && c.y >= d.y)) {
                return true;
            }
            return false;
        }
    }
    HorizontalAnchoredCategorySeriesInteractionManager.$t = /*@__PURE__*/ markType(HorizontalAnchoredCategorySeriesInteractionManager, 'HorizontalAnchoredCategorySeriesInteractionManager', Base.$, [IHorizontalAnchoredCategorySeriesInteractionManager_$type]);
    return HorizontalAnchoredCategorySeriesInteractionManager;
})();
