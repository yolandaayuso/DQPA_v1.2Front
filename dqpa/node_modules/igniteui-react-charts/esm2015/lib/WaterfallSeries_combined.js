/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { HorizontalAnchoredCategorySeries } from "./HorizontalAnchoredCategorySeries";
import { Brush } from "igniteui-react-core";
import { DependencyProperty } from "igniteui-react-core";
import { List$1 } from "igniteui-react-core";
import { SeriesLayerPropertyOverlay } from "./SeriesLayerPropertyOverlay";
import { runOn, delegateCombine, markType, markDep, fromEnum } from "igniteui-react-core";
import { Defaults } from "./Defaults";
import { Rect } from "igniteui-react-core";
import { Pool$1 } from "igniteui-react-core";
import { Rectangle } from "igniteui-react-core";
import { ArrayExtension } from "igniteui-react-core";
import { ScalerParams } from "./ScalerParams";
import { ChartSelection } from "./ChartSelection";
import { PropertyMetadata } from "igniteui-react-core";
import { truncate, isNaN_ } from "igniteui-react-core";
import { AnchoredCategorySeriesView } from "./AnchoredCategorySeriesView";
import { BrushUtil } from "igniteui-react-core";
/**
 * @hidden
 */
export let WaterfallSeries = /*@__PURE__*/ (() => {
    class WaterfallSeries extends HorizontalAnchoredCategorySeries {
        bj() {
            return new WaterfallSeries();
        }
        get_f6() {
            return true;
        }
        get_fl() {
            return true;
        }
        ht() {
            let a = super.ht();
            {
                let b = ((() => {
                    let $ret = new SeriesLayerPropertyOverlay();
                    $ret.r = true;
                    $ret.ad = "NegativeBrush";
                    $ret.p = true;
                    $ret.q = true;
                    return $ret;
                })());
                b.valueResolving = delegateCombine(b.valueResolving, runOn(this, this.r0));
                a.add(b);
            }
            {
                let c = ((() => {
                    let $ret = new SeriesLayerPropertyOverlay();
                    $ret.r = true;
                    $ret.ad = "NegativeOutline";
                    $ret.p = true;
                    $ret.q = true;
                    return $ret;
                })());
                c.valueResolving = delegateCombine(c.valueResolving, runOn(this, this.r0));
                a.add(c);
            }
            return a;
        }
        jk() {
            if (!isNaN_(this.jj)) {
                return super.jk();
            }
            return Defaults.h;
        }
        get_fa() {
            return true;
        }
        cs() {
            return new WaterfallSeriesView(this);
        }
        q1(a) {
            super.q1(a);
            this.acw = a;
        }
        constructor() {
            super();
            this.ab = WaterfallSeries.$;
        }
        preferredCategoryMode(a) {
            return 2;
        }
        get_fm() {
            return true;
        }
        r3(a, b) {
            super.r3(a, b);
            this.ac7 = a;
            this.ac8 = b;
        }
        vw() {
            return this.ac7;
        }
        vx() {
            return this.ac8;
        }
        cy() {
            if (this.cz == 0) {
                return 2;
            }
            return super.cy();
        }
        get_ed() {
            return true;
        }
        q9(a, b, c, d) {
            super.q9(a, b, c, d);
            switch (b) {
                case WaterfallSeries.$$p[3]:
                case WaterfallSeries.$$p[2]:
                case WaterfallSeries.$$p[0]:
                case WaterfallSeries.$$p[1]:
                    this.rr(false);
                    break;
            }
        }
        gw(a, b) {
            if (this.gz(a, b)) {
                return true;
            }
            if (this.xh(a, b)) {
                return true;
            }
            return false;
        }
        wn(a) {
            if (this.acw == null || this.acw.dg == null || this.acw.dg.count == 0 || this.xAxis == null) {
                return Rect.empty;
            }
            let b = this.acw.dg;
            let c = this.v7(a);
            let d = -1;
            let e = this.xAxis.ch;
            let f = this.ws.right * 2;
            if (e) {
                d = ArrayExtension.binarySearch$1(Rectangle.$, b, (g) => {
                    let h = this.acw.dn(g);
                    return (f - c.x) < (f - (h.left + h.width / 2)) ? -1 : ((f - c.x) > (f - (h.left + h.width / 2)) ? 1 : 0);
                });
            }
            else {
                d = ArrayExtension.binarySearch$1(Rectangle.$, b, (g) => {
                    let h = this.acw.dn(g);
                    return c.x < (h.left + h.width / 2) ? -1 : (c.x > (h.left + h.width / 2) ? 1 : 0);
                });
            }
            if (d < 0) {
                d = ~d;
                d--;
            }
            if (d < 0) {
                d = 0;
            }
            if (d > b.count - 1) {
                d = b.count - 1;
            }
            let g = d;
            let h = d;
            if (g < 0) {
                g--;
            }
            if (h < b.count - 1) {
                h++;
            }
            let i = this.ac9(g);
            let j = this.ac9(d);
            let k = this.ac9(h);
            let l = i.left + i.width / 2;
            let m = j.left + j.width / 2;
            let n = k.left + k.width / 2;
            let o = Math.abs(l - c.x);
            let p = Math.abs(m - c.x);
            let q = Math.abs(n - c.x);
            let r = i.containsPoint(c);
            let s = j.containsPoint(c);
            let t = k.containsPoint(c);
            if (p <= o && p <= q) {
                if (!e && t) {
                    return k;
                }
                if (e && r) {
                    return i;
                }
                return j;
            }
            if (o <= p && o <= q) {
                if (!e && s) {
                    return j;
                }
                return i;
            }
            if (q <= p && q <= o) {
                if (e && s) {
                    return j;
                }
                return k;
            }
            return Rect.empty;
        }
        ac9(a) {
            return this.acw.dm(a);
        }
        y4() {
            return 1;
        }
        o5(a, b) {
            super.o5(a, b);
            this.acw.dg.count = 0;
        }
        get_abb() {
            return 1;
        }
        iw() {
            return this.acd.k8(this.cv.by, this.cv.bx, this.getEffectiveViewport1(this.cv));
        }
        aak(a, b) {
            let c = b;
            super.aak(a, b);
            let d = b.by;
            let e = b.bx;
            let f = this.getEffectiveViewport1(b);
            let g = this.acd.k8(d, e, f);
            let h = this.acx;
            let i = this.acy;
            let j;
            let k = this.aa9(b);
            let l = NaN;
            let m = c.dg;
            let n;
            let o = 0;
            this.y2.a2(this, this.zm(), runOn(this, this.ym), this.zv(b), this.zw(b));
            this.y2.r = this.acx;
            this.y2.s = this.acy;
            this.y2.k = this.acx;
            this.y2.l = this.acy;
            let p = false;
            let q = this.y2.b;
            if (q != null) {
                p = true;
            }
            let r = this.acd.cn;
            let s = this.valueColumn.count;
            let t = a.f;
            let u = this.acd;
            let v = new ScalerParams(0, d, e, this.acd.ch, f);
            let w = this.u9;
            let x = this.ac7;
            let y = this.vd;
            let z = this.ac8 || y;
            if (a.f.count > 0) {
                j = a.f._inner[0][0] - 0.5 * g;
                let aa = a.f._inner[0][1];
                if (!isNaN_(aa)) {
                    if (aa > k) {
                        n = m.item(o);
                        o++;
                        c.dl(n, j, k);
                        n.width = g;
                        n.height = Math.abs(k - aa);
                        this.y2.ak = x;
                        this.y2.ag = x;
                        this.y2.al = z;
                        this.y2.ah = z;
                        this.y2.f = true;
                        let ab = this.y2.aw(s, 0)[0];
                        if (r && a.m != null && 0 < a.m.count) {
                            ab = truncate(Math.round(a.m._inner[0]));
                        }
                        if (p) {
                            this.aag(t, 0, s, u, v, b.q, ab);
                        }
                        this.y2.ad(n, false, false, false, false);
                        n.ap = this.y2.k;
                        n.aq = this.y2.l;
                    }
                    else {
                        n = m.item(o);
                        o++;
                        c.dl(n, j, aa);
                        n.width = g;
                        n.height = Math.abs(aa - k);
                        this.y2.ak = w;
                        this.y2.ag = w;
                        this.y2.al = y;
                        this.y2.ah = y;
                        this.y2.f = false;
                        let ac = this.y2.aw(s, o)[0];
                        if (r && a.m != null && o >= 0 && o < a.m.count) {
                            ac = truncate(Math.round(a.m._inner[o]));
                        }
                        if (p) {
                            this.aag(t, 0, s, u, v, b.q, ac);
                        }
                        this.y2.ad(n, false, false, false, false);
                        n.ap = this.y2.k;
                        n.aq = this.y2.l;
                    }
                    l = aa;
                }
                else {
                    l = k;
                }
            }
            for (let ad = 1; ad < a.f.count; ++ad) {
                let ae = a.f._inner[ad];
                j = a.f._inner[ad][0] - 0.5 * g;
                let af = ae[1];
                if (!isNaN_(af)) {
                    n = m.item(o);
                    o++;
                    c.dl(n, j, Math.min(l, af));
                    n.width = g;
                    n.height = Math.abs(l - af);
                    this.y2.ak = w;
                    this.y2.ag = w;
                    this.y2.al = y;
                    this.y2.ah = y;
                    this.y2.f = false;
                    let ag = this.y2.aw(s, o)[0];
                    if (r && a.m != null && o >= 0 && o < a.m.count) {
                        ag = truncate(Math.round(a.m._inner[o]));
                    }
                    if (l > af) {
                        if (p) {
                            this.aag(t, ad, s, u, v, b.q, ag);
                        }
                    }
                    else {
                        this.y2.ak = x;
                        this.y2.ag = x;
                        this.y2.al = z;
                        this.y2.ah = z;
                        this.y2.f = true;
                        if (p) {
                            this.aag(t, ad, s, u, v, b.q, ag);
                        }
                    }
                    this.y2.ad(n, false, false, false, false);
                    n.ap = this.y2.k;
                    n.aq = this.y2.l;
                    l = af;
                }
            }
            m.count = o;
            b.c3(a);
        }
        p4(a, b, c) {
            this.aac(a, b, c, this.yt, 1);
        }
        ak(a, b) {
            let c = new List$1(ChartSelection.$, 0);
            this.p4(a, c, b);
            return c.toArray();
        }
        aa4(a, b, c) {
            if (c == 0) {
                return 0 < b && a < this.valueColumn.item(c);
            }
            else {
                let d = this.valueColumn.item(c - 1);
                let e = Math.min(d, this.valueColumn.item(c));
                let f = Math.max(d, this.valueColumn.item(c));
                return e < b && a < f;
            }
        }
        get useHighMarkerFidelity() {
            return this.zq;
        }
    }
    WaterfallSeries.$t = /*@__PURE__*/ markType(WaterfallSeries, 'WaterfallSeries', HorizontalAnchoredCategorySeries.$);
    WaterfallSeries.$$p = /*@__PURE__*/ markDep(DependencyProperty, PropertyMetadata, WaterfallSeries, 'raisePropertyChanged', ['NegativeBrush:ac7:ac3', [Brush.$, null], 'NegativeOutline:ac8:ac4', [Brush.$, null], 'RadiusX:acx:ac5', [1, 0], 'RadiusY:acy:ac6', [1, 0]]);
    return WaterfallSeries;
})();
/**
 * @hidden
 */
export let WaterfallSeriesView = /*@__PURE__*/ (() => {
    class WaterfallSeriesView extends AnchoredCategorySeriesView {
        au() {
            super.au();
            this.dh = new List$1(Rectangle.$, 0);
            if (!this.q) {
                this.df.xa = Defaults.c;
                this.df.jp = Defaults.i;
                this.df.ac7 = Defaults.ah;
                this.df.ac8 = Defaults.ai;
            }
        }
        constructor(a) {
            super(a);
            this.df = null;
            this.dh = null;
            this.dp = new Rectangle();
            this.dg = null;
            this.df = a;
            this.dg = ((() => {
                let $ret = new Pool$1(Rectangle.$);
                $ret.create = runOn(this, this.dq);
                $ret.activate = runOn(this, this.di);
                $ret.disactivate = runOn(this, this.dk);
                $ret.destroy = runOn(this, this.dj);
                return $ret;
            })());
        }
        dq() {
            let a = new Rectangle();
            this.dh.add(a);
            a._visibility = 1;
            return a;
        }
        di(a) {
            a._visibility = 0;
        }
        dk(a) {
            a._visibility = 1;
        }
        dj(a) {
            this.dh.remove(a);
        }
        dl(a, b, c) {
            let d = false;
            if (a.o != c) {
                d = true;
                a.o = c;
            }
            if (a.n != b) {
                d = true;
                a.n = b;
            }
            if (d) {
                this.as();
            }
        }
        ac(a) {
            return this.dh._inner[a];
        }
        ab(a) {
            let b = this.dh._inner[a];
            this.dp._visibility = b._visibility;
            this.dp.n = b.n;
            this.dp.o = b.o;
            this.dp.width = b.width;
            this.dp.height = b.height;
            let c = this.bs(a);
            this.dp._fill = c;
            this.dp._stroke = c;
            this.dp.ad = this.e.ie + 3;
            return this.dp;
        }
        a8(a, b) {
            super.a8(a, b);
            if (a.d) {
                for (let c = 0; c < this.dh.count; c++) {
                    let d = this.aa(c, b);
                    this.bf(d, c, b);
                    a.w(d);
                }
            }
        }
        an(a) {
            super.an(a);
            let b = 0;
            let c = new List$1(Rectangle.$, 0);
            for (let d of fromEnum(this.dg.a)) {
                c.add(d);
            }
            c.aa((e, f) => {
                if (e.n < f.n) {
                    return -1;
                }
                else if (e.n > f.n) {
                    return 1;
                }
                else {
                    return 0;
                }
            });
            for (let e of fromEnum(c)) {
                let f = "Negative";
                if (BrushUtil.d(e._fill, this.e.u9)) {
                    f = "Positive";
                }
                this.e.bc.exportRectangleData(a, e, "column" + b, ["Main", f]);
            }
            b++;
        }
        dm(a) {
            let b = this.dg.item(a);
            return new Rect(0, b.n, b.o, b.width, b.height);
        }
        dn(a) {
            return new Rect(0, a.n, a.o, a.width, a.height);
        }
    }
    WaterfallSeriesView.$t = /*@__PURE__*/ markType(WaterfallSeriesView, 'WaterfallSeriesView', AnchoredCategorySeriesView.$);
    return WaterfallSeriesView;
})();
