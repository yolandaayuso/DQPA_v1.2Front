/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { Base, Number_$type, Point_$type, fromEnum, markType, getEnumerator } from "igniteui-react-core";
import { Rect } from "igniteui-react-core";
import { Clipper } from "igniteui-react-core";
import { AngleRadiusPair } from "./AngleRadiusPair";
import { List$1 } from "igniteui-react-core";
import { ViewportUtils } from "./ViewportUtils";
import { SpiralFlattener } from "igniteui-react-core";
import { isNaN_, isInfinity } from "igniteui-react-core";
/**
 * @hidden
 */
export let PolarLinePlanner = /*@__PURE__*/ (() => {
    class PolarLinePlanner extends Base {
        constructor() {
            super(...arguments);
            this.f = false;
            this.b = 0;
            this.m = null;
            this.n = null;
            this.o = null;
            this.p = null;
            this.l = 0;
            this.q = 0;
            this.aa = null;
            this.z = null;
            this.ab = null;
            this.a = null;
            this.c = false;
            this.d = false;
            this.i = null;
        }
        get ad() {
            return this.aa;
        }
        set ad(a) {
            this.aa = a;
        }
        get ac() {
            return this.z;
        }
        set ac(a) {
            this.z = a;
        }
        get ae() {
            return this.ab;
        }
        set ae(a) {
            this.ab = a;
        }
        g() {
            if (this.m == null || this.n == null || this.o == null || this.p == null || Rect.l_op_Equality(this.ad, Rect.empty) || Rect.l_op_Equality(this.ae, Rect.empty)) {
                return false;
            }
            return true;
        }
        k(a, b, c, d) {
            let e = a(d) - a(c);
            let f = b(d) - b(c);
            return e * e + f * f;
        }
        h(a) {
            let b = new List$1(AngleRadiusPair.$, 0);
            let c = this.l * this.l;
            let d;
            if (a != null) {
                d = a;
            }
            else {
                let e = new List$1(Number_$type, 0);
                for (let f = 0; f < this.q; f++) {
                    e.add(f);
                }
                d = e;
            }
            let g = getEnumerator(d);
            let h = true;
            h = g.moveNext();
            let i = 0;
            if (h) {
                i = g.current;
            }
            while (h) {
                let j = i;
                h = g.moveNext();
                i = g.current;
                while (h && this.k(this.o, this.p, j, i) < c) {
                    h = g.moveNext();
                    i = g.current;
                }
                let k = new AngleRadiusPair();
                k.c = j;
                if (!this.f) {
                    k.a = this.m(j);
                    k.b = this.n(j);
                }
                b.add(k);
            }
            return b;
        }
        v(a) {
            for (let b of fromEnum(this.h(a))) {
                if (isNaN_(b.a) || isInfinity(b.a) || isNaN_(b.b) || isInfinity(b.b)) {
                    this.s({ $type: Point_$type, x: NaN, y: NaN });
                    continue;
                }
                this.s({ $type: Point_$type, x: this.o(b.c), y: this.p(b.c) });
            }
        }
        j() {
            return Math.pow(this.l / (Math.max(this.ad.width / this.ae.width, this.ad.height / this.ae.height)), 2);
        }
        r(a, b) {
            let c = 0.5 + b * Math.cos(a);
            let d = 0.5 + b * Math.sin(a);
            c = ViewportUtils.e(c, this.ab, this.aa, this.z);
            d = ViewportUtils.i(d, this.ab, this.aa, this.z);
            this.s({ $type: Point_$type, x: c, y: d });
        }
        y(a) {
            let b = this.j();
            let c = this.h(a);
            let d = c.item(0).a;
            let e = c.item(0).b;
            let f = c.item(0).c;
            for (let g = 1; g < c.count; g++) {
                let h = c.item(g).a;
                let i = c.item(g).b;
                let j = c.item(g).c;
                if (isNaN_(h) || isInfinity(h) || isNaN_(i) || isInfinity(i)) {
                    this.s({ $type: Point_$type, x: NaN, y: NaN });
                    if (this.b != 0) {
                        g++;
                        if (g < c.count) {
                            d = c.item(g).a;
                            e = c.item(g).b;
                        }
                    }
                    continue;
                }
                this.t(h, i, d, e, g, b, f > j);
                d = h;
                e = i;
                f = j;
            }
        }
        t(a, b, c, d, e, f, g) {
            let h = false;
            if ((a < c && !g) || (a > c && g)) {
                h = true;
                let i = a;
                a = c;
                c = i;
                i = b;
                b = d;
                d = i;
            }
            let j = SpiralFlattener.a(c, d, a, b, f);
            if (h) {
                let k = new List$1(Number_$type, 2, j.count);
                for (let l = j.count - 1; l >= 0; l--) {
                    k.add(j._inner[l]);
                }
                j = k;
            }
            for (let m = 0; m < j.count; m++) {
                let n = j._inner[m];
                let o = c + n * (a - c);
                let p = d + n * (b - d);
                this.r(o, p);
            }
        }
        u(a) {
            let b = this.ad.top - 10;
            let c = this.ad.bottom + 10;
            let d = this.ad.left - 10;
            let e = this.ad.right + 10;
            if (this.a == null) {
                this.a = ((() => {
                    let $ret = new Clipper(1, d, c, e, b, this.d);
                    $ret.i = a;
                    return $ret;
                })());
            }
        }
        e(a) {
            return !isNaN_(a.x) && !isNaN_(a.y) && !isInfinity(a.x) && !isInfinity(a.y);
        }
        s(a) {
            if (this.b == 0 && !this.e(a)) {
                return;
            }
            if (this.c) {
                this.i.add(a);
            }
            else {
                this.a.j(a);
            }
        }
        w(a) {
            this.x(null, null);
        }
        x(a, b) {
            this.i = a;
            if (!this.g()) {
                return;
            }
            if (this.q > 1) {
                this.u(a);
                if (this.f) {
                    this.v(b);
                }
                else {
                    this.y(b);
                }
                this.a.i = null;
            }
        }
    }
    PolarLinePlanner.$t = /*@__PURE__*/ markType(PolarLinePlanner, 'PolarLinePlanner');
    return PolarLinePlanner;
})();
