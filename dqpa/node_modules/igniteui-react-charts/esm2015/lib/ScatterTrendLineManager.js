/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { TrendLineManagerBase$1 } from "./TrendLineManagerBase$1";
import { Point_$type, fromEnum, markType } from "igniteui-react-core";
import { List$1 } from "igniteui-react-core";
import { TrendFitCalculator } from "./TrendFitCalculator";
import { TrendAverageCalculator } from "./TrendAverageCalculator";
import { isNaN_ } from "igniteui-react-core";
/**
 * @hidden
 */
export let ScatterTrendLineManager = /*@__PURE__*/ (() => {
    class ScatterTrendLineManager extends TrendLineManagerBase$1 {
        constructor() {
            super(Point_$type);
        }
        get_g$a() {
            return 4;
        }
        get g$a() {
            return this.get_g$a();
        }
        h(a, b, c, d, e, f, g, h, i, j, k) {
            let l = j;
            let m = k;
            let n = new List$1(Point_$type, 0);
            let o = 0;
            if (c != null) {
                o = c.count;
            }
            if (d != null) {
                o = Math.min(o, d.count);
            }
            if (!h.j.isEmpty && !h.i.isEmpty) {
                if (b == 0) {
                    this.a = null;
                    this.d.clear();
                }
                else if (this.c(b)) {
                    this.d.clear();
                    this.a = TrendFitCalculator.a(n, b, h, this.a, o, (p) => c.item(p), (p) => d.item(p), f, g, l, m);
                }
                else if (this.b(b)) {
                    this.a = null;
                    this.d.clear();
                    TrendAverageCalculator.c(b, this.d, c, d, e);
                    for (let p of fromEnum(this.d)) {
                        let q = f(p.x);
                        let r = g(p.y);
                        if (!isNaN_(q) && !isNaN_(r)) {
                            n.add({ $type: Point_$type, x: q, y: r });
                        }
                    }
                }
                this.f(n, h, a, i);
            }
        }
    }
    ScatterTrendLineManager.$t = /*@__PURE__*/ markType(ScatterTrendLineManager, 'ScatterTrendLineManager', /*@__PURE__*/ TrendLineManagerBase$1.$.specialize(Point_$type));
    return ScatterTrendLineManager;
})();
