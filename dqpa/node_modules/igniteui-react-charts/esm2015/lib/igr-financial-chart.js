import * as React from 'react';
import * as ReactDOM from 'react-dom';
import { ReactRenderer, ReactWrapper } from "igniteui-react-core";
import { TypeRegistrar } from "igniteui-react-core";
import { FinancialChart } from './FinancialChart';
import { FinancialChartType_$type } from './FinancialChartType';
import { fromBrushCollection, toBrushCollection, brushToString, stringToBrush, ensureEnum, ensureBool } from "igniteui-react-core";
import { IgrXYChart } from './igr-xy-chart';
import { DataChartStylingDefaults } from './DataChartStylingDefaults';
import { DataSeriesType } from "igniteui-react-core";
import { IgrDataContext } from "igniteui-react-core";
import { FinancialChartVolumeType_$type } from './FinancialChartVolumeType';
import { FinancialChartXAxisMode, FinancialChartXAxisMode_$type } from './FinancialChartXAxisMode';
import { FinancialChartYAxisMode, FinancialChartYAxisMode_$type } from './FinancialChartYAxisMode';
import { HorizontalAlignment_$type } from "igniteui-react-core";
import { FinancialChartZoomSliderType_$type } from './FinancialChartZoomSliderType';
import { IgrFinancialChartDefaultTemplates } from './igr-financial-chart-default-templates';
import { delegateCombine, delegateRemove } from "igniteui-react-core";
import { IgrFinancialIndicatorTypeCollection } from './igr-financial-indicator-type-collection';
import { FinancialIndicatorTypeCollection as FinancialIndicatorTypeCollection_internal } from './FinancialIndicatorTypeCollection';
import { SyncableObservableCollection$1 } from "igniteui-react-core";
import { FinancialIndicatorType_$type } from './FinancialIndicatorType';
import { IgrFinancialOverlayTypeCollection } from './igr-financial-overlay-type-collection';
import { FinancialOverlayTypeCollection as FinancialOverlayTypeCollection_internal } from './FinancialOverlayTypeCollection';
import { FinancialOverlayType_$type } from './FinancialOverlayType';
import { IgrIndicatorDisplayTypeCollection } from './igr-indicator-display-type-collection';
import { IndicatorDisplayTypeCollection as IndicatorDisplayTypeCollection_internal } from './IndicatorDisplayTypeCollection';
import { IndicatorDisplayType_$type } from './IndicatorDisplayType';
import { IgrFinancialChartRangeSelectorOptionCollection } from './igr-financial-chart-range-selector-option-collection';
import { FinancialChartRangeSelectorOptionCollection as FinancialChartRangeSelectorOptionCollection_internal } from './FinancialChartRangeSelectorOptionCollection';
import { FinancialChartRangeSelectorOption_$type } from './FinancialChartRangeSelectorOption';
import { IgrFinancialChartCustomIndicatorArgs } from './igr-financial-chart-custom-indicator-args';
import { CustomIndicatorNameCollection as CustomIndicatorNameCollection_internal } from './CustomIndicatorNameCollection';
import { IgrCustomIndicatorNameCollection } from './igr-custom-indicator-name-collection';
import { String_$type } from "igniteui-react-core";
import { IgrTemplateContainer } from "igniteui-react-core";
let fg = window && window.CSS && window.CSS.supports &&
    /*@__PURE__*/ window.CSS.supports("display", "grid");
let financialChartToolbarStyle = {
    gridRow: 1,
    msGridRow: 1
};
let financialChartPriceStyle = {
    gridRow: 3,
    msGridRow: 3
};
let financialChartIndicatorsStyle = {
    gridRow: 4,
    msGridRow: 4
};
let financialChartVolumeStyle = {
    gridRow: 5,
    msGridRow: 5
};
let financialChartZoomSliderStyle = {
    gridRow: 6,
    msGridRow: 6
};
let financialChartMainGridStyle = {
    height: '100%',
    width: '100%',
    textAlign: 'left',
    display: fg ? 'grid' : '-ms-grid',
    msGridColumns: '100%'
};
let financialChartLegendStyle = {
    gridRow: 2,
    msGridRow: 2
};
export class IgrFinancialChart extends IgrXYChart {
    render() {
        let outerChildren = [];
        let children = [
            React.createElement('div', {
                key: 'financialChartToolbarArea',
                className: 'financialChartToolbarArea',
                style: financialChartToolbarStyle,
                ref: this._toolbarRef
            }, React.createElement(IgrTemplateContainer, {
                ref: this._toolTemplateRef,
            })),
            React.createElement('div', { key: 'financialChartLegend', className: 'financialChartLegend', style: financialChartLegendStyle }),
            React.createElement('div', { key: 'financialChartPrice', className: 'financialChartPrice', style: financialChartPriceStyle }),
            React.createElement('div', { key: 'financialChartIndicators', className: 'financialChartIndicators', style: financialChartIndicatorsStyle }),
            React.createElement('div', { key: 'financialChartVolume', className: 'financialChartVolume', style: financialChartVolumeStyle }),
            React.createElement('div', { key: 'financialChartZoomSlider', className: 'financialChartZoomSlider', style: financialChartZoomSliderStyle })
        ];
        if (this._sliderPortal) {
            children.push(this._sliderPortal);
        }
        if (this._currentTooltips && this._currentTooltips.length > 0) {
            for (let i = 0; i < this._currentTooltips.length; i++) {
                let t = this._currentTooltips[i];
                if (this._activeTooltipElements.has(t)) {
                    let active = this._activeTooltipElements.get(t);
                    outerChildren.push(active);
                }
                else {
                    if (!TypeRegistrar.isRegistered("IgrTooltipContainer")) {
                        continue;
                    }
                    let Tooltip = TypeRegistrar.get("IgrTooltipContainer");
                    let tEle = React.createElement(Tooltip, {
                        ref: this._tooltipRef,
                        key: this._currentTooltips[i].key,
                        owner: this._currentTooltips[i]
                    });
                    let portal = ReactDOM.createPortal(tEle, t, this._currentTooltips[i].key);
                    this._activeTooltipElements.set(t, portal);
                    outerChildren.push(portal);
                }
            }
        }
        let mainGrid = React.createElement('div', {
            key: 'financialChartMainGrid',
            className: 'financialChartMainGrid',
            style: financialChartMainGridStyle,
            children: children,
            ref: this._mainGridRef,
        });
        outerChildren.splice(0, 0, mainGrid);
        let mainDiv = React.createElement('div', {
            className: "ig-financial-chart igr-financial-chart",
            key: "financialChartMainDiv",
            children: outerChildren,
            ref: this._mainRef
        });
        return mainDiv;
    }
    _tooltipRef(t) {
        //console.log(t);
        if (t === null) {
            return;
        }
        if (t.currentOwner &&
            t.currentOwner.tooltipTemplate) {
            t.template = t.currentOwner.tooltipTemplate;
        }
        this._activeTooltips.set(t.currentOwner, t);
    }
    _toolbarRef(t) {
        this._toolbarElement = t;
    }
    _toolTemplateRef(t) {
        this._toolbarTemplateComponent = t;
    }
    _mainGridRef(t) {
        this._mainGridElement = t;
    }
    _mainRef(t) {
        this._mainElement = t;
        this._container = t;
        if (!t) {
            return;
        }
        this._wrapper.updateRoot(this._wrapper.getWrapper(this._container));
    }
    set height(value) {
        this._height = value;
        if (this._mainElement) {
            this._mainElement.style.height = value;
            this._chart.notifyResized();
        }
    }
    get height() {
        return this._height;
    }
    set width(value) {
        this._width = value;
        if (this._mainElement) {
            this._mainElement.style.height = value;
            this._chart.notifyResized();
        }
    }
    get width() {
        return this._width;
    }
    get rangeSelectorTemplate() {
        return this._rangeSelectorTemplate;
    }
    set rangeSelectorTemplate(value) {
        this._rangeSelectorTemplate = value;
    }
    get chartTypePickerTemplate() {
        return this._chartTypePickerTemplate;
    }
    set chartTypePickerTemplate(value) {
        this._chartTypePickerTemplate = value;
    }
    get indicatorMenuTemplate() {
        return this._indicatorMenuTemplate;
    }
    set indicatorMenuTemplate(value) {
        this._indicatorMenuTemplate = value;
    }
    get toolbarTemplate() {
        return this._toolbarTemplate;
    }
    set toolbarTemplate(value) {
        this._toolbarTemplate = value;
    }
    get chartTemplate() {
        return this._chartTemplate;
    }
    set chartTemplate(value) {
        this._chartTemplate = value;
    }
    constructor(props) {
        super(props);
        this._wrapper = null;
        this._initialized = false;
        this._toolbarElement = null;
        this._dataSource = null;
        this._defaultTooltips = null;
        this._mounted = false;
        this._dynamicContent = {};
        this._uniqueTooltipId = 0;
        this._xAxisBreaks = null;
        this._indicatorTypes = null;
        this._overlayTypes = null;
        this._indicatorDisplayTypes = null;
        this._rangeSelectorOptions = null;
        this._customIndicatorNames = null;
        this._applyCustomIndicators = null;
        this._applyCustomIndicators_wrapped = null;
        this._toolTemplateRef = this._toolTemplateRef.bind(this);
        this._tooltipRef = this._tooltipRef.bind(this);
        this._mainGridRef = this._mainGridRef.bind(this);
        this._mainRef = this._mainRef.bind(this);
        this._toolbarRef = this._toolbarRef.bind(this);
        this._activeTooltipElements = new Map();
        this._activeTooltips = new Map();
        this._currentTooltips = [];
        this.onDocumentClick = this.onDocumentClick.bind(this);
        if (document) {
            this._container = document.createElement("div");
            this._container.style.display = "block";
            this._container.style.width = "100%";
            this._container.style.height = "100%";
            document.addEventListener("click", this.onDocumentClick);
        }
        var root;
        root = this._container;
        if (this._container != null) {
            root = this._container;
        }
        var ren = new ReactRenderer(root, document, true, DataChartStylingDefaults);
        this._wrapper = ren;
        var chart = this.i;
        this._chart = chart;
        if (chart.xAxis) {
            this.rewrapAxis(chart.xAxis);
        }
        if (chart.yAxis) {
            this.rewrapAxis(chart.yAxis);
        }
        if (chart.volumeAxis) {
            this.rewrapAxis(chart.volumeAxis);
        }
        if (chart.volumeXAxis) {
            this.rewrapAxis(chart.volumeXAxis);
        }
        if (chart.indicatorAxis) {
            this.rewrapAxis(chart.indicatorAxis);
        }
        if (chart.indicatorXAxis) {
            this.rewrapAxis(chart.indicatorXAxis);
        }
        if (chart.zoomSliderAxis) {
            this.rewrapAxis(chart.zoomSliderAxis);
        }
        if (chart.zoomSliderXAxis) {
            this.rewrapAxis(chart.zoomSliderXAxis);
        }
        chart.provideContainer(ren);
        this.bindData();
        chart.notifyResized();
        ren.addSizeWatcher(() => {
            this._checkToolbarSize();
            this._chart.notifyResized();
        });
        this._initialized = true;
    }
    _checkToolbarSize() {
        if (this._toolbarElement) {
            let start = this._toolbarElement;
            if (start.children.length == 1) {
                start = start.children[0];
            }
            if (start.children.length == 1) {
                start = start.children[0];
            }
            let toolbarRoot = start.querySelector(".financialChartToolbar");
            let rootRect = toolbarRoot.getBoundingClientRect();
            let hideRemaining = false;
            for (let i = 0; i < toolbarRoot.children.length; i++) {
                let child = toolbarRoot.children[i];
                if (child.nodeType == Node.ELEMENT_NODE) {
                    if (!hideRemaining) {
                        child.style.display = "";
                    }
                    let childRect = child.getBoundingClientRect();
                    if (hideRemaining ||
                        childRect.left + childRect.width >
                            rootRect.left + rootRect.width) {
                        child.style.display = "none";
                        hideRemaining = true;
                    }
                    else {
                        child.style.display = "";
                    }
                }
            }
        }
    }
    destroy() {
        this._chart.destroy();
        this._wrapper.destroy();
        if (document) {
            document.removeEventListener("click", this.onDocumentClick);
        }
    }
    componentWillUnmount() {
        this._mounted = false;
    }
    onDocumentClick(ev) {
        if (this._mounted) {
            this._chart.onDocumentClick(ev);
        }
    }
    rewrapAxis(axis) {
        let axisName = axis.$type.name;
        let componentName = "Igr" + axisName;
        if (TypeRegistrar.isRegistered(componentName)) {
            let x = TypeRegistrar.create(componentName);
            x._implementation = axis;
            axis.externalObject = x;
        }
        else {
            throw new Error("Axis type not loaded: " + componentName);
        }
    }
    createImplementation() {
        return new FinancialChart();
    }
    get i() {
        return this._implementation;
    }
    createSeriesComponent(type) {
        if (TypeRegistrar.isRegistered(type)) {
            let s = TypeRegistrar.create(type);
            s.owner = this;
            return s;
        }
        else {
            //we shouldn't get here, hopefully.
            throw Error("series type not loaded: " + type);
        }
    }
    createIndicator(typeName) {
        return this.createSeriesComponent("Igr" + typeName);
    }
    createOverlay(typeName) {
        return this.createSeriesComponent("Igr" + typeName);
    }
    createSeries(type) {
        switch (type) {
            case DataSeriesType.Area:
                return this.createSeriesComponent('IgrAreaSeries');
            case DataSeriesType.Column:
                return this.createSeriesComponent('IgrColumnSeries');
            case DataSeriesType.Line:
                return this.createSeriesComponent('IgrLineSeries');
            case DataSeriesType.FinancialPrice:
                return this.createSeriesComponent('IgrFinancialPriceSeries');
            case DataSeriesType.ItemToolTipLayer:
                return this.createSeriesComponent('IgrItemToolTipLayer');
            case DataSeriesType.CategoryToolTipLayer:
                return this.createSeriesComponent('IgrCategoryToolTipLayer');
            case DataSeriesType.CrosshairLayer:
                return this.createSeriesComponent('IgrCrosshairLayer');
            case DataSeriesType.FinalValueLayer:
                return this.createSeriesComponent('IgrFinalValueLayer');
            case DataSeriesType.CalloutLayer:
                return this.createSeriesComponent('IgrCalloutLayer');
            case DataSeriesType.DataToolTipLayer:
                return this.createSeriesComponent('IgrDataToolTipLayer');
            default:
                return this.createSeriesComponent('IgrColumnSeries');
        }
    }
    createXAxis(type) {
        switch (type) {
            case FinancialChartXAxisMode.Ordinal:
                if (TypeRegistrar.isRegistered("IgrOrdinalTimeXAxis")) {
                    return TypeRegistrar.create("IgrOrdinalTimeXAxis");
                }
                else if (TypeRegistrar.isRegistered("IgrTimeXAxis")) {
                    return TypeRegistrar.create("IgrTimeXAxis");
                }
                else {
                    throw new Error("not valid axes components loaded");
                }
            case FinancialChartXAxisMode.Time:
                if (TypeRegistrar.isRegistered("IgrTimeXAxis")) {
                    return TypeRegistrar.create("IgrTimeXAxis");
                }
                else if (TypeRegistrar.isRegistered("IgrOrdinalTimeXAxis")) {
                    return TypeRegistrar.create("IgrOrdinalTimeXAxis");
                }
                else {
                    throw new Error("not valid axes components loaded");
                }
        }
    }
    createYAxis(type) {
        switch (type) {
            case FinancialChartYAxisMode.Numeric:
                if (TypeRegistrar.isRegistered("IgrNumericYAxis")) {
                    return TypeRegistrar.create("IgrNumericYAxis");
                }
                else if (TypeRegistrar.isRegistered("IgrPercentChangeYAxis")) {
                    return TypeRegistrar.create("IgrPercentChangeYAxis");
                }
                else {
                    throw new Error("not valid axes components loaded");
                }
            case FinancialChartYAxisMode.PercentChange:
                if (TypeRegistrar.isRegistered("IgrPercentChangeYAxis")) {
                    return TypeRegistrar.create("IgrPercentChangeYAxis");
                }
                else if (TypeRegistrar.isRegistered("IgrNumericYAxis")) {
                    return TypeRegistrar.create("IgrNumericYAxis");
                }
                else {
                    throw new Error("not valid axes components loaded");
                }
        }
    }
    set dataSource(value) {
        this._dataSource = value;
        this.bindData();
    }
    get dataSource() {
        return this._dataSource;
    }
    bindData() {
        if (this._chart != null && this._chart !== undefined) {
            this._chart.itemsSource = this._dataSource;
        }
    }
    componentDidMount() {
        super.componentDidMount();
        if (this._mainElement) {
            if (this._width) {
                this._mainElement.style.width = this._width;
            }
            if (this._height) {
                this._mainElement.style.height = this._height;
            }
        }
        this.initializeContent();
        this._chart.notifyResized();
        this._mounted = true;
    }
    initializeContent() {
        if (TypeRegistrar.isRegistered("IgrDataChartDefaultTooltips")) {
            let d = TypeRegistrar.create("IgrDataChartDefaultTooltips");
            this._defaultTooltips = d;
            this._onDefaultTooltipsReady(d);
            //this._container.appendChild(cr.location.nativeElement);
        }
        let context = this._chart.getContext();
        if (!this._defaultTemplates) {
            this._defaultTemplates = new IgrFinancialChartDefaultTemplates(this._mainElement);
        }
        let toolbarArea = this._toolbarTemplateComponent;
        let toolbarContext = context.vm.toolbar;
        toolbarContext.vm.financialChartIndicatorMenu.template = this.indicatorMenuTemplate ? this.indicatorMenuTemplate : this._defaultTemplates.financialChartIndicatorMenuTemplate;
        toolbarContext.vm.financialChartIndicatorMenu.vm.notifyChanged = () => { toolbarArea.dataContext = toolbarContext; };
        toolbarContext.vm.financialChartTypePicker.template = this.chartTypePickerTemplate ? this.chartTypePickerTemplate : this._defaultTemplates.financialChartTypePickerTemplate;
        toolbarContext.vm.financialChartTypePicker.vm.notifyChanged = () => { toolbarArea.dataContext = toolbarContext; };
        toolbarContext.vm.financialChartRangeSelector.template = this.rangeSelectorTemplate ? this.rangeSelectorTemplate : this._defaultTemplates.financialChartRangeSelectorTemplate;
        toolbarContext.vm.financialChartRangeSelector.vm.notifyChanged = () => {
            toolbarArea.dataContext = toolbarContext;
        };
        toolbarContext.template = this.toolbarTemplate ? this.toolbarTemplate : this._defaultTemplates.financialChartToolbarTemplate;
        let toolContainer = this._toolbarElement;
        //let toolbarArea = this._templates.toArray()[0];
        //let mainArea = this._templates.toArray()[1];
        toolbarArea.contentReady = () => {
            toolbarArea.contentReady = null;
            this._chart.provideGrid(gridWrapper);
            this._checkToolbarSize();
        };
        toolbarArea.dataContext = toolbarContext;
        toolbarArea.template = toolbarContext.template;
        let ele = this._toolbarElement;
        //ele.style.width = "100%";
        //ele.style.height = "100%";
        //if (ele.parentElement != null) {
        //    ele.parentElement.removeChild(ele);
        //}
        //toolContainer.appendChild(ele);
        //this._wrapper.setStyleProperty(ele, "display", "")
        ele.style.display = "";
        let legendContainer = context.legendContainer.rootWrapper.getNativeElement();
        let mainContainer = context.container.rootWrapper.getNativeElement();
        let indicatorContainer = context.indicatorsContainer.rootWrapper.getNativeElement();
        let volumeContainer = context.volumeContainer.rootWrapper.getNativeElement();
        let zoomSliderContainer = context.zoomContainer.rootWrapper.getNativeElement();
        var main = this._mainGridElement;
        let templateMain = main.querySelector(".financialChartPrice");
        let templateToolbar = main.querySelector(".financialChartToolbar");
        let templateLegend = main.querySelector(".financialChartLegend");
        let templateIndicator = main.querySelector(".financialChartIndicators");
        let templateVolume = main.querySelector(".financialChartVolume");
        let templateZoomSlider = main.querySelector(".financialChartZoomSlider");
        let grid = main; // main.querySelector(".financialChartMainGrid");
        let gridWrapper = new ReactWrapper(grid, this._wrapper);
        templateMain.appendChild(mainContainer);
        //templateToolbar.appendChild(toolContainer);
        templateLegend.appendChild(legendContainer);
        templateIndicator.appendChild(indicatorContainer);
        templateVolume.appendChild(volumeContainer);
        templateZoomSlider.appendChild(zoomSliderContainer);
        this._styling(this._container, this);
        //this._mainElement.nativeElement.parentElement.removeChild(this._mainElement.nativeElement);
        //this.container.appendChild(this._mainElement.nativeElement);
    }
    _createZoomSlider(hostEle, onReady) {
        if (!TypeRegistrar.isRegistered("IgrZoomSlider")) {
            //shouldn't happen.
            throw new Error("zoom slider component isn't loaded");
        }
        let Slider = TypeRegistrar.get("IgrZoomSlider");
        let ele = React.createElement(Slider, {
            width: '100%', height: '100%', ref: (r) => {
                onReady(r);
            }
        });
        let portal = ReactDOM.createPortal(ele, hostEle);
        hostEle.className = "test";
        hostEle.style.width = "100%";
        hostEle.style.height = "100%";
        this._sliderPortal = portal;
    }
    createTooltip() {
        // if (!TypeRegistrar.isRegistered("IgrTooltipContainer")) {
        // 	return null;
        // }
        // let Tooltip = TypeRegistrar.get("IgrTooltipContainer");
        let wrapper = this._wrapper.createElement("div");
        let ele = wrapper.getNativeElement();
        ele.key = "__tooltip_" + this._uniqueTooltipId;
        this._uniqueTooltipId++;
        this._currentTooltips = this._currentTooltips.slice(0);
        this._currentTooltips.push(ele);
        //let element = React.createElement(Tooltip,  );
        //let portal = ReactDOM.createPortal(element, ele);
        let self = this;
        ele.updateToolTip = function (c, isSubContent) {
            if (c.externalObject) {
                c = c.externalObject;
            }
            else {
                let ext = new IgrDataContext();
                ext._implementation = c;
                c = ext;
            }
            if (!isSubContent) {
                if (ele.parentElement != self._container) {
                    if (ele.parentElement != null) {
                        ele.parentElement.removeChild(ele);
                    }
                    self._container.appendChild(ele);
                }
            }
            else {
                c.isSubContent = true;
            }
            if (self._activeTooltips.has(ele)) {
                let t = self._activeTooltips.get(ele);
                t.dataContext = c;
            }
            ele.style.display = "block";
            return true;
        };
        ele.hideToolTip = function () {
            ele.style.display = "none";
        };
        ele.style.display = "none";
        this._updateTooltipState();
        return ele;
    }
    _ensureTooltipCreated(series) {
        series._ensureTooltipCreated(() => this.createTooltip(), (ele) => {
            let wrapper = new ReactWrapper(ele, this._wrapper);
            wrapper.updateToolTip = ele.updateToolTip;
            wrapper.hideToolTip = ele.hideToolTip;
            if (this._activeTooltips.has(ele)) {
                let tCont = this._activeTooltips.get(ele);
                tCont.template = ele.tooltipTemplate;
            }
            return wrapper;
        });
    }
    // private _createXAxis(): any {
    //     let x = new IgxCategoryXAxisComponent();
    //     return x.i;
    // }
    // private _createYAxis(): any {
    //     let y = new IgxNumericYAxisComponent();
    //     return y.i;
    // }
    _ensureDefaultTooltip(series) {
        if (this._defaultTooltips == null) {
            return;
        }
        this._defaultTooltips["ensureDefaultTooltip"](series);
    }
    _onDefaultTooltipsReady(cr) {
        if (this.i.dataChart) {
            var currSeries = this.i.dataChart.series;
            for (var i = 0; i < currSeries.count; i++) {
                if (currSeries.item(i).externalObject.showDefaultTooltip) {
                    this._ensureDefaultTooltip(currSeries.item(i).externalObject);
                }
            }
        }
    }
    _updateTooltipState() {
        if (this._initialized) {
            this.setState({ tooltips: this._currentTooltips });
        }
    }
    /**
     * TimeAxisBreaks to apply to this chart when in time axis mode, representing spans of time to omit, such as weekends.
    */
    get xAxisBreaks() {
        if (this._xAxisBreaks === null) {
            if (!TypeRegistrar.isRegistered("IgrTimeAxisBreakCollection")) {
                return null;
            }
            let coll = TypeRegistrar.create("IgrTimeAxisBreakCollection");
            let innerColl = this.i.xAxisBreaks;
            if (!innerColl) {
                innerColl = TypeRegistrar.create("TimeAxisBreakCollection");
            }
            this._xAxisBreaks = coll._fromInner(innerColl);
            this.i._xAxisBreaks = innerColl;
        }
        return this._xAxisBreaks;
    }
    set xAxisBreaks(v) {
        if (this._xAxisBreaks !== null) {
            this._xAxisBreaks._setSyncTarget(null);
            this._xAxisBreaks = null;
        }
        if (!TypeRegistrar.isRegistered("IgxTimeAxisBreakCollection")) {
            return;
        }
        let coll = TypeRegistrar.create("IgxTimeAxisBreakCollection");
        let t = TypeRegistrar.get("TimeAxisBreak");
        this._xAxisBreaks = coll._fromOuter(v);
        let syncColl = new SyncableObservableCollection$1(t.$type);
        let innerColl = this.i.xAxisBreaks;
        if (!innerColl) {
            innerColl = TypeRegistrar.create("TimeAxisBreakCollection");
        }
        syncColl._inner = innerColl;
        syncColl.clear();
        this._xAxisBreaks._setSyncTarget(syncColl);
        this.i._xAxisBreaks = innerColl;
    }
    get leftMargin() {
        return this.i.jx;
    }
    set leftMargin(v) {
        this.i.jx = +v;
    }
    get isHorizontalZoomEnabled() {
        return this.i.g3;
    }
    set isHorizontalZoomEnabled(v) {
        this.i.g3 = ensureBool(v);
    }
    get toolbarHeight() {
        return this.i.ak6;
    }
    set toolbarHeight(v) {
        this.i.ak6 = +v;
    }
    /**
     * Gets domain type of this chart
    */
    get domainType() {
        return this.i.cb;
    }
    /**
     * Gets or sets whether the Y-axis should use a logarithmic scale instead of a linear one.
     * Since log(-1) is imaginary and log(0) is undefined, it is recommended to enable this property only when the Y-axis minimum is greater than zero.
    */
    get yAxisIsLogarithmic() {
        return this.i.aj5;
    }
    set yAxisIsLogarithmic(v) {
        this.i.aj5 = ensureBool(v);
    }
    /**
     * Gets or sets the base value to use in the log function when mapping the position of data items along the Y-axis.
     * This property is effective only when YAxisIsLogarithmic is true.
    */
    get yAxisLogarithmBase() {
        return this.i.al3;
    }
    set yAxisLogarithmBase(v) {
        this.i.al3 = +v;
    }
    /**
     * Gets or sets the distance between each label and grid line along the Y-axis.
    *
    * The `YAxisInterval` determines how often to show a label, tickmark, and/or gridline along the y-axis.  Set this property to a number less than the numeric range of the y-axis.
    *
    * ```ts
    * <IgrFinancialChart
    *     width="100%"
    *     height="400px"
    *     dataSource={this.data}
    * 	yAxisInterval={20}
    *  />
    * ```
    */
    get yAxisInterval() {
        return this.i.alf;
    }
    set yAxisInterval(v) {
        this.i.alf = +v;
    }
    /**
     * Gets or sets the data value corresponding to the minimum value of the Y-axis.
    *
    * The `YAxisMinimumValue` determines starting value of labels, tickmarks, and gridlines on the y-axis.
    *
    * ```ts
    * <IgrFinancialChart
    *     yAxisMinimumValue={-200}
    *     yAxisMaximumValue={1000}
    *     dataSource={this.data} />
    * ```
    */
    get yAxisMinimumValue() {
        return this.i.alh;
    }
    set yAxisMinimumValue(v) {
        this.i.alh = +v;
    }
    /**
     * Gets or sets the data value corresponding to the maximum value of the Y-axis.
    *
    * The `YAxisMaximumValue` determines ending value of labels, tickmarks, and gridlines on the y-axis.
    *
    * ```ts
    * <IgrFinancialChart
    *  yAxisMinimumValue={-200}
    *     yAxisMaximumValue={100}
    *     dataSource={this.data} />
    * ```
    */
    get yAxisMaximumValue() {
        return this.i.alg;
    }
    set yAxisMaximumValue(v) {
        this.i.alg = +v;
    }
    /**
     * Gets or sets the frequency of displayed minor lines along the Y-axis.
    *
    * The `YAxisMinorInterval` determines how often to show minor gridline along the y-axis.  Set this property to a number less than the `YAxisInterval` and the numeric range of the y-axis.
    *
    * ```ts
    * <IgrFinancialChart
    *      yAxisMinorInterval={50}
    *     dataSource={this.data} />
    * ```
    */
    get yAxisMinorInterval() {
        return this.i.ali;
    }
    set yAxisMinorInterval(v) {
        this.i.ali = +v;
    }
    /**
     * Gets the current minimum value for the Y-axis.
    */
    get yAxisActualMinimum() {
        return this.i.ale;
    }
    /**
     * Gets the current maximum value for the Y-axis.
    */
    get yAxisActualMaximum() {
        return this.i.ald;
    }
    /**
     * The type of series to display in the volume pane.
    *
    * Use the `VolumeType` property to set a type of all series that will be rendered in the volume pane, e.g.
    *
    * ```ts
    * <IgrFinancialChart
    *     width="100%"
    *     height="400px"
    *     dataSource={this.data}
    * 	volumeType="Column" />
    * ```
    */
    get volumeType() {
        return this.i.ah5;
    }
    set volumeType(v) {
        this.i.ah5 = ensureEnum(FinancialChartVolumeType_$type, v);
    }
    /**
     * The scaling mode of the X-axis.
    *
    * Use the `XAxisMode` property to plot data items without any breaks in data range (Ordinal mode) or with breaks in data range (Time mode) such as weekends/holidays. Note that the Ordinal axis mode is less expensive to use in the financial chart than the Time axis mode.
    *
    * ```ts
    * <IgrFinancialChart
    *      xAxisMode="time"
    *     dataSource={this.data} />
    * ```
    */
    get xAxisMode() {
        return this.i.ah7;
    }
    set xAxisMode(v) {
        this.i.ah7 = ensureEnum(FinancialChartXAxisMode_$type, v);
    }
    /**
     * Gets or sets number of visible categories at maximum zooming level
     * This property works only with ordinal XAxisMode and it is overridden by chart's WindowRectMinWidth property
    */
    get xAxisZoomMaximumCategoryRange() {
        return this.i.ak8;
    }
    set xAxisZoomMaximumCategoryRange(v) {
        this.i.ak8 = +v;
    }
    /**
     * Gets or sets starting category that chart will move its zoom window. Acceptable value is between 0 and number of data items
     * This property works only with ordinal XAxisMode and it is overridden by chart's WindowRect or WindowScaleHorizontal properties
    */
    get xAxisZoomToCategoryStart() {
        return this.i.alb;
    }
    set xAxisZoomToCategoryStart(v) {
        this.i.alb = +v;
    }
    /**
     * Gets or sets maximum pixel span of series item that will be visible at maximum zooming level
     * This property ensures that series item does not get stretch above specified value.
     * This property works only with ordinal XAxisMode and it is overridden by chart's WindowRectMinWidth property
    */
    get xAxisZoomMaximumItemSpan() {
        return this.i.ak9;
    }
    set xAxisZoomMaximumItemSpan(v) {
        this.i.ak9 = +v;
    }
    /**
     * Gets or sets number of categories that the chart will zoom in and fill plot area
     * This property is overridden by chart's WindowRect or WindowScaleHorizontal properties
    */
    get xAxisZoomToCategoryRange() {
        return this.i.ala;
    }
    set xAxisZoomToCategoryRange(v) {
        this.i.ala = +v;
    }
    /**
     * Gets or sets pixel span of series item that will be used to zoom chart such that the item has desired span
     * Chart will automatically zoom in until series item has specified pixel span.
     * This property works only with ordinal XAxisMode and it is overridden by chart's WindowRect or WindowScaleHorizontal properties
    */
    get xAxisZoomToItemSpan() {
        return this.i.alc;
    }
    set xAxisZoomToItemSpan(v) {
        this.i.alc = +v;
    }
    /**
     * The scaling mode of the Y-axis.
    *
    * Use the `YAxisMode` property to plot data items using their actual values (Numeric) or using percent changes from the first data point (PercentChange), e.g.
    *
    * ```ts
    * <IgrFinancialChart
    *      yAxisMode={this.state.yAxisMode}
    *     dataSource={this.data} />
    * ```
    */
    get yAxisMode() {
        return this.i.ah9;
    }
    set yAxisMode(v) {
        this.i.ah9 = ensureEnum(FinancialChartYAxisMode_$type, v);
    }
    /**
     * A boolean property controlling the visibility of the toolbar.
    */
    get isToolbarVisible() {
        return this.i.ajy;
    }
    set isToolbarVisible(v) {
        this.i.ajy = ensureBool(v);
    }
    /**
     * The type of price series to display in the main chart.
    *
    * Use the `ChartType` property to set a type of series that will be used to render prices in the Financial Chart control, e.g.
    *
    * ```ts
    * <IgrFinancialChart
    *   width="100%"
    *   height="400px"
    * 	chartType="Candle"
    *   dataSource={this.data} />
    * ```
    */
    get chartType() {
        return this.i.ah0;
    }
    set chartType(v) {
        this.i.ah0 = ensureEnum(FinancialChartType_$type, v);
    }
    /**
     * Gets or sets Horizontal alignment of Y-axis labels.
    */
    get yAxisLabelHorizontalAlignment() {
        return this.i.afs;
    }
    set yAxisLabelHorizontalAlignment(v) {
        this.i.afs = ensureEnum(HorizontalAlignment_$type, v);
    }
    /**
     * A boolean indicating whether the chart should automatically zoom in vertically on the currently visible range of data.
     * When this property is set to true, panning and zooming along the X-axis will result in a corresponding zoom on the Y-axis, so that the visible range of data fills the zoom window as fully as possible.
    */
    get isWindowSyncedToVisibleRange() {
        return this.i.ajz;
    }
    set isWindowSyncedToVisibleRange(v) {
        this.i.ajz = ensureBool(v);
    }
    /**
     * A collection indicating what financial indicator types to display on the Financial Chart.
    *
    * Use the `IndicatorTypes` property to set types of indicators that will be rendered below the price pane in the Financial Chart control, e.g.
    *
    * ```ts
    * <IgrFinancialChart
    *     width="100%"
    *     height="400px"
    *     dataSource={this.data}
    * 	indicatorTypes="ForceIndex" />
    * ```
    */
    get indicatorTypes() {
        if (this._indicatorTypes === null) {
            let coll = new IgrFinancialIndicatorTypeCollection();
            let innerColl = this.i.aie;
            if (!innerColl) {
                innerColl = new FinancialIndicatorTypeCollection_internal(0);
            }
            this._indicatorTypes = coll._fromInner(innerColl);
            this.i.aie = innerColl;
        }
        return this._indicatorTypes;
    }
    set indicatorTypes(v) {
        if (this._indicatorTypes !== null) {
            this._indicatorTypes._setSyncTarget(null);
            this._indicatorTypes = null;
        }
        let coll = new IgrFinancialIndicatorTypeCollection();
        this._indicatorTypes = coll._fromOuter(v);
        let syncColl = new SyncableObservableCollection$1(FinancialIndicatorType_$type);
        let innerColl = this.i.aie;
        if (!innerColl) {
            innerColl = new FinancialIndicatorTypeCollection_internal(0);
        }
        syncColl._inner = innerColl;
        syncColl.clear();
        this._indicatorTypes._setSyncTarget(syncColl);
        this.i.aie = innerColl;
    }
    /**
     * A collection indicating what financial overlay types to display on the Financial Chart.
    *
    * Use the `OverlayTypes` property to set types of overlays that will be rendered behind price series in the Financial Chart control, e.g.
    *
    * ```ts
    * <IgrFinancialChart
    *     width="100%"
    *     height="400px"
    *     dataSource={this.data}
    * 	overlayType ="PriceChannel" />
    * ```
    */
    get overlayTypes() {
        if (this._overlayTypes === null) {
            let coll = new IgrFinancialOverlayTypeCollection();
            let innerColl = this.i.aig;
            if (!innerColl) {
                innerColl = new FinancialOverlayTypeCollection_internal(0);
            }
            this._overlayTypes = coll._fromInner(innerColl);
            this.i.aig = innerColl;
        }
        return this._overlayTypes;
    }
    set overlayTypes(v) {
        if (this._overlayTypes !== null) {
            this._overlayTypes._setSyncTarget(null);
            this._overlayTypes = null;
        }
        let coll = new IgrFinancialOverlayTypeCollection();
        this._overlayTypes = coll._fromOuter(v);
        let syncColl = new SyncableObservableCollection$1(FinancialOverlayType_$type);
        let innerColl = this.i.aig;
        if (!innerColl) {
            innerColl = new FinancialOverlayTypeCollection_internal(0);
        }
        syncColl._inner = innerColl;
        syncColl.clear();
        this._overlayTypes._setSyncTarget(syncColl);
        this.i.aig = innerColl;
    }
    /**
     * Gets or sets whether the large numbers on the Y-axis labels are abbreviated.
    */
    get yAxisAbbreviateLargeNumbers() {
        return this.i.aj3;
    }
    set yAxisAbbreviateLargeNumbers(v) {
        this.i.aj3 = ensureBool(v);
    }
    /**
     * Gets or sets the rendering resolution for all series in this chart.
     * Where n = Resolution, for every n horizontal pixels, combine all items into a single datapoint.  When Resolution = 0, all datapoints will be rendered as graphical objects.  Charts with a higher resolution will have faster performance.
    */
    get resolution() {
        return this.i.j5;
    }
    set resolution(v) {
        this.i.j5 = +v;
    }
    /**
     * Gets or sets whether the x axis enhanced interval management should prefer to show all the labels if possible without collisions for supported types of category axes. This is for use with EnhancedIntervalMinimumCharacters = -1 and axes that have an integral interval.
    */
    get xAxisEnhancedIntervalPreferMoreCategoryLabels() {
        return this.i.aj2;
    }
    set xAxisEnhancedIntervalPreferMoreCategoryLabels(v) {
        this.i.aj2 = ensureBool(v);
    }
    /**
     * Gets or sets whether the y axis enhanced interval management should prefer to show all the labels if possible without collisions for supported types of category axes. This is for use with EnhancedIntervalMinimumCharacters = -1 and axes that have an integral interval.
    */
    get yAxisEnhancedIntervalPreferMoreCategoryLabels() {
        return this.i.aj4;
    }
    set yAxisEnhancedIntervalPreferMoreCategoryLabels(v) {
        this.i.aj4 = ensureBool(v);
    }
    /**
     * Gets or sets type of series to display in the zoom slider pane.
    *
    * Use the `ZoomSliderType` property to set a type of all series that will be rendered in the zoom pane, e.g.
    *
    * ```ts
    * <IgrFinancialChart
    *     zoomSliderType="Candle"
    *     dataSource={this.data} />
    * ```
    */
    get zoomSliderType() {
        return this.i.aic;
    }
    set zoomSliderType(v) {
        this.i.aic = ensureEnum(FinancialChartZoomSliderType_$type, v);
    }
    /**
     * Gets or sets the palette used for coloring negative items of Waterfall chart type.
    *
    * Use the `NegativeBrushes` property to set a collection of brushes that will be used to render fill area of negative elements in the price pane, e.g.
    *
    * ```ts
    * <IgrFinancialChart
    *     width="100%"
    *     height="400px"
    *     dataSource={this.data}
    * 	negativeBrushes="Red" />
    * ```
    */
    get negativeBrushes() {
        return fromBrushCollection(this.i.ag9);
    }
    set negativeBrushes(v) {
        this.i.ag9 = toBrushCollection(v);
    }
    /**
     * Brushes to use for drawing negative elements, when using a chart type with contextual coloring, such as Waterfall.
    *
    * Use the `NegativeOutlines` property to set a collection of brushes that will be used to render outline of negative elements in the price pane, e.g.
    *
    * ```ts
    * <IgrFinancialChart
    *     width="100%"
    *     height="400px"
    *     dataSource={this.data}
    * 	negativeOutlines= "Green"/>
    * ```
    */
    get negativeOutlines() {
        return fromBrushCollection(this.i.aha);
    }
    set negativeOutlines(v) {
        this.i.aha = toBrushCollection(v);
    }
    /**
     * Brushes to use for filling financial overlays.
    *
    * Use the `OverlayBrushes` property to set a collection of brushes that will be used to render fill area of overlays in the Financial Chart control, e.g.
    *
    * ```ts
    * <IgrFinancialChart
    *     width="100%"
    *     height="400px"
    *     dataSource={this.data}
    * 	overlayBrushes="Green" />
    * ```
    */
    get overlayBrushes() {
        return fromBrushCollection(this.i.ahb);
    }
    set overlayBrushes(v) {
        this.i.ahb = toBrushCollection(v);
    }
    /**
     * Brushes to use for outlining financial overlays.
    *
    * Use the `OverlayOutlines` property to set a collection of brushes that will be used to render outlines of overlays in the Financial Chart control, e.g.
    *
    * ```ts
    * <IgrFinancialChart
    *     width="100%"
    *     height="400px"
    *     dataSource={this.data}
    * 	overlayOutlines="Red" />
    * ```
    */
    get overlayOutlines() {
        return fromBrushCollection(this.i.ahc);
    }
    set overlayOutlines(v) {
        this.i.ahc = toBrushCollection(v);
    }
    /**
     * Brushes to use for outlining volume series in the volume pane.
    *
    * Use the `VolumeOutlines` property to set a collection of brushes that will be used to render outline of multiple series in the volume pane of the Financial Chart control, e.g.
    *
    * ```ts
    * <IgrFinancialChart
    *     width="100%"
    *     height="400px"
    *     dataSource={this.data}
    * 	volumeOutlines="Green" />
    * ```
    */
    get volumeOutlines() {
        return fromBrushCollection(this.i.ahe);
    }
    set volumeOutlines(v) {
        this.i.ahe = toBrushCollection(v);
    }
    /**
     * Brushes to use for filling volume series in the volume pane.
    *
    * Use the `VolumeBrushes` property to set a collection of brushes that will be used to render fill area of multiple series in the volume pane of the Financial Chart control, e.g.
    *
    * ```ts
    * <IgrFinancialChart
    *     width="100%"
    *     height="400px"
    *     dataSource={this.data}
    * 	volumeBrushes="Green" />
    * ```
    */
    get volumeBrushes() {
        return fromBrushCollection(this.i.ahd);
    }
    set volumeBrushes(v) {
        this.i.ahd = toBrushCollection(v);
    }
    /**
     * Brushes to use for negative elements in financial indicators.
    *
    * Use the `IndicatorNegativeBrushes` property to set a collection of brushes that will be used to render negative elements of indicators in the Financial Chart control, e.g.
    *
    * ```ts
    * <IgrFinancialChart
    *     width="100%"
    *     height="400px"
    *     dataSource={this.data}
    * 	indicatorNegativeBrushes="Red"/>
    * ```
    */
    get indicatorNegativeBrushes() {
        return fromBrushCollection(this.i.ag8);
    }
    set indicatorNegativeBrushes(v) {
        this.i.ag8 = toBrushCollection(v);
    }
    /**
     * Brushes to use for financial indicators.
    *
    * Use the `IndicatorBrushes` property to set a collection of brushes that will be used to render positive elements of indicators in the Financial Chart control, e.g.
    *
    * ```ts
    * <IgrFinancialChart
    *     width="100%"
    *     height="400px"
    *     dataSource={this.data}
    * 	indicatorBrushes="Green" />
    * ```
    */
    get indicatorBrushes() {
        return fromBrushCollection(this.i.ag7);
    }
    set indicatorBrushes(v) {
        this.i.ag7 = toBrushCollection(v);
    }
    /**
     * The outline thickness of volume series in the volume pane.
    *
    * Use the `VolumeThickness` property to set a number that will be used to render outline thickness of all series in the volume pane, e.g.
    *
    * ```ts
    * <IgrFinancialChart
    *     width="100%"
    *     height="400px"
    *     dataSource={this.data}
    * 	volumeThickness= {2.5}/>
    * ```
    */
    get volumeThickness() {
        return this.i.ak7;
    }
    set volumeThickness(v) {
        this.i.ak7 = +v;
    }
    /**
     * The outline thickness of financial overlays.
    *
    * Use the `OverlayThickness` property to set a number that will be used to render outline thickness of all overlays in the Financial Chart control, e.g.
    *
    * ```ts
    * <IgrFinancialChart
    *     width="100%"
    *     height="400px"
    *     dataSource={this.data}
    * 	overlayThickness ={2.5}  />
    * ```
    */
    get overlayThickness() {
        return this.i.ak5;
    }
    set overlayThickness(v) {
        this.i.ak5 = +v;
    }
    /**
     * The multiplier of financial overlay, e.g. BollingerBands overlay.
    */
    get overlayMultiplier() {
        return this.i.ak4;
    }
    set overlayMultiplier(v) {
        this.i.ak4 = +v;
    }
    /**
     * The outline or stroke thickness of financial indicators.
    *
    * Use the `IndicatorThickness` property to set a number that will be used to render outline thickness of all indicators in the Financial Chart control, e.g.
    *
    * ```ts
    * <IgrFinancialChart
    *     width="100%"
    *     height="400px"
    *     dataSource={this.data}
    * 	indicatorThickness={2.5}  />
    * ```
    */
    get indicatorThickness() {
        return this.i.ak3;
    }
    set indicatorThickness(v) {
        this.i.ak3 = +v;
    }
    /**
     * The display types of financial indicators.
    *
    * Use the `IndicatorDisplayTypes` property to set display types that will determine whether render all indicators as area, lines, or columns in the Financial Chart control, e.g.
    *
    * ```ts
    * <IgrFinancialChart
    *     width="100%"
    *     height="400px"
    *     dataSource={this.data}
    * 	indicatorDisplayTypes="line" />
    * ```
    */
    get indicatorDisplayTypes() {
        if (this._indicatorDisplayTypes === null) {
            let coll = new IgrIndicatorDisplayTypeCollection();
            let innerColl = this.i.aiq;
            if (!innerColl) {
                innerColl = new IndicatorDisplayTypeCollection_internal();
            }
            this._indicatorDisplayTypes = coll._fromInner(innerColl);
            this.i.aiq = innerColl;
        }
        return this._indicatorDisplayTypes;
    }
    set indicatorDisplayTypes(v) {
        if (this._indicatorDisplayTypes !== null) {
            this._indicatorDisplayTypes._setSyncTarget(null);
            this._indicatorDisplayTypes = null;
        }
        let coll = new IgrIndicatorDisplayTypeCollection();
        this._indicatorDisplayTypes = coll._fromOuter(v);
        let syncColl = new SyncableObservableCollection$1(IndicatorDisplayType_$type);
        let innerColl = this.i.aiq;
        if (!innerColl) {
            innerColl = new IndicatorDisplayTypeCollection_internal();
        }
        syncColl._inner = innerColl;
        syncColl.clear();
        this._indicatorDisplayTypes._setSyncTarget(syncColl);
        this.i.aiq = innerColl;
    }
    /**
     * The period of financial indicators, where applicable.
    *
    * The `indicatorPeriod` property applies to only the `BollingerBands` overlay as well as to these indicators types: `AverageDirectionalIndex`, `AverageTrueRange`, `BollingerBandWidth`, `ChaikinVolatility`, `CommodityChannelIndex`, `DetrendedPriceOscillator`, `FastStochasticOscillator`, `ForceIndex`, `FullStochasticOscillator`, `MoneyFlowIndex`, `PriceChannelOverlay`, `RateOfChangeAndMomentum`, `RelativeStrengthIndex`, `SlowStochasticOscillator`, `StandardDeviation`, `StochRSI`, `TRIX`, `WilliamsPercentR`
    *
    * ```ts
    * <IgrFinancialChart
    *     width="100%"
    *     height="400px"
    *     dataSource={this.data}
    * 	indicatorPeriod={8} />
    * ```
    */
    get indicatorPeriod() {
        return this.i.aly;
    }
    set indicatorPeriod(v) {
        this.i.aly = +v;
    }
    /**
     * The multiplier of financial indicators, e.g. BollingerBandWidth indicator.
    *
    * The `IndicatorMultiplier` property applies to only to BollingerBandWidth indicator type.
    *
    * ```ts
    * <IgrFinancialChart
    *     width="100%"
    *     height="400px"
    *     dataSource={this.data}
    * 	indicatorMultiplier= {8} />
    * ```
    */
    get indicatorMultiplier() {
        return this.i.ak2;
    }
    set indicatorMultiplier(v) {
        this.i.ak2 = +v;
    }
    /**
     * The smoothing period of financial indicators, where applicable.
    *
    * The `IndicatorSmoothingPeriod` property applies to only to `FullStochasticOscillator` indicator type.
    *
    * ```ts
    * <IgrFinancialChart
    *     width="100%"
    *     height="400px"
    *     dataSource={this.data}
    * 	indicatorSmoothingPeriod={8}     />
    * ```
    */
    get indicatorSmoothingPeriod() {
        return this.i.al1;
    }
    set indicatorSmoothingPeriod(v) {
        this.i.al1 = +v;
    }
    /**
     * The short period of financial indicators, where applicable.
    *
    * The `IndicatorShortPeriod` property applies only to these indicator types:
    *
    * -   AbsoluteVolumeOscillator,
    * -   ChaikinOscillator,
    * -   MovingAverageConvergenceDivergence,
    * -   PercentagePriceOscillator,
    * -   PercentageVolumeOscillator,
    *
    * ```ts
    * <IgrFinancialChart
    *     width="100%"
    *     height="400px"
    *     dataSource={this.data}
    * 	indicatorShortPeriod={8} />
    * ```
    */
    get indicatorShortPeriod() {
        return this.i.alz;
    }
    set indicatorShortPeriod(v) {
        this.i.alz = +v;
    }
    /**
     * The long period of financial indicators, where applicable.
    *
    * The `IndicatorLongPeriod` property applies only to these indicator types:
    *
    * -   AbsoluteVolumeOscillator,
    * -   ChaikinOscillator,
    * -   MovingAverageConvergenceDivergence,
    * -   PercentagePriceOscillator,
    * -   PercentageVolumeOscillator,
    *
    * ```ts
    * <IgrFinancialChart
    *     width="100%"
    *     height="400px"
    *     dataSource={this.data}
    * 	indicatorLongPeriod={8} />
    * ```
    */
    get indicatorLongPeriod() {
        return this.i.alx;
    }
    set indicatorLongPeriod(v) {
        this.i.alx = +v;
    }
    /**
     * The signal period of financial indicators, where applicable.
    *
    * The `IndicatorSignalPeriod` property applies to only to MovingAverageConvergenceDivergence indicator type.
    *
    * ```ts
    * <IgrFinancialChart
    *     width="100%"
    *     height="400px"
    *     dataSource={this.data}
    * 	indicatorSignalPeriod ={8} />
    * ```
    */
    get indicatorSignalPeriod() {
        return this.i.al0;
    }
    set indicatorSignalPeriod(v) {
        this.i.al0 = +v;
    }
    /**
     * A FinancialChartRangeSelectorOptionCollection containing the available range selector options on the toolbar.
    */
    get rangeSelectorOptions() {
        if (this._rangeSelectorOptions === null) {
            let coll = new IgrFinancialChartRangeSelectorOptionCollection();
            let innerColl = this.i.ahw;
            if (!innerColl) {
                innerColl = new FinancialChartRangeSelectorOptionCollection_internal(0);
            }
            this._rangeSelectorOptions = coll._fromInner(innerColl);
            this.i.ahw = innerColl;
        }
        return this._rangeSelectorOptions;
    }
    set rangeSelectorOptions(v) {
        if (this._rangeSelectorOptions !== null) {
            this._rangeSelectorOptions._setSyncTarget(null);
            this._rangeSelectorOptions = null;
        }
        let coll = new IgrFinancialChartRangeSelectorOptionCollection();
        this._rangeSelectorOptions = coll._fromOuter(v);
        let syncColl = new SyncableObservableCollection$1(FinancialChartRangeSelectorOption_$type);
        let innerColl = this.i.ahw;
        if (!innerColl) {
            innerColl = new FinancialChartRangeSelectorOptionCollection_internal(0);
        }
        syncColl._inner = innerColl;
        syncColl.clear();
        this._rangeSelectorOptions._setSyncTarget(syncColl);
        this.i.ahw = innerColl;
    }
    /**
     * The names of custom indicators to add to the chart.
     * When CustomIndicatorNames is set, the ApplyCustomIndicators event will be raised for each custom indicator name.
    */
    get customIndicatorNames() {
        if (this._customIndicatorNames === null) {
            let coll = new IgrCustomIndicatorNameCollection();
            let innerColl = this.i.customIndicatorNames;
            if (!innerColl) {
                innerColl = new CustomIndicatorNameCollection_internal(0);
            }
            this._customIndicatorNames = coll._fromInner(innerColl);
            this.i.customIndicatorNames = innerColl;
        }
        return this._customIndicatorNames;
    }
    set customIndicatorNames(v) {
        if (this._customIndicatorNames !== null) {
            this._customIndicatorNames._setSyncTarget(null);
            this._customIndicatorNames = null;
        }
        let coll = new IgrCustomIndicatorNameCollection();
        this._customIndicatorNames = coll._fromOuter(v);
        let syncColl = new SyncableObservableCollection$1(String_$type);
        let innerColl = this.i.customIndicatorNames;
        if (!innerColl) {
            innerColl = new CustomIndicatorNameCollection_internal(0);
        }
        syncColl._inner = innerColl;
        syncColl.clear();
        this._customIndicatorNames._setSyncTarget(syncColl);
        this.i.customIndicatorNames = innerColl;
    }
    get isVerticalZoomEnabled() {
        return this.i.hb;
    }
    set isVerticalZoomEnabled(v) {
        this.i.hb = ensureBool(v);
    }
    /**
     * Gets or sets stroke brush of major gridlines on x-axis of the zoom slider pane
    */
    get zoomSliderXAxisMajorStroke() {
        return brushToString(this.i.aqd);
    }
    set zoomSliderXAxisMajorStroke(v) {
        this.i.aqd = stringToBrush(v);
    }
    /**
     * Gets or sets thickness of major gridlines on x-axis of the zoom slider pane
    */
    get zoomSliderXAxisMajorStrokeThickness() {
        return this.i.alj;
    }
    set zoomSliderXAxisMajorStrokeThickness(v) {
        this.i.alj = +v;
    }
    /**
     * Gets or sets weather or not a legend is visible between toolbar and chart's plot area
    */
    get isLegendVisible() {
        return this.i.aju;
    }
    set isLegendVisible(v) {
        this.i.aju = ensureBool(v);
    }
    /**
     * Gets or sets minimum value on x-axis
    */
    get xAxisMinimumValue() {
        return this.i.akk;
    }
    set xAxisMinimumValue(v) {
        this.i.akk = v;
    }
    /**
     * Gets or sets maximum value on x-axis
    */
    get xAxisMaximumValue() {
        return this.i.akj;
    }
    set xAxisMaximumValue(v) {
        this.i.akj = v;
    }
    findByName(name) {
        var baseResult = super.findByName(name);
        if (baseResult) {
            return baseResult;
        }
        if (this.indicatorTypes != null && this.indicatorTypes.findByName && this.indicatorTypes.findByName(name)) {
            return this.indicatorTypes.findByName(name);
        }
        if (this.overlayTypes != null && this.overlayTypes.findByName && this.overlayTypes.findByName(name)) {
            return this.overlayTypes.findByName(name);
        }
        if (this.indicatorDisplayTypes != null && this.indicatorDisplayTypes.findByName && this.indicatorDisplayTypes.findByName(name)) {
            return this.indicatorDisplayTypes.findByName(name);
        }
        if (this.rangeSelectorOptions != null && this.rangeSelectorOptions.findByName && this.rangeSelectorOptions.findByName(name)) {
            return this.rangeSelectorOptions.findByName(name);
        }
        if (this.xAxisBreaks != null && this.xAxisBreaks.findByName && this.xAxisBreaks.findByName(name)) {
            return this.xAxisBreaks.findByName(name);
        }
        return null;
    }
    /**
 * Called by the UI framework to provide a UI container for rendering this control.

* @param container  * The UI container element.
*/
    provideContainer(container) {
        this.i.provideContainer(container);
    }
    notifyInsertItem(source_, index, newItem) {
        this.i.ve(source_, index, newItem);
    }
    notifyRemoveItem(source_, index, oldItem) {
        this.i.vf(source_, index, oldItem);
    }
    notifyClearItems(source_) {
        this.i.vd(source_);
    }
    notifySetItem(source_, index, oldItem, newItem) {
        this.i.vh(source_, index, oldItem, newItem);
    }
    /**
     * Returns visuals as a serialized string.
    
    */
    exportSerializedVisualData() {
        let iv = this.i.amn();
        return (iv);
    }
    /**
     * Event raised by the chart when custom indicator data is needed from the application.
     * During series rendering, event will be raised once for each value in the CustomIndicatorNames collection.
    */
    get applyCustomIndicators() {
        return this._applyCustomIndicators;
    }
    set applyCustomIndicators(ev) {
        if (this._applyCustomIndicators_wrapped !== null) {
            this.i.applyCustomIndicators = delegateRemove(this.i.applyCustomIndicators, this._applyCustomIndicators_wrapped);
            this._applyCustomIndicators_wrapped = null;
            this._applyCustomIndicators = null;
        }
        this._applyCustomIndicators = ev;
        this._applyCustomIndicators_wrapped = (o, e) => {
            let outerArgs = new IgrFinancialChartCustomIndicatorArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeApplyCustomIndicators) {
                this.beforeApplyCustomIndicators(this, outerArgs);
            }
            if (this._applyCustomIndicators) {
                this._applyCustomIndicators(this, outerArgs);
            }
        };
        this.i.applyCustomIndicators = delegateCombine(this.i.applyCustomIndicators, this._applyCustomIndicators_wrapped);
        ;
    }
}
