/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { Base, Point_$type, typeCast, markType } from "igniteui-react-core";
import { PathFigure } from "igniteui-react-core";
import { ViewportUtils } from "./ViewportUtils";
import { ArcSegment } from "igniteui-react-core";
import { Size } from "igniteui-react-core";
import { PathGeometry } from "igniteui-react-core";
import { LineSegment } from "igniteui-react-core";
import { LineGeometry } from "igniteui-react-core";
import { PolarAxisRenderingParameters } from "./PolarAxisRenderingParameters";
import { RadialAxisRenderingParameters } from "./RadialAxisRenderingParameters";
import { RangeInfo } from "./RangeInfo";
/**
 * @hidden
 */
export let PolarAxisRenderingManager = /*@__PURE__*/ (() => {
    class PolarAxisRenderingManager extends Base {
        r(a, b, c, d, e, f, g) {
            let h = ViewportUtils.d(a, e, f, g);
            let i = ViewportUtils.h(a, e, f, g);
            let j = ViewportUtils.e(b.x, e, f, g);
            let k = ViewportUtils.i(b.y, e, f, g);
            if (d - c < Math.PI && d - c > 0) {
                let l = { $type: Point_$type, x: ViewportUtils.e(b.x + a * Math.cos(c), e, f, g), y: ViewportUtils.i(b.y + a * Math.sin(c), e, f, g) };
                let m = { $type: Point_$type, x: ViewportUtils.e(b.x + a * Math.cos(d), e, f, g), y: ViewportUtils.i(b.y + a * Math.sin(d), e, f, g) };
                let n = new PathFigure();
                n._startPoint = l;
                n._isClosed = false;
                n._segments.add(((() => {
                    let $ret = new ArcSegment();
                    $ret.b = false;
                    $ret.e = m;
                    $ret.f = new Size(1, h, i);
                    $ret.d = 1;
                    return $ret;
                })()));
                return n;
            }
            else {
                let o = new PathFigure();
                o._startPoint = { $type: Point_$type, x: j, y: k - i };
                o._isClosed = true;
                o._segments.add(((() => {
                    let $ret = new ArcSegment();
                    $ret.b = false;
                    $ret.e = { $type: Point_$type, x: j, y: k + i };
                    $ret.f = new Size(1, h, i);
                    $ret.d = 1;
                    return $ret;
                })()));
                o._segments.add(((() => {
                    let $ret = new ArcSegment();
                    $ret.b = false;
                    $ret.e = { $type: Point_$type, x: j, y: k - i };
                    $ret.f = new Size(1, h, i);
                    $ret.d = 1;
                    return $ret;
                })()));
                return o;
            }
        }
        l(a, b, c, d, e, f, g, h, i) {
            let j = Math.min(b, c);
            let k = Math.max(b, c);
            let l = new PathGeometry();
            let m = null;
            let n = null;
            let o = null;
            let p = null;
            if (j > 0) {
                m = this.r(j, g, h, i, f, d, e);
                if (i - h < Math.PI && i - h > 0) {
                    let q = typeCast(ArcSegment.$, m._segments._inner[0]);
                    if (q != null) {
                        let r = { $type: Point_$type, x: ViewportUtils.e(g.x + k * Math.cos(i), f, d, e), y: ViewportUtils.i(g.y + k * Math.sin(i), f, d, e) };
                        n = ((() => {
                            let $ret = new LineSegment(1);
                            $ret.c = r;
                            return $ret;
                        })());
                    }
                }
            }
            if (k > 0) {
                o = this.r(k, g, h, i, f, d, e);
            }
            if (j > 0) {
                if (i - h < Math.PI && i - h > 0) {
                    let s = o._startPoint;
                    let t = typeCast(ArcSegment.$, o._segments._inner[0]);
                    if (t != null) {
                        o._startPoint = t.e;
                        t.e = s;
                        t.d = 0;
                        let u = { $type: Point_$type, x: ViewportUtils.e(g.x + j * Math.cos(h), f, d, e), y: ViewportUtils.i(g.y + j * Math.sin(h), f, d, e) };
                        p = ((() => {
                            let $ret = new LineSegment(1);
                            $ret.c = u;
                            return $ret;
                        })());
                    }
                }
            }
            if (n != null && p != null) {
                m._segments.add(n);
                let v = o._segments._inner[0];
                o._segments.remove(v);
                m._segments.add(v);
                m._segments.add(p);
                m._isClosed = true;
                l.c.add(m);
            }
            else {
                if (m != null) {
                    l.c.add(m);
                    this.q(o);
                }
                if (o != null) {
                    l.c.add(o);
                }
            }
            a.add(l);
        }
        q(a) {
            if (a._segments.count > 1) {
                let b = typeCast(ArcSegment.$, a._segments._inner[0]);
                let c = typeCast(ArcSegment.$, a._segments._inner[1]);
                a._segments._inner[0] = c;
                a._segments._inner[1] = b;
                let d = c.e;
                let e = a._startPoint;
                let f = b.e;
                a._startPoint = d;
                c.e = f;
                b.e = e;
                b.d = 0;
                c.d = 0;
            }
            else {
                let g = a._startPoint;
                let h = typeCast(ArcSegment.$, a._segments._inner[0]);
                if (h != null) {
                    a._startPoint = h.e;
                    h.e = g;
                    h.d = 0;
                }
            }
        }
        k(a, b, c, d, e, f, g, h) {
            if (b > 0) {
                let i = new PathGeometry();
                i.c.add(this.r(b, f, g, h, e, c, d));
                a.add(i);
            }
        }
        p(a, b, c, d, e, f, g, h, i) {
            let j = Math.min(b, c);
            let k = Math.max(b, c);
            let l = false;
            if (k - j > Math.PI) {
                l = true;
            }
            let m = Math.cos(j);
            let n = Math.sin(j);
            let o = i.x + m * g;
            let p = i.y + n * g;
            let q = i.x + m * h;
            let r = i.y + n * h;
            let s = Math.cos(k);
            let t = Math.sin(k);
            let u = i.x + s * g;
            let v = i.y + t * g;
            let w = i.x + s * h;
            let x = i.y + t * h;
            o = ViewportUtils.e(o, f, d, e);
            p = ViewportUtils.i(p, f, d, e);
            q = ViewportUtils.e(q, f, d, e);
            r = ViewportUtils.i(r, f, d, e);
            u = ViewportUtils.e(u, f, d, e);
            v = ViewportUtils.i(v, f, d, e);
            w = ViewportUtils.e(w, f, d, e);
            x = ViewportUtils.i(x, f, d, e);
            let y = new PathFigure();
            y._startPoint = { $type: Point_$type, x: o, y: p };
            y._isClosed = true;
            y._segments.add(((() => {
                let $ret = new LineSegment(1);
                $ret.c = { $type: Point_$type, x: q, y: r };
                return $ret;
            })()));
            y._segments.add(((() => {
                let $ret = new ArcSegment();
                $ret.e = { $type: Point_$type, x: w, y: x };
                $ret.f = new Size(1, ViewportUtils.d(h, f, d, e), ViewportUtils.h(h, f, d, e));
                $ret.d = 1;
                $ret.b = l;
                return $ret;
            })()));
            y._segments.add(((() => {
                let $ret = new LineSegment(1);
                $ret.c = { $type: Point_$type, x: u, y: v };
                return $ret;
            })()));
            y._segments.add(((() => {
                let $ret = new ArcSegment();
                $ret.e = { $type: Point_$type, x: o, y: p };
                $ret.f = new Size(1, ViewportUtils.d(g, f, d, e), ViewportUtils.h(g, f, d, e));
                $ret.d = 0;
                $ret.b = l;
                return $ret;
            })()));
            let z = new PathGeometry();
            z.c.add(y);
            a.add(z);
        }
        o(a, b, c, d, e, f, g, h) {
            let i = new LineGeometry();
            let j = Math.cos(b);
            let k = Math.sin(b);
            let l = h.x + j * f;
            let m = h.y + k * f;
            let n = h.x + j * g;
            let o = h.y + k * g;
            l = ViewportUtils.e(l, e, c, d);
            m = ViewportUtils.i(m, e, c, d);
            n = ViewportUtils.e(n, e, c, d);
            o = ViewportUtils.i(o, e, c, d);
            i.d = { $type: Point_$type, x: l, y: m };
            i.c = { $type: Point_$type, x: n, y: o };
            a.add(i);
        }
        a(a, b, c, d) {
            let e = { $type: Point_$type, x: ViewportUtils.e(a.x, b, c, d), y: ViewportUtils.i(a.y, b, c, d) };
            return (e.x >= c.left && e.x <= c.right);
        }
        b(a, b, c, d) {
            let e = { $type: Point_$type, x: ViewportUtils.e(a.x, b, c, d), y: ViewportUtils.i(a.y, b, c, d) };
            return (e.y >= c.top && e.y <= c.bottom);
        }
        c(a, b, c, d) {
            let e = this.d(a, { $type: Point_$type, x: c.left, y: c.top }, b, c, d);
            let f = this.d(a, { $type: Point_$type, x: c.right, y: c.top }, b, c, d);
            let g = this.d(a, { $type: Point_$type, x: c.right, y: c.bottom }, b, c, d);
            let h = this.d(a, { $type: Point_$type, x: c.left, y: c.bottom }, b, c, d);
            return Math.min(e, Math.min(f, Math.min(g, h)));
        }
        f(a, b, c, d) {
            let e = this.d(a, { $type: Point_$type, x: c.left, y: c.top }, b, c, d);
            let f = this.d(a, { $type: Point_$type, x: c.right, y: c.top }, b, c, d);
            let g = this.d(a, { $type: Point_$type, x: c.right, y: c.bottom }, b, c, d);
            let h = this.d(a, { $type: Point_$type, x: c.left, y: c.bottom }, b, c, d);
            return Math.max(e, Math.max(f, Math.max(g, h)));
        }
        d(a, b, c, d, e) {
            let f = { $type: Point_$type, x: ViewportUtils.e(a.x, c, d, e), y: ViewportUtils.i(a.y, c, d, e) };
            let g = b;
            let h = Math.sqrt((f.x - g.x) * (f.x - g.x) + (f.y - g.y) * (f.y - g.y));
            let i = ViewportUtils.a(h, c, d, e);
            return i;
        }
        e(a, b, c, d, e) {
            let f = { $type: Point_$type, x: ViewportUtils.e(a.x, c, d, e), y: ViewportUtils.i(a.y, c, d, e) };
            let g = { $type: Point_$type, x: ViewportUtils.e(b.x, c, d, e), y: ViewportUtils.i(b.y, c, d, e) };
            let h = Math.sqrt((f.x - g.x) * (f.x - g.x) + (f.y - g.y) * (f.y - g.y));
            let i = ViewportUtils.a(h, c, d, e);
            return i;
        }
        h(a, b, c) {
            let d = { $type: Point_$type, x: 0.5, y: 0.5 };
            if (this.a(d, a, b, c) && this.b(d, a, b, c)) {
                return 0;
            }
            if (this.a(d, a, b, c)) {
                if (d.y < a.top) {
                    return this.e(d, { $type: Point_$type, x: d.x, y: a.top }, a, b, c);
                }
                else {
                    return this.e(d, { $type: Point_$type, x: d.x, y: a.bottom }, a, b, c);
                }
            }
            if (this.b(d, a, b, c)) {
                if (d.x < a.left) {
                    return this.e(d, { $type: Point_$type, x: a.left, y: d.y }, a, b, c);
                }
                else {
                    return this.e(d, { $type: Point_$type, x: a.right, y: d.y }, a, b, c);
                }
            }
            return this.c(d, a, b, c);
        }
        i(a, b, c) {
            let d = { $type: Point_$type, x: 0.5, y: 0.5 };
            return this.f(d, a, b, c);
        }
        g(a, b) {
            let c = Math.sqrt(Math.pow(b.x - a.x, 2) + Math.pow(b.y - a.y, 2));
            let d = Math.acos((b.x - a.x) / c);
            if ((b.y - a.y) < 0) {
                d = (2 * Math.PI) - d;
            }
            return d;
        }
        j(a, b) {
            return ((a.y - 0.5) * b.x) + ((0.5 - a.x) * b.y) + ((a.x * 0.5) - (0.5 * a.y));
        }
        n(a, b, c, d, e) {
            let f = { $type: Point_$type, x: 0.5, y: 0.5 };
            if (this.a(f, a, b, c) && this.b(f, a, b, c)) {
                d = 0;
                e = Math.PI * 2;
                return {
                    p3: d,
                    p4: e
                };
            }
            let g = { $type: Point_$type, x: ViewportUtils.e(f.x, a, b, c), y: ViewportUtils.i(f.y, a, b, c) };
            let h = this.g(g, { $type: Point_$type, x: b.left, y: b.top });
            let i = this.g(g, { $type: Point_$type, x: b.right, y: b.top });
            let j = this.g(g, { $type: Point_$type, x: b.right, y: b.bottom });
            let k = this.g(g, { $type: Point_$type, x: b.left, y: b.bottom });
            if (this.b(f, a, b, c) && b.left > g.x) {
                d = h;
                e = 2 * Math.PI + k;
                return {
                    p3: d,
                    p4: e
                };
            }
            d = Math.min(h, Math.min(i, Math.min(j, k)));
            e = Math.max(h, Math.max(i, Math.max(j, k)));
            return {
                p3: d,
                p4: e
            };
        }
        m(a, b, c, d, e, f, g, h, i) {
            let j;
            let k;
            let l = this.n(a, b, c, j, k);
            j = l.p3;
            k = l.p4;
            let m = Math.min(j, k);
            let n = Math.max(j, k);
            if (typeCast(PolarAxisRenderingParameters.$, d) !== null) {
                d.minAngle = m;
                d.maxAngle = n;
            }
            else if (typeCast(RadialAxisRenderingParameters.$, d) !== null) {
                d.minAngle = m;
                d.maxAngle = n;
            }
            if (j == 0 && k == Math.PI * 2) {
                let o = e;
                let p = f;
                let q = Math.min(o, p);
                let r = Math.max(o, p);
                d.k.add(((() => {
                    let $ret = new RangeInfo();
                    $ret.d = q;
                    $ret.c = r;
                    $ret.b = i;
                    return $ret;
                })()));
                return;
            }
            else {
                if (k > Math.PI * 2) {
                    k = k - Math.PI * 2;
                }
                let s = h(j);
                let t = h(k);
                if (s < e || s > f) {
                    s = h(j + Math.PI * 2);
                }
                if (t < e || t > f) {
                    t = h(k + Math.PI * 2);
                }
                let u = Math.min(s, t);
                let v = Math.max(s, t);
                if ((!g && s > t) || (g && s < t)) {
                    let w = (f - v);
                    let x = (u - e);
                    d.k.add(((() => {
                        let $ret = new RangeInfo();
                        $ret.d = v;
                        $ret.c = f;
                        $ret.b = (w / (w + x)) * i;
                        return $ret;
                    })()));
                    d.k.add(((() => {
                        let $ret = new RangeInfo();
                        $ret.d = e;
                        $ret.c = u;
                        $ret.b = (x / (w + x)) * i;
                        return $ret;
                    })()));
                }
                else {
                    d.k.add(((() => {
                        let $ret = new RangeInfo();
                        $ret.d = u;
                        $ret.c = v;
                        $ret.b = i;
                        return $ret;
                    })()));
                }
            }
        }
    }
    PolarAxisRenderingManager.$t = /*@__PURE__*/ markType(PolarAxisRenderingManager, 'PolarAxisRenderingManager');
    return PolarAxisRenderingManager;
})();
