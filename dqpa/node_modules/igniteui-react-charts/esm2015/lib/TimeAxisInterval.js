/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { Base, INotifyPropertyChanged_$type, PropertyChangedEventArgs, enumGetBox, markType } from "igniteui-react-core";
import { TimeAxisIntervalType_$type } from "./TimeAxisIntervalType";
import { truncate } from "igniteui-react-core";
import { dateAddSeconds, dateFromValues, dateGetMonth, dateAddMinutes, dateAddHours, dateAddDays, dateMaxValue, dateAddMonths, dateAddYears } from "igniteui-react-core";
import { timeSpanFromTicks, timeSpanFromMilliseconds, timeSpanFromSeconds, timeSpanFromMinutes, timeSpanFromHours, timeSpanFromDays } from "igniteui-react-core";
/**
 * @hidden
 */
export let TimeAxisInterval = /*@__PURE__*/ (() => {
    class TimeAxisInterval extends Base {
        constructor() {
            super(...arguments);
            this.j = (0);
            this.e = 0;
            this.a = 0;
            this.propertyChanged = null;
        }
        get k() {
            return this.j;
        }
        set k(a) {
            let b = this.k;
            if (a != b) {
                this.j = a;
                this.l("Range", b, this.k);
            }
        }
        get f() {
            return this.e;
        }
        set f(a) {
            let b = this.f;
            if (a != b) {
                this.e = a;
                this.l("Interval", b, this.f);
            }
        }
        get b() {
            return this.a;
        }
        set b(a) {
            let b = this.b;
            if (a != b) {
                this.a = a;
                this.l("Interval", enumGetBox(TimeAxisIntervalType_$type, b), enumGetBox(TimeAxisIntervalType_$type, this.b));
            }
        }
        d(a) {
            let b;
            switch (this.b) {
                case 0:
                    let c = 10000;
                    return dateAddSeconds(a, 1 / c);
                case 1:
                    b = dateAddSeconds(a, 1 / 1000);
                    return dateFromValues(b.getFullYear(), dateGetMonth(b), b.getDate(), b.getHours(), b.getMinutes(), b.getSeconds(), b.getMilliseconds());
                case 2:
                    b = dateAddSeconds(a, 1);
                    return dateFromValues(b.getFullYear(), dateGetMonth(b), b.getDate(), b.getHours(), b.getMinutes(), b.getSeconds(), 0);
                case 3:
                    b = dateAddMinutes(a, 1);
                    return dateFromValues(b.getFullYear(), dateGetMonth(b), b.getDate(), b.getHours(), b.getMinutes(), 0, 0);
                case 4:
                case 5:
                    b = dateAddHours(a, 1);
                    return dateFromValues(b.getFullYear(), dateGetMonth(b), b.getDate(), b.getHours(), 0, 0, 0);
                case 6:
                case 7:
                case 8:
                    b = dateAddDays(a, 1);
                    return dateFromValues(b.getFullYear(), dateGetMonth(b), b.getDate(), 0, 0, 0, 0);
                default: return a;
            }
        }
        c(a) {
            let b = +(dateMaxValue()) - +a;
            switch (this.b) {
                case 0:
                    let c = 10000;
                    if (b > timeSpanFromTicks(truncate(this.f))) {
                        return dateAddSeconds(a, this.f / c);
                    }
                    return dateMaxValue();
                case 1:
                    if (b > timeSpanFromMilliseconds(this.f)) {
                        return dateAddSeconds(a, this.f / 1000);
                    }
                    return dateMaxValue();
                case 2:
                    if (b > timeSpanFromSeconds(this.f)) {
                        return dateAddSeconds(a, this.f);
                    }
                    return dateMaxValue();
                case 3:
                    if (b > timeSpanFromMinutes(this.f)) {
                        return dateAddMinutes(a, this.f);
                    }
                    return dateMaxValue();
                case 4:
                    if (b > timeSpanFromHours(this.f)) {
                        return dateAddHours(a, this.f);
                    }
                    return dateMaxValue();
                case 5:
                    if (b > timeSpanFromDays(this.f)) {
                        return dateAddDays(a, this.f);
                    }
                    return dateMaxValue();
                case 6:
                    if (b > timeSpanFromDays(7 * this.f)) {
                        return dateAddDays(a, this.f * 7);
                    }
                    return dateMaxValue();
                case 7:
                    if (b > timeSpanFromDays(31 * truncate(this.f))) {
                        return dateAddMonths(a, truncate(this.f));
                    }
                    return dateMaxValue();
                case 8:
                    if (b > timeSpanFromDays(365 * truncate(this.f))) {
                        return dateAddYears(a, truncate(this.f));
                    }
                    return dateMaxValue();
                default: return a;
            }
        }
        l(a, b, c) {
            this.m(a, b, c);
            if (this.propertyChanged != null) {
                this.propertyChanged(this, new PropertyChangedEventArgs(a));
            }
        }
        m(a, b, c) {
        }
    }
    TimeAxisInterval.$t = /*@__PURE__*/ markType(TimeAxisInterval, 'TimeAxisInterval', Base.$, [INotifyPropertyChanged_$type]);
    return TimeAxisInterval;
})();
