/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { AxisRendererBase } from "./AxisRendererBase";
import { CategoryAxisRenderingParameters } from "./CategoryAxisRenderingParameters";
import { LinearCategorySnapper } from "./LinearCategorySnapper";
import { typeCast, markType } from "igniteui-react-core";
import { truncate } from "igniteui-react-core";
/**
 * @hidden
 */
export let CategoryAxisRenderer = /*@__PURE__*/ (() => {
    class CategoryAxisRenderer extends AxisRendererBase {
        constructor(a) {
            super(a);
        }
        ac(a, b, c, d, e) {
            let f = typeCast(CategoryAxisRenderingParameters.$, a);
            let g = 0;
            if (f != null) {
                g = f.ac;
            }
            let h = new LinearCategorySnapper(1, a.e.d, a.e.c, a.e.b, a.p, g, a.o);
            b = h.g;
            if (a.e.a != -1) {
                b = a.e.a;
            }
            let i = Math.floor((a.e.d - a.m) / b);
            let j = Math.ceil((a.e.c - a.m) / b);
            d = truncate(i);
            e = truncate(j);
            c = truncate(h.h);
            if (a.e.e != -1) {
                c = a.e.e;
            }
            return {
                p1: b,
                p2: c,
                p3: d,
                p4: e
            };
        }
        w(a, b, c, d) {
            let e = typeCast(CategoryAxisRenderingParameters.$, a);
            if (e == null) {
                return null;
            }
            let f = 0;
            if (d >= 1) {
                f = c * truncate(Math.floor(d));
            }
            else {
                if ((c * d) * 2 % 2 == 0) {
                    f = truncate(Math.floor(c * d));
                }
                else {
                    f = -1;
                }
            }
            let g = null;
            if ((e.af > 0 && f < e.af && f >= 0) || e.ae) {
                while (f >= e.af && e.ae) {
                    f -= e.af;
                }
                g = this.g(f, false);
            }
            return g;
        }
        ad(a, b, c, d, e, f) {
            let g = typeCast(CategoryAxisRenderingParameters.$, a);
            if (g.ac != 0 && g.ag != 0) {
                for (let h = 0; h < truncate(b); h++) {
                    for (let i = 0; i < g.ag; i++) {
                        let j = this.f(i, a.ab, a.aa, a.z);
                        if (g.ad) {
                            j = -j;
                        }
                        let k = this.m(a, h + e * b) + j;
                        a.b = a.d;
                        this.k(a, a.w, k);
                        a.b = null;
                    }
                }
            }
        }
    }
    CategoryAxisRenderer.$t = /*@__PURE__*/ markType(CategoryAxisRenderer, 'CategoryAxisRenderer', AxisRendererBase.$);
    return CategoryAxisRenderer;
})();
