/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { TimeAxisBase } from "./TimeAxisBase";
import { DependencyProperty } from "igniteui-react-core";
import { TimeAxisDisplayType_$type } from "./TimeAxisDisplayType";
import { Base, enumGetBox, Number_$type, typeGetValue, typeCast, markType, markDep } from "igniteui-react-core";
import { Rect } from "igniteui-react-core";
import { ScalerParams } from "./ScalerParams";
import { NumericYAxis } from "./NumericYAxis";
import { LinearNumericSnapper } from "./LinearNumericSnapper";
import { LabelPosition } from "./LabelPosition";
import { PropertyMetadata } from "igniteui-react-core";
import { truncate, intDivide, isNaN_, isInfinity } from "igniteui-react-core";
import { dateMinValue, dateFromTicks } from "igniteui-react-core";
import { timeSpanFromMilliseconds } from "igniteui-react-core";
import { CategoryAxisBaseView } from "./CategoryAxisBaseView";
import { AxisDefaults } from "./AxisDefaults";
/**
 * @hidden
 */
export let CategoryDateTimeXAxis = /*@__PURE__*/ (() => {
    class CategoryDateTimeXAxis extends TimeAxisBase {
        constructor() {
            super();
            this.n0 = 0;
            this.n1 = 0;
            this.ab = CategoryDateTimeXAxis.$;
            this.actualMinimumValue = (new Date());
            this.actualMaximumValue = (new Date());
        }
        get_cd() {
            return this.nt == 0;
        }
        a4() {
            return new CategoryDateTimeXAxisView(this);
        }
        hv(a) {
            super.hv(a);
            this.ns = a;
        }
        get n2() {
            return this.n0;
        }
        set n2(a) {
            if (this.n2 != a) {
                let b = this.n0;
                this.n0 = a;
                this.h5("ActualInterval", b, this.n2);
            }
        }
        ex() {
            return this.n2;
        }
        get n6() {
            return typeGetValue(this.c(CategoryDateTimeXAxis.oi));
        }
        set n6(a) {
            this.h(CategoryDateTimeXAxis.oi, a);
        }
        get n3() {
            return this.n1;
        }
        set n3(a) {
            if (this.n3 != a) {
                let b = this.n1;
                this.n1 = a;
                this.h5("ActualMinorInterval", b, this.n3);
            }
        }
        c8(a, b, c) {
            let d = super.c8(a, b, c);
            if (!d) {
                return false;
            }
            return +(this.actualMinimumValue) != +(this.actualMaximumValue);
        }
        d6() {
            return this.n2;
        }
        ic(a) {
            super.ic(a);
            let b = this.bi != null ? this.bi.v4 : Rect.empty;
            let c = !b.isEmpty ? this.kh : Rect.empty;
            let d = this.kc();
            let e = this.kb();
            let f = new ScalerParams(0, b, c, this.ch, d);
            if ((this.mm == null || this.mm.count < 1) && !this.ms() && !this.mt()) {
                return;
            }
            if (!b.isEmpty && !c.isEmpty && (this.nt != 1 || this.mm != null)) {
                let g = c.bottom;
                let h = g - c.top;
                if (this.aj != null) {
                    let i = typeCast(NumericYAxis.$, this.aj);
                    if (i != null) {
                        let j = this.ii(g, h, b, c, d, c.top, c.bottom);
                        g = j.p0;
                        h = j.p1;
                    }
                }
                if (isNaN_(g)) {
                    g = 0;
                }
                this.ht(this.a5.a4(), g, c, this.a5.e(), true);
                this.aw.bg = h;
                let k = this.a5.a7();
                let l = this.a5.f();
                let m = this.a5.a5();
                let n = this.a5.a6();
                let o = this.a5.g();
                if (this.nt == 1) {
                    let p = this.i$e(b, c, d, e);
                    let q = this.i$g(b, c, d, e);
                    if (p < 0 || q < 0) {
                        return;
                    }
                    let r = NaN;
                    for (let s = p; s <= q; s++) {
                        let t = this.mv == null ? s : this.mv._inner[s];
                        let u = this.el(this.mm.item(t).getTime(), f);
                        if (u == r) {
                            continue;
                        }
                        r = u;
                        if (this.categoryMode == 2) {
                            u += this.ch ? -this.getGroupCenter(s, b, c, d) : this.getGroupCenter(s, b, c, d);
                        }
                        if (u < e.left || u > e.right) {
                            continue;
                        }
                        this.iq(m, u, c, l, false);
                        this.k2.add(u);
                        if (this.kv != null && s < this.kv.count) {
                            let v = this.kv.item(t);
                            let w = super.f1(v);
                            if (!isNaN_(u) && !isInfinity(u) && w != null) {
                                if ((typeof w === 'string') && Base.equalsStatic(w, "")) {
                                }
                                else {
                                    this.dd.add1(w);
                                    this.de.add(new LabelPosition(u));
                                }
                            }
                        }
                    }
                }
                else {
                    let x = this.eo(e.left, f);
                    let y = this.eo(e.right, f);
                    let z = Math.min(x, y);
                    let aa = Math.max(x, y);
                    let ab = new LinearNumericSnapper(0, z, aa, e.width, this.e0(), this.nz());
                    let ac = this.mq ? this.ny() : ab.g;
                    this.oe(truncate(ac));
                    let ad = truncate(Math.floor((z - this.actualMinimumValue.getTime()) / ac));
                    let ae = truncate(Math.ceil((aa - this.actualMinimumValue.getTime()) / ac));
                    let af = 0;
                    if (this.categoryMode == 2) {
                        af = this.getGroupCenter(0, b, c, d);
                        af = this.ch ? -af : af;
                    }
                    let ag = truncate(Math.ceil(e.right));
                    let ah = truncate(Math.floor(e.left));
                    let ai = this.el(this.actualMinimumValue.getTime() + ad * ac, f) + af;
                    for (let aj = ad; aj <= ae; aj++) {
                        let ak = this.el(this.actualMinimumValue.getTime() + (aj + 1) * ac, f) + af;
                        if (!isNaN_(ai) && !isInfinity(ai)) {
                            let al = truncate(Math.round(ai));
                            if (al <= ag) {
                                if (aj % 2 == 0) {
                                    this.ir(k, ai, ak, c);
                                }
                                this.iq(m, ai, c, l, false);
                                this.k2.add(ai);
                                if (this.cy) {
                                    let am = this.n4();
                                    if (am > 0 && am < ac) {
                                        if (ac / am < 20) {
                                            let an = ai;
                                            let ao = Math.abs(this.el(this.actualMinimumValue.getTime() + am, f) - this.el(this.actualMinimumValue.getTime(), f));
                                            while (an + ao < ak) {
                                                if (Math.abs(an + ao - ak) < 0.0001) {
                                                    break;
                                                }
                                                an += ao;
                                                if (an > 0) {
                                                    this.iq(n, an, c, o, false);
                                                }
                                            }
                                            this.of(am);
                                        }
                                    }
                                    else {
                                        for (let ap = 1; ap < ab.j; ++ap) {
                                            let aq = this.el(this.actualMinimumValue.getTime() + aj * ac + (ap * ac) / ab.j, f) + af;
                                            this.iq(n, aq, c, o, false);
                                        }
                                        if (ab.j > 0) {
                                            this.of(truncate((ac / ab.j)));
                                        }
                                    }
                                }
                            }
                            if (al >= ah && al <= ag) {
                                let ar = this.actualMinimumValue.getTime() + aj * ac;
                                let ticks_ = truncate(Math.floor(ar));
                                let as = (new Date(ticks_));
                                let at = this.f1(as);
                                if (at != null) {
                                    this.dd.add1(at);
                                    this.de.add(new LabelPosition(ai));
                                }
                            }
                        }
                        ai = ak;
                    }
                }
                if ((this.az == null || this.az.visibility == 0) && this.aj != null) {
                    if (this.az != null && (this.az.location == 4 || this.az.location == 5)) {
                        this.bi.n3();
                    }
                }
                this.aw.a9 = this.dd;
                this.aw.ba = this.de;
                this.l9();
            }
        }
        nz() {
            return -1;
        }
        ny() {
            return this.n2;
        }
        n4() {
            return this.n6;
        }
        oe(a) {
            this.n2 = a;
        }
        of(a) {
            this.n3 = a;
        }
        nv() {
            return this.n5 != 0;
        }
        nu() {
            return this.n2 == 0;
        }
        nx(a) {
            return this.mm == null ? dateMinValue() : this.mm.item(a);
        }
        od(a, b) {
            if (a > b || this.kv == null || this.kv.count == 0) {
                return;
            }
            let c = (a.getTime() - this.actualMinimumValue.getTime()) / (this.actualMaximumValue.getTime() - this.actualMinimumValue.getTime());
            let d = (b.getTime() - this.actualMinimumValue.getTime()) / (this.actualMaximumValue.getTime() - this.actualMinimumValue.getTime());
            this.bi.wl = new Rect(0, c, this.bi.wl.y, d - c, this.bi.wl.height);
        }
        hz(a, b, c, d) {
            super.hz(a, b, c, d);
            switch (b) {
                case CategoryDateTimeXAxis.$$p[0]:
                    this.cq = true;
                    this.aw.al = this.nt == 1 || this.nw;
                    this.ib(false);
                    break;
                case CategoryDateTimeXAxis.$$p[1]:
                    this.cq = true;
                    this.ib(false);
                    break;
                case CategoryDateTimeXAxis.$$p[2]:
                    this.aw.al = this.nt == 1 || this.nw;
                    break;
            }
        }
        ni() {
            super.ni();
            if (this.nv()) {
                this.n2 = this.n5;
                let a = this.bi != null ? this.bi.v4 : Rect.empty;
                let b = !a.isEmpty ? this.kh : Rect.empty;
                let c = Math.abs(this.actualMaximumValue.getTime() - this.actualMinimumValue.getTime());
                this.mq = this.nu() || (this.nt == 1) || (1 * c / this.ny() > (b.width / a.width)) ? false : true;
            }
            else {
                this.mq = false;
            }
        }
        ng(a, b) {
            let c = b.getTime() - a.getTime();
            let timeOffset_ = truncate(Math.round(intDivide(c, this.lj) / 2));
            return timeOffset_ == 0 ? timeSpanFromMilliseconds(1) : timeSpanFromMilliseconds(timeOffset_);
        }
        get_cc() {
            return true;
        }
        get isVertical() {
            return this.cp;
        }
        j$d(a, b) {
            return this.eo.apply(this, arguments);
        }
        j$c(a, b) {
            return this.el.apply(this, arguments);
        }
        j$e(a, b, c, d, e) {
            this.hp.apply(this, arguments);
        }
        j$f(a, b, c, d) {
            this.hq.apply(this, arguments);
        }
        j$g(a, b, c, d) {
            this.hr.apply(this, arguments);
        }
        get j$b() {
            return this.ch;
        }
        j$a() {
            return this.ag.apply(this, arguments);
        }
        get i$a() {
            return this.ce;
        }
    }
    CategoryDateTimeXAxis.$t = /*@__PURE__*/ markType(CategoryDateTimeXAxis, 'CategoryDateTimeXAxis', TimeAxisBase.$);
    CategoryDateTimeXAxis.oi = /*@__PURE__*/ DependencyProperty.i("MinorInterval", Number_$type, CategoryDateTimeXAxis.$, /*@__PURE__*/ new PropertyMetadata(2, 0, (a, b) => {
        (typeCast(CategoryDateTimeXAxis.$, a)).h5("MinorInterval", b.oldValue, b.newValue);
        (typeCast(CategoryDateTimeXAxis.$, a)).ib(false);
    }));
    CategoryDateTimeXAxis.$$p = /*@__PURE__*/ markDep(DependencyProperty, PropertyMetadata, CategoryDateTimeXAxis, 'h5', ['DisplayType:nt:og', [TimeAxisDisplayType_$type, /*@__PURE__*/ enumGetBox(TimeAxisDisplayType_$type, 0)], 'Interval:n5:oh', [1, 0], 'UnevenlySpacedLabels:nw:oj', [0, false]]);
    return CategoryDateTimeXAxis;
})();
/**
 * @hidden
 */
export let CategoryDateTimeXAxisView = /*@__PURE__*/ (() => {
    class CategoryDateTimeXAxisView extends CategoryAxisBaseView {
        constructor(a) {
            super(a);
            this.bm = null;
            this.bm = a;
        }
        al() {
            super.al();
            this.a.fj = AxisDefaults.f;
        }
        s(a) {
            let b = this.q(dateFromTicks(truncate(a)));
            return b;
        }
    }
    CategoryDateTimeXAxisView.$t = /*@__PURE__*/ markType(CategoryDateTimeXAxisView, 'CategoryDateTimeXAxisView', CategoryAxisBaseView.$);
    return CategoryDateTimeXAxisView;
})();
