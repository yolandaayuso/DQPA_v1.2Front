/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { LegendBase } from "./LegendBase";
import { LegendBaseView } from "./LegendBaseView";
import { Base, fromEn, delegateCombine, fromEnum, typeCast, markType } from "igniteui-react-core";
import { LegendItemInfo } from "./LegendItemInfo";
import { ContentControl } from "igniteui-react-core";
import { ILegendContext_$type } from "igniteui-react-core";
/**
 * @hidden
 */
export let Legend = /*@__PURE__*/ (() => {
    class Legend extends LegendBase {
        aj() {
            return new LegendView(this);
        }
        a8(a) {
            super.a8(a);
            this.bc = a;
        }
        constructor() {
            super();
            this.ab = Legend.$;
            let a = this.at;
            a.collectionChanged = delegateCombine(a.collectionChanged, (a, b) => {
                if (b.oldItems != null) {
                    for (let c of fromEn(b.oldItems)) {
                        this.bc.ao(c);
                    }
                }
                if (b.newItems != null) {
                    for (let d of fromEn(b.newItems)) {
                        this.bc.y(d);
                    }
                }
            });
        }
        bd(a) {
            return a.resolveLegendIndex();
        }
        bf(a) {
            return this.be(a);
        }
        addChildInOrder(a, b) {
            if (b.isStacked) {
                return;
            }
            if (!b.isUsableInLegend) {
                return;
            }
            let c = 0;
            for (let d of fromEnum(this.at)) {
                let e;
                let f;
                let g;
                let h = this.ak.ab(d, e, f, g);
                e = h.p1;
                f = h.p2;
                g = h.p3;
                if (b.container != null && e != null && (this.bf(b.container) < this.bf(e) || (this.bf(b.container) == -1 && this.bf(e) == -1 && Base.getHashCodeStatic(b.container) < Base.getHashCodeStatic(e)))) {
                    break;
                }
                if (b.container != null && e != null && b.container == e && f != null) {
                    let i = this.bd(b);
                    let j = this.bd(f);
                    let k = this.bf(b);
                    let l = this.bf(f);
                    if (f.isVertical && !f.isStacked) {
                        if (l == -1 && k == -1) {
                            c = 0;
                            break;
                        }
                        if (k < l || l == -1) {
                            break;
                        }
                    }
                    if (i <= j) {
                        break;
                    }
                }
                c++;
            }
            this.at.insert(c, a);
            let m = new LegendItemInfo();
            m.c = a;
            m.a = b;
            let n = typeCast(ContentControl.$, a);
            if (n != null && n.content != null) {
                let o = typeCast(ILegendContext_$type, n.content);
                if (o != null) {
                    m.b = o;
                    m.d = o.itemLabel;
                }
            }
        }
        get bb() {
            return this.ak.l ? 0 : 1;
        }
        set bb(a) {
            this.ak.l = a == 0;
        }
        be(a) {
            return -1;
        }
        get bh() {
            return this.ak.w;
        }
        set bh(a) {
            this.ak.w = a;
        }
        get bi() {
            return this.ak.x;
        }
        set bi(a) {
            this.ak.x = a;
        }
    }
    Legend.$t = /*@__PURE__*/ markType(Legend, 'Legend', LegendBase.$);
    return Legend;
})();
/**
 * @hidden
 */
export let LegendView = /*@__PURE__*/ (() => {
    class LegendView extends LegendBaseView {
        constructor(a) {
            super(a);
            this.ap = null;
            this.ap = a;
        }
        al() {
            super.al();
        }
    }
    LegendView.$t = /*@__PURE__*/ markType(LegendView, 'LegendView', LegendBaseView.$);
    return LegendView;
})();
