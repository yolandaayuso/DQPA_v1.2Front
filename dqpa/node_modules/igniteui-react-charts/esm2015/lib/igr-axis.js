/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import * as React from 'react';
import { Visibility_$type } from "igniteui-react-core";
import { HorizontalAlignment_$type } from "igniteui-react-core";
import { VerticalAlignment_$type } from "igniteui-react-core";
import { AxisLabelsLocation_$type } from './AxisLabelsLocation';
import { AxisLabelSettings } from './AxisLabelSettings';
import { TitleSettings } from './TitleSettings';
import { AxisTitlePosition_$type } from './AxisTitlePosition';
import { fromDoubleCollection, toDoubleCollection, ensureEnum, arrayFindByName, brushToString, stringToBrush, ensureBool, isValidProp, getModifiedProps, toSpinal, initializePropertiesFromCss, NamePatcher } from "igniteui-react-core";
import { delegateCombine, delegateRemove } from "igniteui-react-core";
import { IgrRenderRequestedEventArgs } from './igr-render-requested-event-args';
import { TypeRegistrar } from "igniteui-react-core";
import { IgrAxisRangeChangedEventArgs } from './igr-axis-range-changed-event-args';
import { IgrAxisAnnotationCollection } from './igr-axis-annotation-collection';
import { AxisAnnotationCollection as AxisAnnotationCollection_internal } from './AxisAnnotationCollection';
import { SyncableObservableCollection$1 } from "igniteui-react-core";
import { IAxisAnnotation_$type } from './IAxisAnnotation';
/**
 * Represents the base class from which all axis types are derived.
*
* The `Axis` is an array of axis objects.
*
* ```ts
* <IgrDataChart
*     dataSource={this.state.dataSource} >
*
*     <IgrCategoryXAxis name="xAxis" label="Date" />
*     <IgrNumericYAxis  name="yAxis" />
*  </IgrDataChart>
* ```
*/
export class IgrAxis extends React.Component {
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor(props) {
        super(props);
        this._renderer = null;
        this._crossingAxisName = null;
        this._annotations = null;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        this._rangeChanged = null;
        this._rangeChanged_wrapped = null;
        this._renderRequested = null;
        this._renderRequested_wrapped = null;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
    }
    componentDidMount() {
        {
            for (const p of Object.keys(this.props)) {
                {
                    if (isValidProp(this, p)) {
                        {
                            this[p] = this.props[p];
                        }
                    }
                }
            }
        }
    }
    //private _crossingAxisName: string;
    //public set crossingAxisName(value: string) {
    //    this._crossingAxisName = value;
    //}
    //public get crossingAxisName(): string {
    //    return this._crossingAxisName;
    //}
    get axisInternal() {
        return this.i;
    }
    createImplementation() {
        return null;
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    render() {
        return null;
    }
    set name(value) {
        this.i.name = value;
    }
    get name() {
        return this.i.name;
    }
    provideData(data) {
    }
    _provideRenderer(renderer) {
        this._renderer = renderer;
    }
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    /**
 * Gets or sets if the current axis is of category axis type
*/
    get isCategory() {
        return this.i.cb;
    }
    /**
     * Gets or sets if the current axis is of numeric axis type
    *
    *     Gets or sets if the current axis is of numeric axis type
    */
    get isNumeric() {
        return this.i.cj;
    }
    /**
     * Gets if the current axis is of angular axis type
    */
    get isAngular() {
        return this.i.b9;
    }
    /**
     * Gets or sets if the current axis is of radial axis type
    */
    get isRadial() {
        return this.i.cm;
    }
    /**
     * Gets if the current axis is a vertical axis.
    */
    get isVertical() {
        return this.i.cp;
    }
    /**
     * Gets or sets if the current axis is sorting data items
    */
    get isSorting() {
        return this.i.cn;
    }
    /**
     * Gets or sets if the current axis is of date time axis type
    */
    get isDateTime() {
        return this.i.ce;
    }
    /**
     * Gets or sets if the current axis is of ordinal axis type
    */
    get isOrdinal() {
        return this.i.ck;
    }
    /**
     * Gets or sets if the axis is a piecewise scaling function.
    */
    get isPiecewise() {
        return this.i.cl;
    }
    /**
     * Gets if the current axis is of category date time axis type
    */
    get isCategoryDateTime() {
        return this.i.cc;
    }
    /**
     * Gets if the current axis is a continuous rather than a discrete scale
    */
    get isContinuous() {
        return this.i.cd;
    }
    /**
     * Sets or gets a function which takes an object that produces a formatted label for displaying in the chart.
    *
    * The `FormatLabel` function takes an object that produces a formatted label for displaying in the chart.
    *
    * ```ts
    * <IgrDataChart dataSource={this.data}   >
    *     <IgrCategoryXAxis
    * 		name="xAxis"
    * 		FormatLabel="xAxis_FormatLabel" />
    * </IgrDataChart>
    * ```
    */
    get formatLabel() {
        return this.i.au;
    }
    set formatLabel(v) {
        this.i.au = v;
    }
    /**
     * Gets or sets the Title property.
    *
    * Use `Title` property to display the title of the component.
    *
    * ```ts
    * <IgrCategoryXAxis name="xAxis"
    *     title="Country"
    *     titleTextColor="gray"
    *     titleTextStyle="12pt Verdana"
    *     titleAngle={90} />
    * ```
    */
    get title() {
        return this.i.g8;
    }
    set title(v) {
        this.i.g8 = v;
    }
    /**
     * Gets or sets the Stroke property.
     * Null is treated as auto. The axis stroke will be displayed or not based on the axis type and series used with it.
    *
    * Use `Stroke` property to set the stroke of the chart.
    *
    * ```ts
    * <IgrCategoryChart
    *         ref={this.onChartRef}
    *         width="100%"
    *         height="100%"
    *         dataSource={this.data}
    *         titleTopMargin={5}
    *         xAxisStroke="gray"/>
    * ```
    */
    get stroke() {
        return brushToString(this.i.j2);
    }
    set stroke(v) {
        this.i.j2 = stringToBrush(v);
    }
    /**
     * Gets or sets the effective stroke used for the axis.
    */
    get actualStroke() {
        return brushToString(this.i.jy);
    }
    set actualStroke(v) {
        this.i.jy = stringToBrush(v);
    }
    /**
     * Gets or sets the StrokeThickness property.
    *
    * Use `StrokeThickness` property for the thickness of the stroke.
    *
    * ```ts
    * <IgrCategoryChart
    *         ref={this.onChartRef}
    *         width="100%"
    *         height="100%"
    *         dataSource={this.data}
    *         titleTopMargin={5}
    *         xAxisStrokeThickness={2}>
    * ```
    */
    get strokeThickness() {
        return this.i.fi;
    }
    set strokeThickness(v) {
        this.i.fi = +v;
    }
    /**
     * Gets or sets the StrokeDashArray property.
    */
    get strokeDashArray() {
        return fromDoubleCollection(this.i.j6);
    }
    set strokeDashArray(v) {
        this.i.j6 = toDoubleCollection(v);
    }
    /**
     * Gets or sets the Strip property.
    *
    * Use `Strip` property to set the strip of the chart.
    *
    * ```ts
    * <IgrCategoryChart
    *         ref={this.onChartRef}
    *         width="100%"
    *         height="100%"
    *         dataSource={this.data}
    *         titleTopMargin={5}
    *         xAxisStrip="gray"/>
    * ```
    */
    get strip() {
        return brushToString(this.i.j1);
    }
    set strip(v) {
        this.i.j1 = stringToBrush(v);
    }
    /**
     * Gets or sets the MajorStroke property.
     * Null is treated as auto. Major lines will be displayed or not based on the axis type and series used with it.
    *
    * Gets or sets the `MajorStroke` using this property.
    *
    * ```ts
    * <IgrNumericYAxis name="yAxis"
    *     interval={100}
    *     majorStroke="black"
    *     majorStrokeThickness={1}
    *     minorInterval={25}
    *     minorStroke="gray"
    *     minorStrokeThickness={0.5} />
    * ```
    */
    get majorStroke() {
        return brushToString(this.i.jz);
    }
    set majorStroke(v) {
        this.i.jz = stringToBrush(v);
    }
    /**
     * Gets or sets the ActualMajorStroke property.
    *
    * The `ActualMajorStroke` property is used for ActualMajorStroke of the axis.
    */
    get actualMajorStroke() {
        return brushToString(this.i.jw);
    }
    set actualMajorStroke(v) {
        this.i.jw = stringToBrush(v);
    }
    /**
     * Gets or sets the MajorStrokeThickness property.
    *
    * Gets or sets the `MajorStrokeThickness` using this property.
    *
    * ```ts
    * <IgrNumericYAxis name="yAxis"
    *     interval={100}
    *     majorStroke="black"
    *     majorStrokeThickness={1}
    *     minorInterval={25}
    *     minorStroke="gray"
    *     minorStrokeThickness={0.5} />
    * ```
    */
    get majorStrokeThickness() {
        return this.i.et;
    }
    set majorStrokeThickness(v) {
        this.i.et = +v;
    }
    /**
     * Gets or sets the MajorStrokeDashArray property.
    */
    get majorStrokeDashArray() {
        return fromDoubleCollection(this.i.j4);
    }
    set majorStrokeDashArray(v) {
        this.i.j4 = toDoubleCollection(v);
    }
    /**
     * Gets or sets the MinorStroke property.
    *
    * Gets or sets the minorStroke thickness using `MinorStrokeThickness` property.
    *
    * ```ts
    * <IgrNumericYAxis name="yAxis"
    *     interval={100}
    *     majorStroke="black"
    *     majorStrokeThickness={1}
    *     minorInterval={25}
    *     minorStroke="gray"
    *     minorStrokeThickness={0.5} />
    * ```
    */
    get minorStroke() {
        return brushToString(this.i.j0);
    }
    set minorStroke(v) {
        this.i.j0 = stringToBrush(v);
    }
    /**
     * Gets or sets the ActualMinorStroke property.
    *
    * The `ActualMinorStroke` property is used for ActualMinorStroke of the axis.
    */
    get actualMinorStroke() {
        return brushToString(this.i.jx);
    }
    set actualMinorStroke(v) {
        this.i.jx = stringToBrush(v);
    }
    /**
     * Gets or sets the MinorStrokeThickness property.
    */
    get minorStrokeThickness() {
        return this.i.ew;
    }
    set minorStrokeThickness(v) {
        this.i.ew = +v;
    }
    /**
     * Gets or sets the MinorStrokeDashArray property.
    */
    get minorStrokeDashArray() {
        return fromDoubleCollection(this.i.j5);
    }
    set minorStrokeDashArray(v) {
        this.i.j5 = toDoubleCollection(v);
    }
    /**
     * Gets or sets the TickStroke property.
    *
    * Use `TickStroke` property for the color of the tickmarks.
    *
    * ```ts
    * <IgrCategoryXAxis name="xAxis"
    *     tickLength={10}
    *     tickStrokeThickness={0.5}
    *     tickStroke="black" />
    * ```
    */
    get tickStroke() {
        return brushToString(this.i.j3);
    }
    set tickStroke(v) {
        this.i.j3 = stringToBrush(v);
    }
    /**
     * Gets or sets the TickStrokeThickness property.
    *
    * Use `TickStrokeThickness` property for thickness of the stroke tickmarks.
    *
    * ```ts
    * <IgrCategoryXAxis name="xAxis"
    *     tickLength={10}
    *     tickStrokeThickness={0.5}
    *     tickStroke="black" />
    * ```
    */
    get tickStrokeThickness() {
        return this.i.fk;
    }
    set tickStrokeThickness(v) {
        this.i.fk = +v;
    }
    /**
     * Gets or sets the TickStrokeDashArray property.
    */
    get tickStrokeDashArray() {
        return fromDoubleCollection(this.i.j7);
    }
    set tickStrokeDashArray(v) {
        this.i.j7 = toDoubleCollection(v);
    }
    /**
     * Gets or sets the TickLength property.
    *
    * Use `TickLength` property for The length of the tickmarks to display for this axis.
    *
    * ```ts
    * <IgrCategoryXAxis name="xAxis"
    *     tickLength={10}
    *     tickStrokeThickness={0.5}
    *     tickStroke="black" />
    * ```
    */
    get tickLength() {
        return this.i.fj;
    }
    set tickLength(v) {
        this.i.fj = +v;
    }
    /**
     * Gets or sets the IsDisabled property. If true, the axis will not be rendered.
    *
    * The `IsDisabled` property is used to decide if the axis will not be rendered.
    */
    get isDisabled() {
        return this.i.cf;
    }
    set isDisabled(v) {
        this.i.cf = ensureBool(v);
    }
    /**
     * Gets or sets the IsInverted property.
    *
    * Gets or sets the `IsInverted` property.
    */
    get isInverted() {
        return this.i.ch;
    }
    set isInverted(v) {
        this.i.ch = ensureBool(v);
    }
    /**
     * Gets or sets whether annotations should be shifted to avoid collision, even if this would result in them appearing where they shouldn't be along the scale.
    */
    get shouldAvoidAnnotationCollisions() {
        return this.i.cu;
    }
    set shouldAvoidAnnotationCollisions(v) {
        this.i.cu = ensureBool(v);
    }
    /**
     * ets or sets whether annotations should be kept in view, even if they aren't positioned where they should appear on the scale.
    */
    get shouldKeepAnnotationsInView() {
        return this.i.cw;
    }
    set shouldKeepAnnotationsInView(v) {
        this.i.cw = ensureBool(v);
    }
    /**
     * Gets or sets whether to use label height measurement when determining the initial number of labels to render, before resolving collisions, etc.
    */
    get usePerLabelHeightMeasurement() {
        return this.i.c5;
    }
    set usePerLabelHeightMeasurement(v) {
        this.i.c5 = ensureBool(v);
    }
    /**
     * Gets or sets whether to use more advanced heuristics when determining the initial number of labels to render, before resolving collisions, etc.
    *
    * Use `UseEnhancedIntervalManagement` property to gets/sets whether to use more advanced heuristics when determining the initial number of labels to render,
    * before resolving collisions, etc.
    */
    get useEnhancedIntervalManagement() {
        return this.i.c4;
    }
    set useEnhancedIntervalManagement(v) {
        this.i.c4 = ensureBool(v);
    }
    /**
     * Gets or sets the minimum desired characters to be displayed for horizontal axes when using advanced label heuristics. -1 will attempt to adjust the interval to precisely fit the horizontal labels.
    *
    * The `EnhancedIntervalMinimumCharacters` property is used to set the mininum desired characters to be displayed for horizontal axes when using advanced label heuristics.
    */
    get enhancedIntervalMinimumCharacters() {
        return this.i.fs;
    }
    set enhancedIntervalMinimumCharacters(v) {
        this.i.fs = +v;
    }
    /**
     * Gets or sets whether the enhanced interval management should prefer to show all the labels if possible without collisions for supported types of category axes. This is for use with EnhancedIntervalMinimumCharacters = -1 and axes that have an integral interval.
    */
    get enhancedIntervalPreferMoreCategoryLabels() {
        return this.i.b1;
    }
    set enhancedIntervalPreferMoreCategoryLabels(v) {
        this.i.b1 = ensureBool(v);
    }
    /**
     * Gets or sets the text style to use for axis labels.
    *
    * The `labelTextStyle` property Overrides the style of the text used for the axis labels.
    *
    * ```ts
    * <IgrDataChart
    *     dataSource={this.state.dataSource}
    *     width="700px"
    *     height="500px">
    *
    *     <IgrCategoryXAxis name="xAxis"
    * 		label="Year"
    * 		titleTextStyle="12pt Verdana" />
    *     <IgrNumericYAxis  name="yAxis" />
    *  </IgrDataChart>
    * ```
    *
    * ```ts
    * <IgrCategoryXAxis name="xAxis"
    *     title="Country"
    *     titleTextColor="gray"
    *     titleTextStyle="12pt Verdana"
    *     titleAngle={90} />
    * ```
    */
    get labelTextStyle() {
        return this.i.az ? this.i.az.textStyle : null;
    }
    set labelTextStyle(v) {
        this.ensureLabelSettings();
        this.i.az.textStyle = v;
    }
    /**
     * The color of the {0}.
    *
    * The `labelTextColor` property Overrides the color of the text used for the axis labels.
    *
    * ```ts
    * <IgrDataChart
    *     dataSource={this.state.dataSource}
    *     width="700px"
    *     height="500px">
    *
    *     <IgrCategoryXAxis name="xAxis"
    * 		label="Year"
    * 		labelTextColor="gray"  />
    *     <IgrNumericYAxis  name="yAxis" />
    *  </IgrDataChart>
    * ```
    *
    * ```ts
    * <IgrCategoryXAxis name="xAxis"
    *     title="Country"
    *     titleTextColor="gray"
    *     titleTextStyle="12pt Verdana"
    *     titleAngle={90} />
    * ```
    */
    get labelTextColor() {
        return brushToString(this.i.az ? this.i.az.textColor : null);
    }
    set labelTextColor(v) {
        this.ensureLabelSettings();
        this.i.az.textColor = stringToBrush(v);
    }
    /**
     * Gets or sets the location of the {0}.
    *
    * The `Location` property is used for the location.
    */
    get labelLocation() {
        return this.i.az ? this.i.az.location : 0;
    }
    set labelLocation(v) {
        this.ensureLabelSettings();
        this.i.az.location = ensureEnum(AxisLabelsLocation_$type, v);
    }
    /**
     * Gets or sets the visibility of the {0}.
    *
    * The `Visibility` property is used for the visibility of the axis.
    */
    get labelVisibility() {
        return this.i.az ? this.i.az.visibility : 0;
    }
    set labelVisibility(v) {
        this.ensureLabelSettings();
        this.i.az.visibility = ensureEnum(Visibility_$type, v);
    }
    /**
     * Gets or sets whether the first label is displayed when the zoom level is set to 1.
    *
    * The `ShowFirstLabel` is used to check whether the first label is displayed when the zoom level is set to 1.
    */
    get labelShowFirstLabel() {
        return this.i.az ? this.i.az.showFirstLabel : false;
    }
    set labelShowFirstLabel(v) {
        this.ensureLabelSettings();
        this.i.az.showFirstLabel = ensureBool(v);
    }
    /**
     * Gets or sets the angle of the {0}.
    *
    * The `Angle` property is used to set the angle of the axis.
    *
    * ```ts
    * <IgrDataChart
    *     dataSource={this.state.dataSource}
    *     width="700px"
    *     height="500px">
    *
    *     <IgrCategoryXAxis name="xAxis"
    * 		label="Year"
    * 		titleAngle={90} />
    *     <IgrNumericYAxis  name="yAxis" />
    *  </IgrDataChart>
    * ```
    *
    * ```ts
    * <IgrCategoryXAxis name="xAxis"
    *     title="Country"
    *     titleTextColor="gray"
    *     titleTextStyle="12pt Verdana"
    *     titleAngle={90} />
    * ```
    */
    get labelAngle() {
        return this.i.az ? this.i.az.angle : NaN;
    }
    set labelAngle(v) {
        this.ensureLabelSettings();
        this.i.az.angle = +v;
    }
    /**
     * Distance between the axis and the edge of the control.
    *
    * The `Extent` property is used for the extent.
    *
    * ```ts
    * <IgrDataChart
    *     dataSource={this.state.dataSource}
    *     width="700px"
    *     height="500px">
    *
    *     <IgrCategoryXAxis name="xAxis"
    * 		label="Year"/>
    *     <IgrNumericYAxis  name="yAxis" />
    *  </IgrDataChart>
    * ```
    */
    get labelExtent() {
        return this.i.az ? this.i.az.extent : NaN;
    }
    set labelExtent(v) {
        this.ensureLabelSettings();
        this.i.az.extent = +v;
    }
    /**
     * Margin applied to the left of the {0}.
    *
    * The `labelLeftMargin` property is used for the left margin of the labels.
    */
    get labelLeftMargin() {
        return this.i.az ? this.i.az.leftMargin : NaN;
    }
    set labelLeftMargin(v) {
        this.ensureLabelSettings();
        this.i.az.leftMargin = +v;
    }
    /**
     * Margin applied to the right of the {0}.
    *
    * The `labelRightMargin` property is used for the right margin of the labels.
    */
    get labelRightMargin() {
        return this.i.az ? this.i.az.rightMargin : NaN;
    }
    set labelRightMargin(v) {
        this.ensureLabelSettings();
        this.i.az.rightMargin = +v;
    }
    /**
     * Margin applied above the {0}.
    *
    * The `labelTopMargin` property is used for the top margin of the labels.
    *
    * ```ts
    * <IgrCategoryXAxis name="xAxis"
    *     label="Country"
    *     labelTextStyle="9pt Verdana"
    *     labelTopMargin={5}
    *     labelTextColor="gray" />
    * ```
    */
    get labelTopMargin() {
        return this.i.az ? this.i.az.topMargin : NaN;
    }
    set labelTopMargin(v) {
        this.ensureLabelSettings();
        this.i.az.topMargin = +v;
    }
    /**
     * Margin applied below the {0}.
    *
    * The `labelBottomMargin` is used to set the bottom margin of the labels.
    */
    get labelBottomMargin() {
        return this.i.az ? this.i.az.bottomMargin : NaN;
    }
    set labelBottomMargin(v) {
        this.ensureLabelSettings();
        this.i.az.bottomMargin = +v;
    }
    /**
     * Gets or sets the horizontal alignment of the {0}.
    *
    * The `HorizontalAlignment` property is used for the horizontal alignment.
    */
    get labelHorizontalAlignment() {
        return this.i.az ? this.i.az.horizontalAlignment : 0;
    }
    set labelHorizontalAlignment(v) {
        this.ensureLabelSettings();
        this.i.az.horizontalAlignment = ensureEnum(HorizontalAlignment_$type, v);
    }
    /**
     * Gets or sets the vertical alignment of the {0}.
    *
    * The `VerticalAlignment` property is used for the vertical alignment of the axis.
    */
    get labelVerticalAlignment() {
        return this.i.az ? this.i.az.verticalAlignment : 0;
    }
    set labelVerticalAlignment(v) {
        this.ensureLabelSettings();
        this.i.az.verticalAlignment = ensureEnum(VerticalAlignment_$type, v);
    }
    ensureLabelSettings() {
        if (this.i.az) {
            return;
        }
        this.i.az = new AxisLabelSettings();
        this.i.az.location = this.i.a0();
        this.i.az.angle = this.i.d7();
        this.i.az.leftMargin = this.i.d9();
        this.i.az.rightMargin = this.i.ea();
        this.i.az.topMargin = this.i.eb();
        this.i.az.bottomMargin = this.i.d8();
        this.i.az.horizontalAlignment = this.i.ju();
        this.i.az.verticalAlignment = this.i.ko();
    }
    /**
     * Gets or sets the CrossingAxis property.
    *
    * The `CrossingAxis` property is used for CrossingAxis .
    *
    * ```ts
    *  <IgrDataChart
    *     dataSource={this.state.dataSource} >
    *
    *     <IgrNumericXAxis name="xAxis" />
    *     <IgrNumericYAxis name="yAxis"
    * 		 crossingAxisName= "xAxis"
    * 		crossingValue= {700}/>
    *  </IgrDataChart>
    * ```
    */
    get crossingAxis() {
        const r = this.i.aj;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = IgrAxis._createFromInternal(r);
            if (e) {
                e._implementation = r;
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    set crossingAxis(v) {
        if (v != null && this._stylingContainer && v._styling)
            v._styling(this._stylingContainer, this, this);
        v == null ? this.i.aj = null : this.i.aj = v.i;
    }
    /**
    * Gets or sets the name to use to resolve crossingAxis from markup.
    */
    get crossingAxisName() {
        return this._crossingAxisName;
    }
    set crossingAxisName(v) {
        this._crossingAxisName = v;
    }
    /**
     * Gets or sets the CrossingValue property.
    *
    * The `CrossingValue` property is used for CrossingValue of the axis.
    *
    * ```ts
    *  <IgrDataChart
    *     dataSource={this.state.dataSource} >
    *
    *     <IgrNumericXAxis name="xAxis" />
    *     <IgrNumericYAxis name="yAxis"
    * 		 crossingAxis= "xAxis"
    * 		crossingValue= {700}/>
    *  </IgrDataChart>
    * ```
    */
    get crossingValue() {
        return this.i.fx;
    }
    set crossingValue(v) {
        this.i.fx = v;
    }
    /**
     * Gets or sets the title position relative to the axis labels.
    */
    get titlePosition() {
        return this.i.bf ? this.i.bf.position : 0;
    }
    set titlePosition(v) {
        this.ensureTitleSettings();
        this.i.bf.position = ensureEnum(AxisTitlePosition_$type, v);
    }
    /**
     * Gets or sets the text style to use for axis labels.
    *
    * The `labelTextStyle` property Overrides the style of the text used for the axis labels.
    *
    * ```ts
    * <IgrDataChart
    *     dataSource={this.state.dataSource}
    *     width="700px"
    *     height="500px">
    *
    *     <IgrCategoryXAxis name="xAxis"
    * 		label="Year"
    * 		titleTextStyle="12pt Verdana" />
    *     <IgrNumericYAxis  name="yAxis" />
    *  </IgrDataChart>
    * ```
    *
    * ```ts
    * <IgrCategoryXAxis name="xAxis"
    *     title="Country"
    *     titleTextColor="gray"
    *     titleTextStyle="12pt Verdana"
    *     titleAngle={90} />
    * ```
    */
    get titleTextStyle() {
        return this.i.bf ? this.i.bf.textStyle : null;
    }
    set titleTextStyle(v) {
        this.ensureTitleSettings();
        this.i.bf.textStyle = v;
    }
    /**
     * The color of the {0}.
    *
    * The `labelTextColor` property Overrides the color of the text used for the axis labels.
    *
    * ```ts
    * <IgrDataChart
    *     dataSource={this.state.dataSource}
    *     width="700px"
    *     height="500px">
    *
    *     <IgrCategoryXAxis name="xAxis"
    * 		label="Year"
    * 		labelTextColor="gray"  />
    *     <IgrNumericYAxis  name="yAxis" />
    *  </IgrDataChart>
    * ```
    *
    * ```ts
    * <IgrCategoryXAxis name="xAxis"
    *     title="Country"
    *     titleTextColor="gray"
    *     titleTextStyle="12pt Verdana"
    *     titleAngle={90} />
    * ```
    */
    get titleTextColor() {
        return brushToString(this.i.bf ? this.i.bf.textColor : null);
    }
    set titleTextColor(v) {
        this.ensureTitleSettings();
        this.i.bf.textColor = stringToBrush(v);
    }
    /**
     * Gets or sets the location of the {0}.
    *
    * The `Location` property is used for the location.
    */
    get titleLocation() {
        return this.i.bf ? this.i.bf.location : 0;
    }
    set titleLocation(v) {
        this.ensureTitleSettings();
        this.i.bf.location = ensureEnum(AxisLabelsLocation_$type, v);
    }
    /**
     * Gets or sets the visibility of the {0}.
    *
    * The `Visibility` property is used for the visibility of the axis.
    */
    get titleVisibility() {
        return this.i.bf ? this.i.bf.visibility : 0;
    }
    set titleVisibility(v) {
        this.ensureTitleSettings();
        this.i.bf.visibility = ensureEnum(Visibility_$type, v);
    }
    /**
     * Gets or sets whether the first label is displayed when the zoom level is set to 1.
    *
    * The `ShowFirstLabel` is used to check whether the first label is displayed when the zoom level is set to 1.
    */
    get titleShowFirstLabel() {
        return this.i.bf ? this.i.bf.showFirstLabel : false;
    }
    set titleShowFirstLabel(v) {
        this.ensureTitleSettings();
        this.i.bf.showFirstLabel = ensureBool(v);
    }
    /**
     * Gets or sets the angle of the {0}.
    *
    * The `Angle` property is used to set the angle of the axis.
    *
    * ```ts
    * <IgrDataChart
    *     dataSource={this.state.dataSource}
    *     width="700px"
    *     height="500px">
    *
    *     <IgrCategoryXAxis name="xAxis"
    * 		label="Year"
    * 		titleAngle={90} />
    *     <IgrNumericYAxis  name="yAxis" />
    *  </IgrDataChart>
    * ```
    *
    * ```ts
    * <IgrCategoryXAxis name="xAxis"
    *     title="Country"
    *     titleTextColor="gray"
    *     titleTextStyle="12pt Verdana"
    *     titleAngle={90} />
    * ```
    */
    get titleAngle() {
        return this.i.bf ? this.i.bf.angle : NaN;
    }
    set titleAngle(v) {
        this.ensureTitleSettings();
        this.i.bf.angle = +v;
    }
    /**
     * Distance between the axis and the edge of the control.
    *
    * The `Extent` property is used for the extent.
    *
    * ```ts
    * <IgrDataChart
    *     dataSource={this.state.dataSource}
    *     width="700px"
    *     height="500px">
    *
    *     <IgrCategoryXAxis name="xAxis"
    * 		label="Year"/>
    *     <IgrNumericYAxis  name="yAxis" />
    *  </IgrDataChart>
    * ```
    */
    get titleExtent() {
        return this.i.bf ? this.i.bf.extent : NaN;
    }
    set titleExtent(v) {
        this.ensureTitleSettings();
        this.i.bf.extent = +v;
    }
    /**
     * Margin applied to the left of the {0}.
    *
    * The `labelLeftMargin` property is used for the left margin of the labels.
    */
    get titleLeftMargin() {
        return this.i.bf ? this.i.bf.leftMargin : NaN;
    }
    set titleLeftMargin(v) {
        this.ensureTitleSettings();
        this.i.bf.leftMargin = +v;
    }
    /**
     * Margin applied to the right of the {0}.
    *
    * The `labelRightMargin` property is used for the right margin of the labels.
    */
    get titleRightMargin() {
        return this.i.bf ? this.i.bf.rightMargin : NaN;
    }
    set titleRightMargin(v) {
        this.ensureTitleSettings();
        this.i.bf.rightMargin = +v;
    }
    /**
     * Margin applied above the {0}.
    *
    * The `labelTopMargin` property is used for the top margin of the labels.
    *
    * ```ts
    * <IgrCategoryXAxis name="xAxis"
    *     label="Country"
    *     labelTextStyle="9pt Verdana"
    *     labelTopMargin={5}
    *     labelTextColor="gray" />
    * ```
    */
    get titleTopMargin() {
        return this.i.bf ? this.i.bf.topMargin : NaN;
    }
    set titleTopMargin(v) {
        this.ensureTitleSettings();
        this.i.bf.topMargin = +v;
    }
    /**
     * Margin applied below the {0}.
    *
    * The `labelBottomMargin` is used to set the bottom margin of the labels.
    */
    get titleBottomMargin() {
        return this.i.bf ? this.i.bf.bottomMargin : NaN;
    }
    set titleBottomMargin(v) {
        this.ensureTitleSettings();
        this.i.bf.bottomMargin = +v;
    }
    /**
     * Gets or sets the horizontal alignment of the {0}.
    *
    * The `HorizontalAlignment` property is used for the horizontal alignment.
    */
    get titleHorizontalAlignment() {
        return this.i.bf ? this.i.bf.horizontalAlignment : 0;
    }
    set titleHorizontalAlignment(v) {
        this.ensureTitleSettings();
        this.i.bf.horizontalAlignment = ensureEnum(HorizontalAlignment_$type, v);
    }
    /**
     * Gets or sets the vertical alignment of the {0}.
    *
    * The `VerticalAlignment` property is used for the vertical alignment of the axis.
    */
    get titleVerticalAlignment() {
        return this.i.bf ? this.i.bf.verticalAlignment : 0;
    }
    set titleVerticalAlignment(v) {
        this.ensureTitleSettings();
        this.i.bf.verticalAlignment = ensureEnum(VerticalAlignment_$type, v);
    }
    ensureTitleSettings() {
        if (this.i.bf) {
            return;
        }
        this.i.bf = new TitleSettings();
        this.i.bf.location = this.i.a1();
        this.i.bf.angle = this.i.ec();
        this.i.bf.leftMargin = this.i.ee();
        this.i.bf.rightMargin = this.i.ef();
        this.i.bf.topMargin = this.i.eg();
        this.i.bf.bottomMargin = this.i.ed();
        this.i.bf.horizontalAlignment = this.i.jv();
        this.i.bf.verticalAlignment = this.i.kp();
    }
    /**
     * Gets the current annotations for the axis.
    */
    get annotations() {
        if (this._annotations === null) {
            let coll = new IgrAxisAnnotationCollection();
            let innerColl = this.i.an;
            if (!innerColl) {
                innerColl = new AxisAnnotationCollection_internal();
            }
            this._annotations = coll._fromInner(innerColl);
        }
        return this._annotations;
    }
    set annotations(v) {
        if (this._annotations !== null) {
            this._annotations._setSyncTarget(null);
            this._annotations = null;
        }
        let coll = new IgrAxisAnnotationCollection();
        this._annotations = coll._fromOuter(v);
        let syncColl = new SyncableObservableCollection$1(IAxisAnnotation_$type);
        let innerColl = this.i.an;
        if (!innerColl) {
            innerColl = new AxisAnnotationCollection_internal();
        }
        syncColl._inner = innerColl;
        syncColl.clear();
        this._annotations._setSyncTarget(syncColl);
    }
    /**
     * Gets or sets the coercion methods to use when loading data from data sources.
     * Should be specified before setting any member paths, if being used. Setting it later
     * will not cause data to be re-imported into the chart.
    *
    * The	`coercionMethods` methods is to use when loading data from data sources. Should be specified before setting any member paths, if being used.
    * Setting it later will not cause data to be reimported into the chart.
    */
    get coercionMethods() {
        return this.i.coercionMethods;
    }
    set coercionMethods(v) {
        this.i.coercionMethods = v;
    }
    /**
     * Gets or sets whether the series should expect that properties in its items source may be functions that need to be
     * evaluated to yield their value. This defaults to false, as there will be a subtle performance impact to using this feature.
     * This value must be set before assigning an item's source to take effect.
    */
    get expectFunctions() {
        return this.i.expectFunctions;
    }
    set expectFunctions(v) {
        this.i.expectFunctions = ensureBool(v);
    }
    /**
     * Gets or sets the axis label format string.
    *
    * The `Label` property is used for label mapping of the axis labels.
    *
    * ```ts
    * <IgrCategoryXAxis name="xAxis"
    *     label="Country"
    *     labelTextStyle="9pt Verdana"
    *     labelTopMargin={5}
    *     labelTextColor="gray" />
    * ```
    */
    get label() {
        return this.i.f2;
    }
    set label(v) {
        this.i.f2 = v;
    }
    /**
     * Gets or sets the label format string to use for the label.
    */
    get labelFormat() {
        return this.i.gi;
    }
    set labelFormat(v) {
        this.i.gi = v;
    }
    /**
     * Gets or sets the format specifiers to use with the LabelFormat string.
    */
    get labelFormatSpecifiers() {
        return this.i.ah;
    }
    set labelFormatSpecifiers(v) {
        if (v && !Array.isArray(v) && typeof (v) == "string") {
            const re = /\s*(?:,|\s|$)\s*/gm;
            v = v.split(re);
        }
        this.i.ah = v;
    }
    bindAxes(axes) {
        for (let i = 0; i < axes.length; i++) {
            if (this.crossingAxisName && this.crossingAxisName.length > 0 &&
                axes[i].name == this.crossingAxisName) {
                this.crossingAxis = axes[i];
            }
        }
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        if (this.crossingAxis && this.crossingAxis.name && this.crossingAxis.name == name) {
            return this.crossingAxis;
        }
        if (this.annotations != null && this.annotations.findByName && this.annotations.findByName(name)) {
            return this.annotations.findByName(name);
        }
        if (this.labelFormatSpecifiers != null && arrayFindByName(this.labelFormatSpecifiers, name)) {
            return arrayFindByName(this.labelFormatSpecifiers, name);
        }
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("Axis");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this.crossingAxis && this.crossingAxis._styling) {
            this.crossingAxis._styling(container, component, this);
        }
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    getFullRange() {
        let iv = this.i.ag();
        return (iv);
    }
    /**
     * Renders the axis with no animation.
    
    */
    renderAxis() {
        this.i.ia();
    }
    /**
     * If using enhanced interval management and precise interval fitting, this will reset the cached maximum label width, and recalculate using the current labels.
    
    */
    resetCachedEnhancedInterval() {
        this.i.ie();
    }
    getItemValue(item, memberPathName) {
        let iv = this.i.fz(item, memberPathName);
        return (iv);
    }
    /**
     * Gets the label for a data item.
    
    * @param value  * The unscaled value to get a label for.
    */
    getValueLabel(value) {
        let iv = this.i.gf(value);
        return (iv);
    }
    /**
     * Scales a value from axis space into screen space.
    
    * @param unscaledValue  * The unscaled axis value to scale.
    */
    scaleValue(unscaledValue) {
        let iv = this.i.e6(unscaledValue);
        return (iv);
    }
    /**
     * Occurs when the axis range changes.
    */
    get rangeChanged() {
        return this._rangeChanged;
    }
    set rangeChanged(ev) {
        if (this._rangeChanged_wrapped !== null) {
            this.i.rangeChanged = delegateRemove(this.i.rangeChanged, this._rangeChanged_wrapped);
            this._rangeChanged_wrapped = null;
            this._rangeChanged = null;
        }
        this._rangeChanged = ev;
        this._rangeChanged_wrapped = (o, e) => {
            let outerArgs = new IgrAxisRangeChangedEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeRangeChanged) {
                this.beforeRangeChanged(this, outerArgs);
            }
            if (this._rangeChanged) {
                this._rangeChanged(this, outerArgs);
            }
        };
        this.i.rangeChanged = delegateCombine(this.i.rangeChanged, this._rangeChanged_wrapped);
        ;
    }
    /**
     * This event is raised every time a render has been requested from a series.
    */
    get renderRequested() {
        return this._renderRequested;
    }
    set renderRequested(ev) {
        if (this._renderRequested_wrapped !== null) {
            this.i.renderRequested = delegateRemove(this.i.renderRequested, this._renderRequested_wrapped);
            this._renderRequested_wrapped = null;
            this._renderRequested = null;
        }
        this._renderRequested = ev;
        this._renderRequested_wrapped = (o, e) => {
            let outerArgs = new IgrRenderRequestedEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeRenderRequested) {
                this.beforeRenderRequested(this, outerArgs);
            }
            if (this._renderRequested) {
                this._renderRequested(this, outerArgs);
            }
        };
        this.i.renderRequested = delegateCombine(this.i.renderRequested, this._renderRequested_wrapped);
        ;
    }
}
