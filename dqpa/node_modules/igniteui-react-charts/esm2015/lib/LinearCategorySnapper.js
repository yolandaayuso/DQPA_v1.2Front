/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { Snapper } from "./Snapper";
import { markType } from "igniteui-react-core";
import { truncate, isNaN_, isInfinity } from "igniteui-react-core";
/**
 * @hidden
 */
export let LinearCategorySnapper = /*@__PURE__*/ (() => {
    class LinearCategorySnapper extends Snapper {
        constructor(a, ..._rest) {
            super();
            this.g = 0;
            this.h = 0;
            a = (a == void 0) ? 0 : a;
            switch (a) {
                case 0:
                    {
                        let c = _rest[0];
                        let d = _rest[1];
                        let e = _rest[2];
                        let f = _rest[3];
                        let g = [c, d, e, NaN, 0, f];
                        {
                            let i = g[0];
                            let j = g[1];
                            let k = g[2];
                            let l = g[3];
                            let m = g[4];
                            let n = g[5];
                            if (n > 0) {
                                this.f = n;
                                this.b = true;
                            }
                            let o = !isNaN_(l);
                            this.g = l;
                            this.h = 0;
                            let p = Math.min(10, truncate((k / this.f)));
                            if (this.b && !isInfinity(this.f) && !isNaN_(this.f)) {
                                p = Math.min(10 + 1, truncate(((k + this.f) / this.f)));
                                if (p == 0) {
                                    p = 1;
                                }
                            }
                            if (p > 0) {
                                let q = this.i(i, j, p, true);
                                if (this.b && (q + 1) > p) {
                                    if (!o) {
                                        this.g = NaN;
                                    }
                                    else {
                                        this.g = l;
                                    }
                                    q = this.i(i, j, p - 1, true);
                                    if (this.b && (q + 1) > p) {
                                        if (!o) {
                                            this.g = NaN;
                                        }
                                        else {
                                            this.g = l;
                                        }
                                        q = this.i(i, j, p - 1, false);
                                    }
                                }
                                p = q;
                                if (k / p > this.f * 10) {
                                    this.h = 10;
                                }
                                else {
                                    if (k / p > this.f * 5) {
                                        this.h = 5;
                                    }
                                    else {
                                        if (k / p > this.f * 2) {
                                            this.h = 2;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    break;
                case 1:
                    {
                        let c = _rest[0];
                        let d = _rest[1];
                        let e = _rest[2];
                        let f = _rest[3];
                        let g = _rest[4];
                        let h = _rest[5];
                        if (h > 0) {
                            this.f = h;
                            this.b = true;
                        }
                        let i = !isNaN_(f);
                        this.g = f;
                        this.h = 0;
                        let j = Math.min(10, truncate((e / this.f)));
                        if (this.b && !isInfinity(this.f) && !isNaN_(this.f)) {
                            j = Math.min(10 + 1, truncate(((e + this.f) / this.f)));
                            if (j == 0) {
                                j = 1;
                            }
                        }
                        if (j > 0) {
                            let k = this.i(c, d, j, true);
                            if (this.b && (k + 1) > j) {
                                if (!i) {
                                    this.g = NaN;
                                }
                                else {
                                    this.g = f;
                                }
                                k = this.i(c, d, j - 1, true);
                                if (this.b && (k + 1) > j) {
                                    if (!i) {
                                        this.g = NaN;
                                    }
                                    else {
                                        this.g = f;
                                    }
                                    k = this.i(c, d, j - 1, false);
                                }
                            }
                            j = k;
                            if (e / j > this.f * 10) {
                                this.h = 10;
                            }
                            else {
                                if (e / j > this.f * 5) {
                                    this.h = 5;
                                }
                                else {
                                    if (e / j > this.f * 2) {
                                        this.h = 2;
                                    }
                                }
                            }
                        }
                    }
                    break;
            }
        }
        i(a, b, c, d) {
            let e = Snapper.e(b - a, false);
            if (isNaN_(this.g)) {
                let f = Math.max(c - 1, 1);
                this.g = Snapper.e(e / f, d);
            }
            if (this.g < 1) {
                this.g = 1;
            }
            let g = Math.floor(a / this.g) * this.g;
            let h = Math.ceil(b / this.g) * this.g;
            let i = truncate(Math.round((h - g) / this.g));
            return i;
        }
    }
    LinearCategorySnapper.$t = /*@__PURE__*/ markType(LinearCategorySnapper, 'LinearCategorySnapper', Snapper.$);
    return LinearCategorySnapper;
})();
