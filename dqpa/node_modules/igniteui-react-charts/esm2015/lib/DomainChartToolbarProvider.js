/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { Base, String_$type, fromEnum, runOn, markType } from "igniteui-react-core";
import { IDomainChartToolbarProvider_$type } from "./IDomainChartToolbarProvider";
import { ToolCommandStateChanged } from "igniteui-react-core";
import { ToolActionGroupHeaderInfo } from "igniteui-react-core";
import { ToolActionCheckboxListInfo } from "igniteui-react-core";
import { HashSet$1 } from "igniteui-react-core";
import { DomainChartCheckboxListItem } from "./DomainChartCheckboxListItem";
import { ToolActionIconMenuInfo } from "igniteui-react-core";
import { Tuple$2 } from "igniteui-react-core";
import { NativeUIComponent } from "igniteui-react-core";
import { ToolContextBindingInfo } from "igniteui-react-core";
import { ToolCommandArgument } from "igniteui-react-core";
import { ValueModeCollection } from "./ValueModeCollection";
import { BrushCollection } from "igniteui-react-core";
import { BrushUtil } from "igniteui-react-core";
/**
 * @hidden
 */
export let DomainChartToolbarProvider = /*@__PURE__*/ (() => {
    class DomainChartToolbarProvider extends Base {
        constructor() {
            super(...arguments);
            this.b = null;
            this.c = false;
            this._container = null;
            this.e = new HashSet$1(Tuple$2.$.specialize(String_$type, String_$type), 0);
            this.f = new HashSet$1(Tuple$2.$.specialize(String_$type, String_$type), 0);
            this._commandChanged = null;
            this.a = null;
        }
        get container() {
            return this._container;
        }
        set container(a) {
            this._container = a;
        }
        get commandChanged() {
            return this._commandChanged;
        }
        set commandChanged(a) {
            this._commandChanged = a;
        }
        getDesiredToolbarActions(a, b, c) {
            let d;
            if (a.itemsSource != null && NativeUIComponent.v(16, 0)) {
                let e = new ToolActionGroupHeaderInfo();
                e.name = "AxisFieldLabelHeader";
                e.title = "Label Fields";
                let f = new ToolActionCheckboxListInfo();
                f.name = "AxisFieldLabel";
                let g = new ToolActionGroupHeaderInfo();
                g.name = "AxisFieldValueHeader";
                g.title = "Value Fields";
                let h = new ToolActionCheckboxListInfo();
                h.name = "AxisFieldValue";
                let i = a.includedProperties == null ? null : new HashSet$1(String_$type, 1, a.includedProperties);
                let j = 0;
                if (i != null && a.excludedProperties != null && a.excludedProperties.length > 0) {
                    let k = new HashSet$1(String_$type, 1, a.excludedProperties);
                    for (let l of fromEnum(k)) {
                        if (i.contains(l)) {
                            i.remove(l);
                        }
                    }
                    let m = i.count;
                    let n = new Array(m);
                    j = 0;
                    for (let o of fromEnum(i)) {
                        n[j] = o;
                        j++;
                    }
                }
                a.currentDataAdapter.az(this.e, this.f);
                j = 0;
                let p = new Array(this.e.count);
                for (let q of fromEnum(this.e)) {
                    p[j] = ((() => {
                        let $ret = new DomainChartCheckboxListItem();
                        $ret.key = q.c;
                        $ret.label = q.d;
                        $ret.isSelected = i == null || i.contains(q.c);
                        return $ret;
                    })());
                    j++;
                }
                c.setContextValue("AxisFieldLabels", 7, p);
                f.dataMemberPath = "label";
                f.selectedMemberPath = "isSelected";
                f.primaryKey = ["key"];
                f.contextBindings = [((() => {
                        let $ret = new ToolContextBindingInfo();
                        $ret.bindingMode = 0;
                        $ret.contextKey = "AxisFieldLabels";
                        $ret.propertyName = "ItemsSource";
                        return $ret;
                    })())];
                let r = new Array(this.f.count);
                j = 0;
                for (let s of fromEnum(this.f)) {
                    r[j] = ((() => {
                        let $ret = new DomainChartCheckboxListItem();
                        $ret.key = s.c;
                        $ret.label = s.d;
                        $ret.isSelected = i == null || i.contains(s.c);
                        return $ret;
                    })());
                    j++;
                }
                c.setContextValue("AxisFieldValues", 7, r);
                h.dataMemberPath = "label";
                h.selectedMemberPath = "isSelected";
                h.primaryKey = ["key"];
                h.contextBindings = [((() => {
                        let $ret = new ToolContextBindingInfo();
                        $ret.bindingMode = 0;
                        $ret.contextKey = "AxisFieldValues";
                        $ret.propertyName = "ItemsSource";
                        return $ret;
                    })())];
                let t = new ToolActionIconMenuInfo();
                t.name = "AxisFieldMenu";
                t.iconName = "analyze-valuelabels-showlast";
                t.iconCollectionName = "ChartToolbarIcons";
                t.iconWidth = 24;
                t.iconHeight = 25;
                t.actions = [e, f, g, h];
                d = new Array(b.length + 1);
                for (let u = 0; u < b.length; u++) {
                    d[u] = b[u];
                }
                d[b.length] = t;
            }
            else {
                d = b;
            }
            for (let v = 0; v < d.length; v++) {
                this.g(a, d[v]);
            }
            return d;
        }
        g(a, b) {
            if (b.actions != null && b.actions.length > 0) {
                for (let c = 0; c < b.actions.length; c++) {
                    this.g(a, b.actions[c]);
                }
            }
            switch (b.name) {
                case "ShowCrosshairs":
                    {
                        let d = b;
                        d.isChecked = a.crosshairsDisplayMode != 1;
                    }
                    break;
                case "ShowGridlines":
                    {
                        let e = b;
                        e.isChecked = a.autoCalloutsVisible;
                    }
                    break;
                case "ShowValueLabels":
                    {
                        let f = b;
                        f.isChecked = a.autoCalloutsVisible;
                    }
                    break;
                case "ShowLastValueLabel":
                    {
                        let g = b;
                        g.isChecked = a.finalValueAnnotationsVisible;
                    }
                    break;
                case "MinValue":
                    {
                        if (a.valueLines != null) {
                            let h = b;
                            for (let i = 0; i < a.valueLines.count; i++) {
                                if (a.valueLines._inner[i] == 4) {
                                    h.isChecked = true;
                                    break;
                                }
                            }
                        }
                    }
                    break;
                case "MaxValue":
                    {
                        if (a.valueLines != null) {
                            let j = b;
                            for (let k = 0; k < a.valueLines.count; k++) {
                                if (a.valueLines._inner[k] == 5) {
                                    j.isChecked = true;
                                    break;
                                }
                            }
                        }
                    }
                    break;
                case "Average":
                    {
                        if (a.valueLines != null) {
                            let l = b;
                            for (let m = 0; m < a.valueLines.count; m++) {
                                if (a.valueLines._inner[m] == 6) {
                                    l.isChecked = true;
                                    break;
                                }
                            }
                        }
                    }
                    break;
                case "SeriesAvg":
                    {
                        if (a.valueLines != null) {
                            let n = b;
                            for (let o = 0; o < a.valueLines.count; o++) {
                                if (a.valueLines._inner[o] == 3) {
                                    n.isChecked = true;
                                    break;
                                }
                            }
                        }
                    }
                    break;
                case "AxisFieldLabel":
                    {
                    }
                    break;
                case "AxisFieldValue":
                    {
                    }
                    break;
            }
            this.h(a, b);
        }
        h(a, b) {
        }
        onToolCommandExecuting(a, b) {
            this.c = true;
            let c = 0;
            switch (b.commandId) {
                case "ZoomReset":
                    this.ad(a, b);
                    break;
                case "ZoomIn":
                    this.ab(a, b);
                    break;
                case "ZoomOut":
                    this.ac(a, b);
                    break;
                case "ShowCrosshairs":
                    this.o(a, b);
                    break;
                case "ShowGridlines":
                    this.q(a, b);
                    break;
                case "MaxValue":
                    this.u(a, b);
                    break;
                case "MinValue":
                    this.v(a, b);
                    break;
                case "Average":
                    this.j(a, b);
                    break;
                case "Exponential":
                    this.p(a, b);
                    break;
                case "Linear":
                    this.s(a, b);
                    break;
                case "Logarithmic":
                    this.t(a, b);
                    break;
                case "NoTrends":
                    this.w(a, b);
                    break;
                case "SeriesAvg":
                    this.x(a, b);
                    break;
                case "ShowValueLabels":
                    this.z(a, b);
                    break;
                case "ShowLastValueLabel":
                    this.y(a, b);
                    break;
                case "CopyAsImage":
                    this.n(a, b);
                    c = 2;
                    break;
                case "AxisFieldLabel":
                    this.l(a, b);
                    break;
                case "AxisFieldValue":
                    this.m(a, b);
                    break;
            }
            this.c = false;
            return c;
        }
        onTargetPropertyChanged(a, b, c, d) {
            if (this.c) {
                return;
            }
            switch (b) {
                case "CrosshairsDisplayMode":
                    if (a.crosshairsDisplayMode == 1) {
                        this.i("ShowCrosshairs", 2, false);
                    }
                    else {
                        this.i("ShowCrosshairs", 2, true);
                    }
                    break;
                case "AutoCalloutsVisible":
                    this.i("ShowValueLabels", 2, a.autoCalloutsVisible);
                    break;
                case "FinalValueAnnotationsVisible":
                    this.i("ShowLastValueLabel", 2, a.finalValueAnnotationsVisible);
                    break;
            }
            this.aa(a, b, c, d);
        }
        aa(a, b, c, d) {
        }
        i(a, b, c) {
            if (this.commandChanged != null) {
                this.commandChanged(((() => {
                    let $ret = new ToolCommandStateChanged();
                    $ret.c = a;
                    $ret.a = b;
                    $ret.b = c;
                    return $ret;
                })()));
            }
        }
        d(a, b) {
            if (a.commandId == b) {
                let e = a.argumentsList;
                for (let d = 0; d < e.length; d++) {
                    let c = e[d];
                    if (c.argumentName == "IsChecked") {
                        return c.value;
                    }
                }
            }
            return false;
        }
        o(a, b) {
            if (this.d(b, "ShowCrosshairs")) {
                a.crosshairsDisplayMode = 0;
                a.crosshairsAnnotationEnabled = true;
            }
            else {
                a.crosshairsDisplayMode = 1;
            }
        }
        q(a, b) {
        }
        p(a, b) {
            if (this.d(b, "Exponential")) {
                a.trendLineType = 7;
            }
            else {
                a.trendLineType = 0;
            }
        }
        s(a, b) {
            if (this.d(b, "Linear")) {
                a.trendLineType = 1;
            }
            else {
                a.trendLineType = 0;
            }
        }
        t(a, b) {
            if (this.d(b, "Logarithmic")) {
                a.trendLineType = 6;
            }
            else {
                a.trendLineType = 0;
            }
        }
        w(a, b) {
            if (this.d(b, "NoTrends")) {
                a.trendLineType = 0;
            }
        }
        u(a, b) {
            if (this.d(b, "MaxValue")) {
                if (a.valueLines == null) {
                    a.valueLines = new ValueModeCollection();
                }
                if (a.valueLinesBrushes == null) {
                    a.valueLinesBrushes = new BrushCollection();
                }
                a.valueLines.add(5);
                a.valueLinesBrushes.add(BrushUtil.h(255, 99, 208, 0));
            }
            else {
                for (let c = 0; c < a.valueLines.count; c++) {
                    if (a.valueLines._inner[c] == 5) {
                        a.valueLines.removeAt(c);
                        a.valueLinesBrushes.removeAt(c);
                        c--;
                    }
                }
            }
        }
        v(a, b) {
            if (this.d(b, "MinValue")) {
                if (a.valueLines == null) {
                    a.valueLines = new ValueModeCollection();
                }
                if (a.valueLinesBrushes == null) {
                    a.valueLinesBrushes = new BrushCollection();
                }
                a.valueLines.add(4);
                a.valueLinesBrushes.add(BrushUtil.h(255, 246, 93, 80));
            }
            else {
                for (let c = 0; c < a.valueLines.count; c++) {
                    if (a.valueLines._inner[c] == 4) {
                        a.valueLines.removeAt(c);
                        a.valueLinesBrushes.removeAt(c);
                        c--;
                    }
                }
            }
        }
        j(a, b) {
            if (this.d(b, "Average")) {
                if (a.valueLines == null) {
                    a.valueLines = new ValueModeCollection();
                }
                if (a.valueLinesBrushes == null) {
                    a.valueLinesBrushes = new BrushCollection();
                }
                a.valueLines.add(6);
                a.valueLinesBrushes.add(BrushUtil.h(255, 248, 173, 118));
            }
            else {
                for (let c = 0; c < a.valueLines.count; c++) {
                    if (a.valueLines._inner[c] == 6) {
                        a.valueLines.removeAt(c);
                        a.valueLinesBrushes.removeAt(c);
                        c--;
                    }
                }
            }
        }
        x(a, b) {
            if (this.d(b, "SeriesAvg")) {
                if (a.valueLines == null) {
                    a.valueLines = new ValueModeCollection();
                }
                if (a.valueLinesBrushes == null) {
                    a.valueLinesBrushes = new BrushCollection();
                }
                a.valueLines.add(3);
                a.valueLinesBrushes.add(BrushUtil.h(0, 0, 0, 0));
            }
            else {
                for (let c = 0; c < a.valueLines.count; c++) {
                    if (a.valueLines._inner[c] == 3) {
                        a.valueLines.removeAt(c);
                        a.valueLinesBrushes.removeAt(c);
                        c--;
                    }
                }
            }
        }
        z(a, b) {
            if (this.d(b, "ShowValueLabels")) {
                a.autoCalloutsVisible = true;
            }
            else {
                a.autoCalloutsVisible = false;
            }
        }
        y(a, b) {
            if (this.d(b, "ShowLastValueLabel")) {
                a.finalValueAnnotationsVisible = true;
                a.shouldAvoidAxisAnnotationCollisions = true;
            }
            else {
                a.finalValueAnnotationsVisible = false;
            }
        }
        n(a, b) {
            this.b = b;
            a.captureTargetImageToClipboard(runOn(this, this.r));
        }
        l(a, b) {
            this.k(a, b, "AxisFieldLabel");
        }
        m(a, b) {
            this.k(a, b, "AxisFieldValue");
        }
        k(a, b, c) {
            if (b.argumentsList.length != 3) {
                return;
            }
            let d = b.argumentsList[2].value;
            let e = (d[0]);
            let f = false;
            if (a.includedProperties != null) {
                let i = a.includedProperties;
                for (let h = 0; h < i.length; h++) {
                    let g = i[h];
                    if (g == e) {
                        f = true;
                        break;
                    }
                }
            }
            let j = false;
            if (a.excludedProperties != null) {
                let m = a.excludedProperties;
                for (let l = 0; l < m.length; l++) {
                    let k = m[l];
                    if (k == e) {
                        j = true;
                        break;
                    }
                }
            }
            if (this.d(b, c)) {
                if (a.includedProperties == null) {
                    a.includedProperties = new Array(0);
                }
                if (!f) {
                    let n = new Array(a.includedProperties.length + 1);
                    for (let o = 0; o < a.includedProperties.length; ++o) {
                        n[o] = a.includedProperties[o];
                    }
                    n[a.includedProperties.length] = e;
                    a.includedProperties = n;
                }
                if (j) {
                    if (a.excludedProperties.length == 1) {
                        a.excludedProperties = new Array(0);
                    }
                    else {
                        let p = new Array(a.excludedProperties.length - 1);
                        let q = -1;
                        let r = 0;
                        while (r < p.length) {
                            q++;
                            if (a.excludedProperties[q] == e) {
                                continue;
                            }
                            p[r] = a.excludedProperties[q];
                            r++;
                        }
                        a.excludedProperties = p;
                    }
                }
            }
            else if ((a.includedProperties == null || a.includedProperties.length == 0) && (this.e.count + this.f.count > 1)) {
                let s = this.e.count + this.f.count - 1;
                let t = new Array(s);
                let u = 0;
                for (let v of fromEnum(this.e)) {
                    if (v.c == e) {
                        continue;
                    }
                    t[u] = v.c;
                    u++;
                }
                for (let w of fromEnum(this.f)) {
                    if (w.c == e) {
                        continue;
                    }
                    t[u] = w.c;
                    u++;
                }
                a.includedProperties = t;
            }
            else if (f) {
                if (a.includedProperties.length == 1) {
                    a.includedProperties = new Array(0);
                }
                else {
                    let x = new Array(a.includedProperties.length - 1);
                    let y = -1;
                    let z = 0;
                    while (z < x.length) {
                        y++;
                        if (a.includedProperties[y] == e) {
                            continue;
                        }
                        x[z] = a.includedProperties[y];
                        z++;
                    }
                    a.includedProperties = x;
                }
            }
        }
        r(a, b) {
            let c = b;
            if (this.b.argumentsList == null || this.b.argumentsList.length < 1) {
                this.b.argumentsList = new Array(1);
                this.b.argumentsList[0] = ((() => {
                    let $ret = new ToolCommandArgument();
                    $ret.argumentName = "image";
                    return $ret;
                })());
            }
            this.b.argumentsList[0].value = c.base64Data;
            if (this.a != null) {
                this.a.sendCommandCompleted(this.b);
            }
        }
        ab(a, b) {
            a.zoomIn(0.05);
        }
        ac(a, b) {
            a.zoomOut(0.05);
        }
        ad(a, b) {
            a.resetZoom();
        }
    }
    DomainChartToolbarProvider.$t = /*@__PURE__*/ markType(DomainChartToolbarProvider, 'DomainChartToolbarProvider', Base.$, [IDomainChartToolbarProvider_$type]);
    return DomainChartToolbarProvider;
})();
