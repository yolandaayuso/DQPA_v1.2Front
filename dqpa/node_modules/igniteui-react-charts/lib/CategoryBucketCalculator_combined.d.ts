import { Base, Type, Point } from "igniteui-react-core";
import { IBucketizer } from "./IBucketizer";
import { IFastItemColumn$1 } from "igniteui-react-core";
import { Rect } from "igniteui-react-core";
import { CategoryAxisBase } from "./CategoryAxisBase";
import { ScalerParams } from "./ScalerParams";
import { SeriesView } from "./SeriesView";
import { Axis } from "./Axis";
import { FramePreparer } from "./FramePreparer";
import { IIsCategoryBased } from "./IIsCategoryBased";
import { List$1 } from "igniteui-react-core";
import { ISupportsMarkers } from "./ISupportsMarkers";
import { IProvidesViewport } from "./IProvidesViewport";
import { ISupportsErrorBars } from "./ISupportsErrorBars";
import { CategoryFrame } from "./CategoryFrame";
import { IDetectsCollisions } from "./IDetectsCollisions";
import { PreparationParams } from "./PreparationParams";
import { Frame } from "./Frame";
import { ICategoryScaler } from "./ICategoryScaler";
import { ValuesHolder } from "./ValuesHolder";
import { NumericAxisBase } from "./NumericAxisBase";
import { IHasCategoryTrendline } from "./IHasCategoryTrendline";
import { IHasSingleValueCategory } from "./IHasSingleValueCategory";
import { MarkerSeries } from "./MarkerSeries";
import { IHasCategoryModePreference } from "./IHasCategoryModePreference";
import { ICategorySeriesInteractionManager } from "./ICategorySeriesInteractionManager";
import { CategoryCollisionMode } from "./CategoryCollisionMode";
import { CategoryTransitionInMode } from "./CategoryTransitionInMode";
import { HighlightingInfo } from "igniteui-react-core";
import { CategoryTransitionSourceFramePreparer } from "./CategoryTransitionSourceFramePreparer";
import { SeriesPointOfInterest } from "./SeriesPointOfInterest";
import { Marker } from "./Marker";
import { MarkerSeriesView } from "./MarkerSeriesView";
import { CategoryMode } from "./CategoryMode";
import { CategorySeriesRenderManager } from "./CategorySeriesRenderManager";
import { AssigningCategoryStyleEventArgs } from "./AssigningCategoryStyleEventArgs";
import { AssigningCategoryMarkerStyleEventArgs } from "./AssigningCategoryMarkerStyleEventArgs";
import { SeriesComponentsForView } from "./SeriesComponentsForView";
import { Pool$1 } from "igniteui-react-core";
import { TransitionInSpeedType } from "./TransitionInSpeedType";
import { TransitionOutSpeedType } from "./TransitionOutSpeedType";
import { SeriesLayerPropertyOverlay } from "./SeriesLayerPropertyOverlay";
import { RenderSurface } from "./RenderSurface";
import { Clipper } from "igniteui-react-core";
import { ChartSelection } from "./ChartSelection";
import { SeriesSelectionBehavior } from "./SeriesSelectionBehavior";
import { ValueCollisionMode } from "./ValueCollisionMode";
/**
 * @hidden
 */
export declare class CategoryBucketCalculator extends Base implements IBucketizer {
    static $t: Type;
    protected c: CategorySeriesView;
    constructor(a: CategorySeriesView);
    e: number;
    f: number;
    d: number;
    getBucket(a: number): number[];
    getBucketWithoutUnknowns(a: number): number[];
    getErrorBucket(a: number, b: IFastItemColumn$1<number>): number;
    g(a: number): void;
    getBucketInfo(a: number, b: number, c: number, d: number): {
        p0: number;
        p1: number;
        p2: number;
        p3: number;
    };
    cacheValues(): void;
    unCacheValues(): void;
}
/**
 * @hidden
 */
export declare abstract class CategoryFramePreparerBase extends FramePreparer {
    static $t: Type;
    constructor(a: number, b: IIsCategoryBased);
    constructor(a: number, b: IIsCategoryBased, c: ISupportsMarkers, d: IProvidesViewport, e: ISupportsErrorBars, f: IBucketizer);
    constructor(a: number, ..._rest: any[]);
    g: IBucketizer;
    h: IIsCategoryBased;
    protected abstract l(a: CategoryFrame, b: number[], c: IDetectsCollisions, d: number, e: number, f: number): boolean;
    m: boolean;
    private i;
    r(a: ICategoryScaler, b: Rect, c: Rect, d: Rect): number;
    private s;
    d(a: Frame, b: SeriesView): void;
    protected v(a: CategoryFrame, b: SeriesView): void;
    private o;
    protected get q(): List$1<number[]>;
    private p;
    private n;
    protected t(a: PreparationParams, b: ValuesHolder, c: number, d: boolean, e: boolean): number;
    protected k(): boolean;
    protected abstract z(a: ValuesHolder, b: number, c: boolean, d: boolean): void;
    protected abstract u(a: ValuesHolder, b: number, c: boolean): void;
    protected abstract e(a: number, b: ValuesHolder): number[];
    protected f(a: PreparationParams, b: number, c: ValuesHolder, d: number, e: boolean, f: number[], g: number): {
        ret: number[];
        p1?: number;
        p4: boolean;
        p5: number[];
    };
    protected y(a: PreparationParams, b: number, c: boolean, d: ScalerParams, e: ScalerParams, f: boolean, g: boolean): void;
    protected abstract x(a: PreparationParams, b: number[], c: number, d: boolean, e: ScalerParams, f: ScalerParams): void;
    protected w(a: PreparationParams, b: ValuesHolder, c: number): void;
    protected abstract j(a: PreparationParams): ValuesHolder;
}
/**
 * @hidden
 */
export declare class CategoryFramePreparer extends CategoryFramePreparerBase {
    static $t: Type;
    constructor(a: number, b: IIsCategoryBased);
    constructor(a: number, b: IIsCategoryBased, c: ISupportsMarkers, d: IProvidesViewport, e: ISupportsErrorBars, f: IBucketizer);
    constructor(a: number, ..._rest: any[]);
    private aa;
    private ab;
    protected ac: IHasCategoryTrendline;
    protected ad: IHasSingleValueCategory;
    protected l(a: CategoryFrame, b: number[], c: IDetectsCollisions, d: number, e: number, f: number): boolean;
    protected j(a: PreparationParams): ValuesHolder;
    protected x(a: PreparationParams, b: number[], c: number, d: boolean, e: ScalerParams, f: ScalerParams): void;
    protected y(a: PreparationParams, b: number, c: boolean, d: ScalerParams, e: ScalerParams, f: boolean, g: boolean): void;
    protected w(a: PreparationParams, b: ValuesHolder, c: number): void;
    protected z(a: ValuesHolder, b: number, c: boolean, d: boolean): void;
    protected u(a: ValuesHolder, b: number, c: boolean): void;
    protected e(a: number, b: ValuesHolder): number[];
}
/**
 * @hidden
 */
export declare abstract class CategorySeries extends MarkerSeries implements IHasCategoryModePreference, ISupportsErrorBars {
    static $t: Type;
    yz: CategoryFramePreparer;
    protected cs(): SeriesView;
    y3: CategorySeriesView;
    private y7;
    get y8(): ICategorySeriesInteractionManager;
    eb(a: List$1<SeriesPointOfInterest>, b: boolean, c: boolean, d: number, e: boolean): boolean;
    private zz;
    q1(a: SeriesView): void;
    preferredCategoryMode(a: CategoryAxisBase): CategoryMode;
    get categoryAxis(): CategoryAxisBase;
    ys(): CategoryAxisBase;
    y9(): NumericAxisBase;
    protected get_ek(): boolean;
    protected get_f5(): boolean;
    protected get_ey(): boolean;
    constructor();
    ac(): void;
    zk: boolean;
    zj: boolean;
    yt: CategoryCollisionMode;
    protected zg: boolean;
    protected zf: boolean;
    assigningCategoryStyle: (sender: any, args: AssigningCategoryStyleEventArgs) => void;
    assigningCategoryMarkerStyle: (sender: any, args: AssigningCategoryMarkerStyleEventArgs) => void;
    zm(): boolean;
    protected zn(): boolean;
    protected aaj(a: AssigningCategoryStyleEventArgs): void;
    protected aai(a: AssigningCategoryMarkerStyleEventArgs): void;
    ym(a: number, b: number): any[];
    o5(a: boolean, b: SeriesView): void;
    br(): SeriesComponentsForView;
    qb(): void;
    zq: boolean;
    protected sr(a: Rect, b: Rect): void;
    y5: CategoryTransitionInMode;
    zl: boolean;
    protected sq(a: Rect, b: Rect): void;
    protected q9(a: any, b: string, c: any, d: any): void;
    protected zi(): boolean;
    protected zh(): boolean;
    zt(a: Point): number;
    protected get_fs(): boolean;
    a0(): CategoryAxisBase;
    j5(a: Point): number;
    abstract getOffsetValue(): number;
    abstract getCategoryWidth(): number;
    kn(a: Point): any;
    j3(a: Point): number;
    ir(a: Point): number;
    private zd;
    private ze;
    dh(a: any, b: Point, c: boolean): HighlightingInfo;
    protected get_fe(): boolean;
    o3(): void;
    dg(a: any, b: Point, c: boolean): HighlightingInfo;
    protected zs(): List$1<Marker>;
    protected zc(a: any, b: Point, c: HighlightingInfo): HighlightingInfo;
    protected zb(a: any, b: Point, c: HighlightingInfo): HighlightingInfo;
    protected za(a: any, b: Point, c: HighlightingInfo): HighlightingInfo;
    yw: CategoryFrame;
    yy: CategoryFrame;
    yu: CategoryFrame;
    yx: CategoryFrame;
    yv(): CategoryFrame;
    y2: CategorySeriesRenderManager;
    protected aaf(a: List$1<number[]>, b: number, c: number, d: CategoryAxisBase, e: ScalerParams, f: boolean, g: number): void;
    aag(a: List$1<number[]>, b: number, c: number, d: CategoryAxisBase, e: ScalerParams, f: boolean, g: number): void;
    he(a: Rect, b: Rect, c: SeriesView): boolean;
    private zr;
    protected gn(): boolean;
    protected go(): boolean;
    protected y4(): CategoryTransitionInMode;
    y6: CategoryTransitionSourceFramePreparer;
    protected o6(): void;
    rs(a: boolean): void;
    protected c4(): TransitionInSpeedType;
    protected c7(): TransitionOutSpeedType;
    protected zu(): number;
    protected zo(): boolean;
    protected ht(): List$1<SeriesLayerPropertyOverlay>;
    kv(): any;
    zy(): number;
    get GetErrorBarsXAxis(): Axis;
    get GetErrorBarsYAxis(): Axis;
    z9(a: CategorySeriesView, b: CategoryFrame): void;
    aak(a: CategoryFrame, b: CategorySeriesView): void;
    aah(a: CategoryFrame, b: CategorySeriesView): void;
    zv(a: SeriesView): number;
    zw(a: SeriesView): number;
    zx(a: SeriesView): number;
    z8(a: SeriesView): void;
    rt(a: Rect, b: RenderSurface): void;
    aal(): void;
    abstract fetchXAxis(): Axis;
    abstract fetchYAxis(): Axis;
    abstract zp(): boolean;
    y0(a: CategorySeriesView): CategoryFramePreparer;
    aw(a: Axis): Axis;
    ai(): Axis[];
    static yn(a: List$1<number[]>, b: number, c: Rect, d: Rect, e: boolean): Clipper;
    aac(a: Rect, b: List$1<ChartSelection>, c: SeriesSelectionBehavior, d: CategoryCollisionMode, e: ValueCollisionMode): void;
    aae(a: List$1<ChartSelection>, b: number, c: number, d: SeriesSelectionBehavior): void;
    abstract aad(a: ValueCollisionMode, b: List$1<ChartSelection>, c: number, d: number, e: number, f: number, g: SeriesSelectionBehavior): void;
    abstract z7(a: List$1<ChartSelection>, b: number, c: SeriesSelectionBehavior): void;
    aaa(a: Rect, b: NumericAxisBase, c: boolean, d: Rect, e: number, f: number): {
        p4: number;
        p5: number;
    };
    aab(a: Rect, b: CategoryAxisBase, c: boolean, d: Rect, e: number, f: number): {
        p4: number;
        p5: number;
    };
    static $$p: string[];
}
/**
 * @hidden
 */
export declare class CategorySeriesView extends MarkerSeriesView implements ISupportsMarkers {
    static $t: Type;
    cy: CategorySeries;
    c1: number;
    c0(a: CategoryFrame): boolean;
    c3(a: CategoryFrame): void;
    constructor(a: CategorySeries);
    updateMarkerTemplate(a: number, b: number, c: number): void;
    cw: CategoryBucketCalculator;
    cx(): CategoryBucketCalculator;
    cz: Pool$1<Marker>;
    get shouldDisplayMarkers(): boolean;
    updateMarkerCount(a: number): void;
    cj(a: (arg1: Marker) => void): void;
    c2(): void;
}
