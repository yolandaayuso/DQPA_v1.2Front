import * as React from 'react';
import { ReactRenderer } from "igniteui-react-core";
import { Visibility } from "igniteui-react-core";
import { IgRect } from "igniteui-react-core";
import { IgPoint } from "igniteui-react-core";
import { IgDataTemplate } from "igniteui-react-core";
import { TransitionInSpeedType } from './TransitionInSpeedType';
import { SeriesHitTestMode } from './SeriesHitTestMode';
import { IgrAxis } from './igr-axis';
import { Series } from './Series';
import { IgrRenderRequestedEventArgs } from './igr-render-requested-event-args';
import { IChartTooltipProps } from "igniteui-react-core";
import { SeriesVisibleRangeMode } from './SeriesVisibleRangeMode';
import { SeriesHighlightingMode } from './SeriesHighlightingMode';
import { SeriesOutlineMode } from './SeriesOutlineMode';
import { LegendItemBadgeMode } from "igniteui-react-core";
import { LegendItemBadgeShape } from "igniteui-react-core";
import { PenLineJoin } from "igniteui-react-core";
import { PenLineCap } from "igniteui-react-core";
import { ValueLayerValueMode } from './ValueLayerValueMode';
import { IgrSeriesLayerCollection } from './igr-series-layer-collection';
import { TransitionOutSpeedType } from './TransitionOutSpeedType';
import { SeriesHighlightedValuesDisplayMode } from "igniteui-react-core";
import { IgrSeriesLayerPropertyOverlayCollection } from './igr-series-layer-property-overlay-collection';
import { SeriesSelectionMode } from './SeriesSelectionMode';
import { IgrTransitionOutCompletedEventArgs } from './igr-transition-out-completed-event-args';
/**
 * Represents the base class for all IgxDataChartComponent series.
*/
export declare abstract class IgrSeries<P extends IIgrSeriesProps = IIgrSeriesProps> extends React.Component<P, {}> {
    protected _implementation: any;
    get i(): Series;
    private onImplementationCreated;
    protected createImplementation(): Series;
    constructor(props: P);
    componentDidMount(): void;
    get seriesInternal(): any;
    shouldComponentUpdate(nextProps: any, nextState: any): boolean;
    render(): any;
    protected set name(value: string);
    protected get name(): string;
    private _chartLevelData;
    provideData(data: any[]): void;
    protected onUpdateDataSource(dataSource: any): any;
    private updateDataSource;
    private _dataSource;
    set dataSource(value: any);
    get dataSource(): any;
    private _chartLevelHighlightedData;
    provideHighlightedData(data: any[]): void;
    protected onUpdatehighlightedDataSource(highlightedDataSource: any): any;
    private updatehighlightedDataSource;
    private _highlightedDataSource;
    set highlightedDataSource(value: any);
    get highlightedDataSource(): any;
    bindAxes(axes: IgrAxis[]): void;
    private _tooltipTemplate;
    private _tooltipContent;
    set tooltipTemplate(value: React.FunctionComponent<IChartTooltipProps> | React.Component<IChartTooltipProps>);
    get tooltipTemplate(): React.FunctionComponent<IChartTooltipProps> | React.Component<IChartTooltipProps>;
    private _tooltipContainerTemplate;
    set tooltipContainerTemplate(value: React.FunctionComponent<IChartTooltipProps> | React.Component<IChartTooltipProps>);
    get tooltipContainerTemplate(): React.FunctionComponent<IChartTooltipProps> | React.Component<IChartTooltipProps>;
    private _ensureTooltipCreated;
    private _ensureTooltipDestroyed;
    private _renderer;
    protected _provideRenderer(renderer: ReactRenderer): void;
    static _createFromInternal(internal: any): IgrSeries;
    /**
     * Gets or sets the legend used for the current series.
    */
    get legend(): any;
    set legend(v: any);
    /**
 * Gets unique key used to identify the series in data legend
*/
    get dataLegendKey(): string;
    /**
     * Gets or sets a name used for grouping multiple series in the Data Legend
     * If not set, series will be grouped by series family, e.g. Category, Range, Financial, Scatter
    */
    get dataLegendGroup(): string;
    set dataLegendGroup(v: string);
    /**
     * Gets or sets a name used for grouping highlighted series in the Data Legend
     * If not set, series will default to parent series' DataLegendGroup, e.g. Category, Range, Financial, Scatter
    */
    get highlightedValuesDataLegendGroup(): string;
    set highlightedValuesDataLegendGroup(v: string);
    /**
     * Gets whether the series is an annotation layer.
    *
    * ```ts
    * let isAnnotationLayer: boolean = this.series.isAnnotationLayer;
    * ```
    */
    get isAnnotationLayer(): boolean;
    /**
     * Gets whether the series is an crosshair annotation layer.
    */
    get isAnnotationCrosshairLayer(): boolean;
    /**
     * Gets whether the series is an callout annotation layer.
    */
    get isAnnotationCalloutLayer(): boolean;
    /**
     * Gets whether the series is an annotation layer displayed only when hovering over the chart.
     * Crosshair Layer, Category Highlight Layer, Category Tooltip Layer, Item Tooltip Layer
    */
    get isAnnotationHoverLayer(): boolean;
    /**
     * Gets whether the series is final value annotation layer.
    */
    get isAnnotationFinalValue(): boolean;
    /**
     * Gets whether the series is a value annotation layer.
    */
    get isAnnotationValueLayer(): boolean;
    /**
     * Gets whether the current series is oriented vertically.
    *
    * ```ts
    * let isVertical: boolean = this.series.isVertical;
    * ```
    */
    get isVertical(): boolean;
    /**
     * Gets whether the current series is a stack fragment.
    *
    * ```ts
    * let isFragment: boolean = this.series.isFragment;
    * ```
    */
    get isFragment(): boolean;
    /**
     * Gets whether the current series shows an area or line shape.
    *
    * ```ts
    * let isAreaorLine: boolean = this.series.isAreaorLine;
    * ```
    */
    get isAreaOrLine(): boolean;
    /**
     * Gets whether the current series shows an area shape.
    */
    get isArea(): boolean;
    /**
     * Gets whether the current series shows an area shape.
    */
    get hasValueAxis(): boolean;
    /**
     * Gets whether the current series shows an area shape.
    */
    get isValueAxisInverted(): boolean;
    /**
     * Gets whether the current series shows only line shapes.
    */
    get isLineOnly(): boolean;
    /**
     * Gets whether the current series shows a line contour shape.
    */
    get isLineContour(): boolean;
    /**
     * Gets whether the current series shows a spline shape.
    */
    get isSpline(): boolean;
    /**
     * Gets whether the current series shows a column shape.
    */
    get isColumn(): boolean;
    /**
     * Gets whether the current series shows a horizontal column shape.
    */
    get isBar(): boolean;
    /**
     * Gets whether the current series shows a waterfall column shape.
    */
    get isWaterfall(): boolean;
    /**
     * Gets whether the current series shows a polyline shape.
    */
    get isPolyline(): boolean;
    /**
     * Gets whether the current series shows a polygon shape.
    */
    get isPolygon(): boolean;
    /**
     * Gets whether the current series shows pixels.
    */
    get isPixel(): boolean;
    /**
     * Gets whether the current series shows a pie shape.
    */
    get isPie(): boolean;
    /**
     * Gets whether the current series shows a tile imagery.
    */
    get isTile(): boolean;
    /**
     * Gets whether the current series shows step shapes.
    */
    get isStep(): boolean;
    /**
     * Gets whether the current series shows interactive shape controls.
    */
    get isShapeControl(): boolean;
    /**
     * Gets whether the current series is a polar type series.
    *
    * ```ts
    * let isPolar: boolean = this.series.isPolar;
    * ```
    */
    get isPolar(): boolean;
    /**
     * Gets whether the current series is a scatter type series.
    *
    * ```ts
    * let isScatter: boolean = this.series.isScatter;
    * ```
    */
    get isScatter(): boolean;
    /**
     * Gets whether the current series is a radial type series.
    *
    * ```ts
    * let isRadial: boolean = this.series.isRadial;
    * ```
    */
    get isRadial(): boolean;
    /**
     * Gets whether the current series is a stacked type series.
    *
    * ```ts
    * let isStacked: boolean = this.series.isStacked;
    * ```
    */
    get isStacked(): boolean;
    /**
     * Gets whether the current series is a financial type series.
    *
    * ```ts
    * let isFinancial: boolean = this.series.isFinancial;
    * ```
    */
    get isFinancial(): boolean;
    /**
     * Gets whether the current series is a range type series.
    *
    * ```ts
    * let isRange: boolean = this.series.isRange;
    * ```
    */
    get isRange(): boolean;
    /**
     * Gets whether the current series is a category type series.
    *
    * ```ts
    * let isCategory: boolean = this.series.isCategory;
    * ```
    */
    get isCategory(): boolean;
    /**
     * Gets whether the current series is a geographic series.
    *
    * ```ts
    * let isGeographic: boolean = this.series.isGeographic;
    * ```
    */
    get isGeographic(): boolean;
    /**
     * Gets whether the current series is a shape type series.
    */
    get isShape(): boolean;
    /**
     * Gets whether the series is a value overlay.
    */
    get isValueOverlay(): boolean;
    /**
     * Gets whether the series is a highlight overlay.
    */
    get isHighlightOverlay(): boolean;
    /**
     * Gets whether the series supports summarization in Data Legend and Data Tooltip.
    */
    get isSummarizationSupported(): boolean;
    get isLayer(): boolean;
    /**
     * Gets whether the series has only marker as visuals
    */
    get hasOnlyMarkers(): boolean;
    /**
     * Gets whether the series has financial OHLC/candlestick visuals
    */
    get isFinancialSeries(): boolean;
    /**
     * Gets whether the series is financial overlay
    */
    get isFinancialOverlay(): boolean;
    /**
     * Gets whether the series is financial indicator
    */
    get isFinancialIndicator(): boolean;
    /**
     * Gets whether the series is financial waterfall
    */
    get isFinancialWaterfall(): boolean;
    /**
     * Gets whether the default crosshair behavior should be disabled if this series is present.
    *
    * `IsDefaultCrosshairBehaviorDisabled` defaults to true for annotation layers. When not using annotaion layers, you can show crosshairs by setting the chart's `CrosshairVisibility` to true.
    *
    * ```ts
    * let isDefaultCrosshairBehaviorDisabled: boolean = this.series.isDefaultCrosshairBehaviorDisabled;
    * ```
    */
    get isDefaultCrosshairBehaviorDisabled(): boolean;
    /**
     * Gets whether the default tooltip behavior should be disabled if this series is present.
    *
    * ```ts
    *  let isDefaultTooltipBehaviorDisabled: boolean = this.series.isDefaultTooltipBehaviorDisabled;
    * ```
    */
    get isDefaultTooltipBehaviorDisabled(): boolean;
    /**
     * Returns whether the current series supports visual markers.
    *
    * ```ts
    * let hasMarkers: boolean = this.series.hasMarkers;
    * ```
    */
    get hasMarkers(): boolean;
    /**
     * Returns whether the current series has a visible marker style.
    */
    get hasVisibleMarkers(): boolean;
    private _highlightedValuesExtraPropertyOverlays;
    /**
     * Gets the current extra layers for the series.
    */
    get highlightedValuesExtraPropertyOverlays(): IgrSeriesLayerPropertyOverlayCollection;
    set highlightedValuesExtraPropertyOverlays(v: IgrSeriesLayerPropertyOverlayCollection);
    /**
     * Gets if the series uses an index, which can be used to auto-assign it a color.
    *
    * ```ts
    * let isIndexed: boolean = this.series.isIndexed;
    * ```
    */
    get isIndexed(): boolean;
    /**
     * Gets if the series should appear in any legends.
    *
    * ```ts
    * let isUsableInLegend: boolean = this.series.isUsableInLegend;
    * ```
    */
    get isUsableInLegend(): boolean;
    /**
     * Gets or sets whether or not the current series will have a legend item displayed in a legend.
    *
    * The `LegendItemVisibilty` can be used to exclude only certain `Series` from the `Legend`.
    *
    * ```ts
    *  <IgrDataChart
    *     dataSource={this.state.dataSource} >
    *
    *     <IgrNumericXAxis name="xAxis" />
    *     <IgrNumericYAxis name="yAxis" />
    *
    *     <IgrAreaSeries
    *      name="series1"
    *     xAxisName="xAxis"
    * 	yAxisName="yAxis"
    * 	valueMemberPath="Value"
    *     legendItemVisibility= "collapsed" />
    *  </IgrDataChart>
    * ```
    */
    get legendItemVisibility(): Visibility;
    set legendItemVisibility(v: Visibility);
    /**
     * Gets or sets the LegendItemBadgeTemplate property.
     * The legend item badge is created according to the LegendItemBadgeTemplate on-demand by
     * the series object itself.
    */
    get legendItemBadgeTemplate(): IgDataTemplate;
    set legendItemBadgeTemplate(v: IgDataTemplate);
    /**
     * Gets the actual legend item badge template used by the series.
    */
    get actualLegendItemBadgeTemplate(): IgDataTemplate;
    set actualLegendItemBadgeTemplate(v: IgDataTemplate);
    /**
     * Gets the effective legend badge outline for the current series.
    */
    get actualLegendItemBadgeOutline(): string;
    set actualLegendItemBadgeOutline(v: string);
    /**
     * Gets the effective legend badge fill for the current series.
    */
    get actualLegendItemBadgeBrush(): string;
    set actualLegendItemBadgeBrush(v: string);
    /**
     * Gets or sets the type of legend badge representing the current series in a legend.
     * This property will be ignored when the LegendItemTemplate/LegendItemBadgeTemplate property is set on the series
    */
    get legendItemBadgeShape(): LegendItemBadgeShape;
    set legendItemBadgeShape(v: LegendItemBadgeShape);
    /**
     * Gets or sets the mode of legend badge representing the current series in a legend.
     * This property will be ignored when the LegendItemTemplate/LegendItemBadgeTemplate property is set on the series
    */
    get legendItemBadgeMode(): LegendItemBadgeMode;
    set legendItemBadgeMode(v: LegendItemBadgeMode);
    /**
     * Gets or sets the LegendItemTemplate property.
     * The legend item control content is created according to the LegendItemTemplate on-demand by
     * the series object itself.
    */
    get legendItemTemplate(): IgDataTemplate;
    set legendItemTemplate(v: IgDataTemplate);
    /**
     * Gets or sets the DiscreteLegendItemTemplate property.
     * The legend item control content is created according to the DiscreteLegendItemTemplate on-demand by
     * the series object itself.
    */
    get discreteLegendItemTemplate(): IgDataTemplate;
    set discreteLegendItemTemplate(v: IgDataTemplate);
    /**
     * Gets the Index property.
    */
    get index(): number;
    set index(v: number);
    /**
     * Gets or sets the easing function used to morph the current series.
    *
    * The `TransitioninDuration` and `TransitionEasingFunction` can be used to play animation when data is added or removed from a `Series`. To play an initial animation see `TransitionInDuration`.
    *
    * ```ts
    *  <IgrDataChart
    *     dataSource={this.state.dataSource} >
    *
    *     <IgrNumericXAxis name="xAxis" />
    *     <IgrNumericYAxis name="yAxis" />
    *
    *     <IgrAreaSeries
    *      name="series1"
    *     xAxisName="xAxis"
    * 	yAxisName="yAxis"
    * 	valueMemberPath="Value"
    *     isDropShadowEnabled=true
    *     markerType="circle"
    *    transitionEasingFunction ="cubicEase"
    *    isTransitionInEnabled= {true}  />
    *  </IgrDataChart>
    * ```
    *
    * ```ts
    * this.series.transitionEasingFunction =  EasingFunctions.cubicEase;
    * ```
    */
    get transitionEasingFunction(): (time: number) => number;
    set transitionEasingFunction(v: (time: number) => number);
    /**
     * Gets or sets the EasingFunction used to morph the current series during the initial transition.
    *
    * The `TransitionInEasingFunction` can be used with `IsTransitionInEnabled` to cofigure the animation when a new datasource is loaded.
    *
    * ```ts
    *  <IgrDataChart
    *     dataSource={this.state.dataSource} >
    *
    *     <IgrNumericXAxis name="xAxis" />
    *     <IgrNumericYAxis name="yAxis" />
    *
    *     <IgrAreaSeries
    *      name="series1"
    *     xAxisName="xAxis"
    * 	yAxisName="yAxis"
    * 	valueMemberPath="Value"
    *     isDropShadowEnabled=true
    *     markerType="circle"
    *    transitionInEasingFunction ="cubicEase"
    *    isTransitionInEnabled= {true}  />
    *  </IgrDataChart>
    * ```
    *
    * ```ts
    * this.series.transitionInEasingFunction =  EasingFunctions.cubicEase;
    * ```
    */
    get transitionInEasingFunction(): (time: number) => number;
    set transitionInEasingFunction(v: (time: number) => number);
    /**
     * Gets or sets the EasingFunction used to morph the current series during the initial transition.
    */
    get transitionOutEasingFunction(): (time: number) => number;
    set transitionOutEasingFunction(v: (time: number) => number);
    /**
     * Gets or sets the duration of the current series' morph.
    *
    * The `TransitionDuration` can be used to play animation when data is added or removed from a `Series`. To play an initial animation see `TransitionInDuration`.
    *
    * ```ts
    * this.series.transitionDuration = 500;
    * ```
    *
    * ```ts
    *  <IgrDataChart
    *     dataSource={this.state.dataSource} >
    *
    *     <IgrNumericXAxis name="xAxis" />
    *     <IgrNumericYAxis name="yAxis" />
    *
    *     <IgrAreaSeries
    *      name="series1"
    *     xAxisName="xAxis"
    * 	yAxisName="yAxis"
    * 	valueMemberPath="Value"
    *     isTransitionInEnabled=true
    *     transitionInSpeedType="indexScaled"
    *     transitionDuration= {500}
    *     transitionInDuration = {500} />
    *  </IgrDataChart>
    * ```
    */
    get transitionDuration(): number;
    set transitionDuration(v: number);
    get actualResolution(): number;
    set actualResolution(v: number);
    /**
     * Gets or sets the current series object's rendering resolution.
    *
    * Setting the `Resolution` on a Series to a higher value can help with performance, but it will lower the graphical fidelity of the line. As such, it can be increased up until the fidelity is unacceptable.
    *
    * ```ts
    * this.series.resolution = 1.5;
    * ```
    *
    * ```ts
    *  <IgrDataChart
    *     dataSource={this.state.dataSource} >
    *
    *     <IgrNumericXAxis name="xAxis" />
    *     <IgrNumericYAxis name="yAxis" />
    *
    *     <IgrAreaSeries
    *      name="series1"
    *     xAxisName="xAxis"
    * 	yAxisName="yAxis"
    * 	valueMemberPath="Value"
    *     resolution= {1.5} />
    *  </IgrDataChart>
    * ```
    */
    get resolution(): number;
    set resolution(v: number);
    /**
     * Gets or sets the top margin to use when getting a visible axis range for the series.
    */
    get visibleRangeMarginTop(): number;
    set visibleRangeMarginTop(v: number);
    /**
     * Gets or sets the bottom margin to use when getting a visible axis range for the series.
    */
    get visibleRangeMarginBottom(): number;
    set visibleRangeMarginBottom(v: number);
    /**
     * Gets or sets the left margin to use when getting a visible axis range for the series.
    */
    get visibleRangeMarginLeft(): number;
    set visibleRangeMarginLeft(v: number);
    /**
     * Gets or sets the right margin to use when getting a visible axis range for the series.
    */
    get visibleRangeMarginRight(): number;
    set visibleRangeMarginRight(v: number);
    /**
     * Gets or sets the Title property.
     * The legend item control is created according to the Title on-demand by
     * the series object itself.
    *
    * The `Series` `Title` may be used in tooltips and legends.
    *
    * ```ts
    * this.series.title = "InStock Items";
    * ```
    *
    * ```ts
    *  <IgrDataChart
    *     dataSource={this.state.dataSource} >
    *
    *     <IgrNumericXAxis name="xAxis" />
    *     <IgrNumericYAxis name="yAxis" />
    *
    *     <IgrAreaSeries
    *      name="series1"
    *     xAxisName="xAxis"
    * 	yAxisName="yAxis"
    * 	valueMemberPath="Value"
    *    title="InStock Items" />
    *  </IgrDataChart>
    * ```
    */
    get title(): any;
    set title(v: any);
    /**
     * Gets or sets the HighlightedTitleSuffix property.
    */
    get highlightedTitleSuffix(): string;
    set highlightedTitleSuffix(v: string);
    /**
     * Gets or sets whether the highlighted values layer should have a legend item.
    */
    get highlightedLegendItemVisibility(): Visibility;
    set highlightedLegendItemVisibility(v: Visibility);
    /**
     * Gets or sets the brush to use for the series.
    *
    * The `Brush` along with the `Outline` and `Negative Brush` can be used to affect the visuals of the `Series`.
    *
    * ```ts
    * this.series.brush = "red";
    * ```
    *
    * ```ts
    *  <IgrDataChart
    *     dataSource={this.state.dataSource} >
    *
    *     <IgrNumericXAxis name="xAxis" />
    *     <IgrNumericYAxis name="yAxis" />
    *
    *     <IgrAreaSeries
    *      name="series1"
    *     xAxisName="xAxis"
    * 	yAxisName="yAxis"
    * 	valueMemberPath="Value"
    *     brush="Gray"
    *     outline="Black" />
    *  </IgrDataChart>
    * ```
    */
    get brush(): string;
    set brush(v: string);
    /**
     * Gets the effective brush for the current series object.
    *
    * ```ts
    * let actualBrush: string = series.actualBrush;
    * ```
    */
    get actualBrush(): string;
    set actualBrush(v: string);
    /**
     * Gets or sets the selection brush to use for the series.
    */
    get selectionBrush(): string;
    set selectionBrush(v: string);
    /**
     * Gets or sets the Focus brush to use for the series.
    */
    get focusBrush(): string;
    set focusBrush(v: string);
    /**
     * Gets the effective emphasis brush for the current series object.
    */
    get actualSelectionBrush(): string;
    set actualSelectionBrush(v: string);
    /**
     * Gets the effective emphasis brush for the current series object.
    */
    get actualFocusBrush(): string;
    set actualFocusBrush(v: string);
    /**
     * Gets the effective brush for the current series object with opacity removed so its contrasty for use as a font color.
    */
    get safeActualBrush(): string;
    set safeActualBrush(v: string);
    /**
     * Gets or sets the brush to use for the outline of the series.
     * Some series types, such as LineSeries, do not display outlines.  Therefore, this property does not affect some charts.
    *
    * The `Outline` along with the `Brush` and `NegativeBrush` can be used to affect the visuals of the `Series`.
    *
    * ```ts
    * this.series.brush = "red";
    * ```
    *
    * ```ts
    *  <IgrDataChart
    *     dataSource={this.state.dataSource} >
    *
    *     <IgrNumericXAxis name="xAxis" />
    *     <IgrNumericYAxis name="yAxis" />
    *
    *     <IgrAreaSeries
    *      name="series1"
    *     xAxisName="xAxis"
    * 	yAxisName="yAxis"
    * 	valueMemberPath="Value"
    *     brush="Gray"
    *     outline="Black" />
    *  </IgrDataChart>
    * ```
    */
    get outline(): string;
    set outline(v: string);
    /**
     * Gets the effective outline for the current series object.
    *
    * ```ts
    * let actualOutline: string = series.ActualOutline;
    * ```
    */
    get actualOutline(): string;
    set actualOutline(v: string);
    /**
     * Gets or sets the brush that specifies current series object's line join style.
    */
    get lineJoin(): PenLineJoin;
    set lineJoin(v: PenLineJoin);
    /**
     * Gets or sets whether and how to display highlighted values for the series. Note, this is distinct from the highlighting feature that indicates what is closest or under the mouse.
    */
    get highlightedValuesDisplayMode(): SeriesHighlightedValuesDisplayMode;
    set highlightedValuesDisplayMode(v: SeriesHighlightedValuesDisplayMode);
    /**
     * Gets or sets whether and how to display highlighted values for the series. Note, this is distinct from the highlighting feature that indicates what is closest or under the mouse.
    */
    get shouldAnimateOnDataSourceSwap(): boolean;
    set shouldAnimateOnDataSourceSwap(v: boolean);
    /**
     * Gets or sets the width of the current series object's line thickness.
    *
    * Depending on the `Series` type, this can be the main brush used, or just the outline. For example, when using a `LineSeries` it will affect the thickness of the lines drawn, whereas when using a `ColumnSeries` it will affect the outer border thickness of the columns.
    *
    * ```ts
    * this.series.thickness=5;
    * ```
    *
    * ```ts
    *  <IgrDataChart
    *     dataSource={this.state.dataSource} >
    *
    *     <IgrNumericXAxis name="xAxis" />
    *     <IgrNumericYAxis name="yAxis" />
    *
    *     <IgrAreaSeries
    *      name="series1"
    *     xAxisName="xAxis"
    * 	yAxisName="yAxis"
    * 	valueMemberPath="Value"
    *     thickness= {5} />
    *  </IgrDataChart>
    * ```
    */
    get thickness(): number;
    set thickness(v: number);
    /**
     * Gets the effective Thickness for the current series object.
    */
    get actualThickness(): number;
    set actualThickness(v: number);
    /**
     * Gets or sets a collection of Double values that indicate the pattern of dashes and gaps that
     * is used to outline the current series object.
    */
    get dashArray(): number[];
    set dashArray(v: number[]);
    /**
     * Gets actual highlighting mode
    */
    get actualHighlightingMode(): SeriesHighlightingMode;
    set actualHighlightingMode(v: SeriesHighlightingMode);
    /**
     * Gets actual Selection mode
    */
    get actualSelectionMode(): SeriesSelectionMode;
    set actualSelectionMode(v: SeriesSelectionMode);
    /**
     * Gets actual Selection mode
    */
    get actualFocusMode(): SeriesSelectionMode;
    set actualFocusMode(v: SeriesSelectionMode);
    /**
     * Gets actual HighlightedValues fade opacity
    */
    get actualHighlightedValuesFadeOpacity(): number;
    set actualHighlightedValuesFadeOpacity(v: number);
    /**
     * Gets or sets the target opacity to fade to for fade style HighlightedValues.
    */
    get highlightedValuesFadeOpacity(): number;
    set highlightedValuesFadeOpacity(v: number);
    /**
     * Gets actual highlighting fade opacity
    */
    get actualHighlightingFadeOpacity(): number;
    set actualHighlightingFadeOpacity(v: number);
    /**
     * Gets or sets the target opacity to fade to for fade style highlighting.
    */
    get highlightingFadeOpacity(): number;
    set highlightingFadeOpacity(v: number);
    /**
     * Gets or sets whether the ActualLegend is FinancialLegend or normal Legend.
    */
    get isActualLegendFinancial(): boolean;
    set isActualLegendFinancial(v: boolean);
    /**
     * Gets or sets whether the component level highlight mode is ignored.
    */
    get isComponentHighlightingModeIgnored(): boolean;
    set isComponentHighlightingModeIgnored(v: boolean);
    /**
     * Gets or sets whether highlighting should be enabled for this series, if this type of series supports highlighting.
    *
    * ```ts
    * this.series.isHighlightingEnabled = true;
    * ```
    *
    * ```ts
    * <IgrDataChart
    *     dataSource={this.state.dataSource} >
    *
    *     <IgrNumericXAxis name="xAxis" />
    *     <IgrNumericYAxis name="yAxis" />
    *
    *     <IgrAreaSeries
    *      name="series1"
    *     xAxisName="xAxis"
    * 	yAxisName="yAxis"
    * 	valueMemberPath="Value"
    *     isHighlightingEnabled="true" />
    *  </IgrDataChart>
    * ```
    */
    get isHighlightingEnabled(): boolean;
    set isHighlightingEnabled(v: boolean);
    /**
     * Gets or sets whether the series should use individual palette colors for each item.
    */
    get useItemWiseColors(): boolean;
    set useItemWiseColors(v: boolean);
    get isColoredItemwise(): boolean;
    /**
     * Gets or sets whether the opacity should be automatically shifted for the safe actual brush.
    */
    get shouldShiftOpacityForSafeActualBrush(): boolean;
    set shouldShiftOpacityForSafeActualBrush(v: boolean);
    /**
     * Gets or sets whether the opacity should be automatically shifted for the safe actual brush.
    */
    get shouldRemoveHighlightedDataOnLayerHidden(): boolean;
    set shouldRemoveHighlightedDataOnLayerHidden(v: boolean);
    /**
     * Gets or sets whether this series should suppress it's auto callouts
    */
    get shouldHideAutoCallouts(): boolean;
    set shouldHideAutoCallouts(v: boolean);
    /**
     * Gets or sets whether drop shadow should be enabled for this series.
    *
    * `IsDropShadowEnabled` is used to decide whether drop shadow should be enabled for this series.
    *
    * ```ts
    * this.series.isDropShadowEnabled = true;
    * ```
    *
    * ```ts
    * <IgrDataChart
    *     dataSource={this.state.dataSource} >
    *
    *     <IgrNumericXAxis name="xAxis" />
    *     <IgrNumericYAxis name="yAxis" />
    *
    *     <IgrAreaSeries
    *      name="series1"
    *     xAxisName="xAxis"
    * 	yAxisName="yAxis"
    * 	valueMemberPath="Value"
    *     isDropShadowEnabled="true" />
    *  </IgrDataChart>
    * ```
    */
    get isDropShadowEnabled(): boolean;
    set isDropShadowEnabled(v: boolean);
    /**
     * Gets or sets the shadow blur.
     * This property is ignored when
     * Series.UseSingleShadow is set to true.
    *
    * `ShadowBlur` can be set in conjection with `IsDropShadowEnabled` to further define the drop shadow effect.
    *
    * ```ts
    * this.series.shadowBlur = 7;
    * ```
    *
    * ```ts
    *  <IgrDataChart
    *     dataSource={this.state.dataSource} >
    *
    *     <IgrNumericXAxis name="xAxis" />
    *     <IgrNumericYAxis name="yAxis" />
    *
    *     <IgrAreaSeries
    *      name="series1"
    *     xAxisName="xAxis"
    * 	yAxisName="yAxis"
    * 	valueMemberPath="Value"
    *     shadowBlur={7}
    *     shadowColor="blue" />
    *  </IgrDataChart>
    * ```
    */
    get shadowBlur(): number;
    set shadowBlur(v: number);
    /**
     * Gets or sets the drop shadow color.
    *
    * `ShadowColor` can be set in conjection with `IsDropShadowEnabled` to further define the drop shadow effect.
    *
    * ```ts
    * this.series.shadowColor = "blue";
    * ```
    *
    * ```ts
    *  <IgrDataChart
    *     dataSource={this.state.dataSource} >
    *
    *     <IgrNumericXAxis name="xAxis" />
    *     <IgrNumericYAxis name="yAxis" />
    *
    *     <IgrAreaSeries
    *      name="series1"
    *     xAxisName="xAxis"
    * 	yAxisName="yAxis"
    * 	valueMemberPath="Value"
    *     shadowBlur="7"
    *     shadowColor="blue" />
    *  </IgrDataChart>
    * ```
    */
    get shadowColor(): string;
    set shadowColor(v: string);
    /**
     * Gets or sets whether drop shadow is applied to the whole series visual or to each of the individual shapes forming the series.
     * When this property is set to true, no
     * Series.ShadowBlur is applied.
    *
    * ```ts
    * this.series.useSingleShadow = true;
    * ```
    *
    * ```ts
    *  <IgrDataChart
    *     dataSource={this.state.dataSource} >
    *
    *     <IgrNumericXAxis name="xAxis" />
    *     <IgrNumericYAxis name="yAxis" />
    *
    *     <IgrAreaSeries
    *      name="series1"
    *     xAxisName="xAxis"
    * 	yAxisName="yAxis"
    * 	valueMemberPath="Value"
    *     isDropShadowEnabled=true
    *     markerType="circle"
    *     useSingleShadow= {true} />
    *  </IgrDataChart>
    * ```
    */
    get useSingleShadow(): boolean;
    set useSingleShadow(v: boolean);
    /**
     * Gets or sets the drop shadow x-offset.
    *
    * `ShadowOffsetX` can be set in conjection with `IsDropShadowEnabled` to further define the drop shadow effect.
    *
    * ```ts
    * this.series.shadowOffsetX = 10;
    * ```
    *
    * ```ts
    *  <IgrDataChart
    *     dataSource={this.state.dataSource} >
    *
    *     <IgrNumericXAxis name="xAxis" />
    *     <IgrNumericYAxis name="yAxis" />
    *
    *     <IgrAreaSeries
    *      name="series1"
    *     xAxisName="xAxis"
    * 	yAxisName="yAxis"
    * 	valueMemberPath="Value"
    *     shadowOffsetX= {10}
    *     shadowOffsetY={10] />
    *  </IgrDataChart>
    * ```
    */
    get shadowOffsetX(): number;
    set shadowOffsetX(v: number);
    /**
     * Gets or sets the drop shadow y-offset.
    *
    * `ShadowOffsetY` can be set in conjection with `IsDropShadowEnabled` to further define the drop shadow effect.
    *
    * ```ts
    * this.series.shadowOffsetY = 10;
    * ```
    *
    * ```ts
    *  <IgrDataChart
    *     dataSource={this.state.dataSource} >
    *
    *     <IgrNumericXAxis name="xAxis" />
    *     <IgrNumericYAxis name="yAxis" />
    *
    *     <IgrAreaSeries
    *      name="series1"
    *     xAxisName="xAxis"
    * 	yAxisName="yAxis"
    * 	valueMemberPath="Value"
    *     shadowOffsetX= {10}
    *     shadowOffsetY= {10} />
    *  </IgrDataChart>
    * ```
    */
    get shadowOffsetY(): number;
    set shadowOffsetY(v: number);
    /**
     * Gets or sets the opacity applied to the area fill visual.
     * This property only applies to series that have area visual.
    *
    * ```ts
    *  <IgrDataChart
    *     dataSource={this.state.dataSource} >
    *
    *     <IgrNumericXAxis name="xAxis" />
    *     <IgrNumericYAxis name="yAxis" />
    *
    *     <IgrAreaSeries
    *      name="series1"
    *     xAxisName="xAxis"
    * 	yAxisName="yAxis"
    * 	valueMemberPath="Value"
    *    actualAreaFillOpacity= {1} />
    *  </IgrDataChart>
    * ```
    */
    get areaFillOpacity(): number;
    set areaFillOpacity(v: number);
    /**
     * Gets the actual opacity applied to the area fill visual.
    *
    * ```ts
    * let actualFillOpacity: number = series.actualAreaFillOpacity;
    * ```
    */
    get actualAreaFillOpacity(): number;
    set actualAreaFillOpacity(v: number);
    /**
     * Gets or sets the opacity applied to the fill of the markers.
     * This property only applies to series that have area visual.
    */
    get markerFillOpacity(): number;
    set markerFillOpacity(v: number);
    /**
     * Gets the actual opacity applied to the fill of the markers.
    */
    get actualMarkerFillOpacity(): number;
    set actualMarkerFillOpacity(v: number);
    /**
     * Gets if the default tooltip has been selected for display.
    *
    * To use the default tooltip set `ShowDefaultTooltip` to true.
    *
    * ```ts
    * let isDefaultToolTipSelected: boolean = this.series.isDefaultToolTipSelected;
    * ```
    */
    get isDefaultToolTipSelected(): boolean;
    set isDefaultToolTipSelected(v: boolean);
    /**
     * Gets or sets whether default tooltip will be shown.
    *
    * The default tooltips display all the information relevant to the particular series item (series title, data values, axis values etc.) and are styled to match the series' style. When using default tooltips, you should also set the series `Title`.
    *
    * ```ts
    *  <IgrDataChart
    *     dataSource={this.state.dataSource} >
    *
    *     <IgrNumericXAxis name="xAxis" />
    *     <IgrNumericYAxis name="yAxis" />
    *
    *     <IgrAreaSeries
    *      name="series1"
    *     xAxisName="xAxis"
    * 	yAxisName="yAxis"
    * 	valueMemberPath="Value"
    *     showDefaultTooltip ="true"
    *     title="InStock Items" />
    *  </IgrDataChart>
    * ```
    *
    * ```ts
    * this.series.showDefaultTooltip ="true";
    * ```
    */
    get showDefaultTooltip(): boolean;
    set showDefaultTooltip(v: boolean);
    /**
     * Gets or sets the visible range mode to use.
    */
    get visibleRangeMode(): SeriesVisibleRangeMode;
    set visibleRangeMode(v: SeriesVisibleRangeMode);
    /**
     * Gets or sets the outline mode to use for the series.
    */
    get outlineMode(): SeriesOutlineMode;
    set outlineMode(v: SeriesOutlineMode);
    /**
     * Gets or sets the duration of the current series' transition in morph.
    *
    * The `TransitionInDuration` can be used with `IsTransitionInEnabled` to cofigure the animation when a new datasource is loaded.
    *
    * ```ts
    * this.series.transitionDuration = 500;
    * ```
    *
    * ```ts
    *  <IgrDataChart
    *     dataSource={this.state.dataSource} >
    *
    *     <IgrNumericXAxis name="xAxis" />
    *     <IgrNumericYAxis name="yAxis" />
    *
    *     <IgrAreaSeries
    *      name="series1"
    *     xAxisName="xAxis"
    * 	yAxisName="yAxis"
    * 	valueMemberPath="Value"
    *     isTransitionInEnabled= {true}
    *     transitionInSpeedType="indexScaled"
    *     transitionDuration={500}
    *     transitionInDuration= {500} />
    *  </IgrDataChart>
    * ```
    */
    get transitionInDuration(): number;
    set transitionInDuration(v: number);
    /**
     * Gets or sets the duration of the current series' transition out morph.
    */
    get transitionOutDuration(): number;
    set transitionOutDuration(v: number);
    /**
     * Gets or sets the duration of the current series' transition in morph.
    *
    * The `TransitionInSpeedType` can be used with `IsTransitionInEnabled` to cofigure the animation when a new datasource is loaded.
    *
    * ```ts
    * this.series.transitionInSpeedType = TransitionInSpeedType.IndexScaled;
    * ```
    *
    * ```ts
    *  <IgrDataChart
    *     dataSource={this.state.dataSource} >
    *
    *     <IgrNumericXAxis name="xAxis" />
    *     <IgrNumericYAxis name="yAxis" />
    *
    *     <IgrAreaSeries
    *      name="series1"
    *     xAxisName="xAxis"
    * 	yAxisName="yAxis"
    * 	valueMemberPath="Value"
    *     isTransitionInEnabled=true
    *     transitionInSpeedType="indexScaled"
    *     transitionDuration=500
    *     transitionInDuration=500 />
    *  </IgrDataChart>
    * ```
    */
    get transitionInSpeedType(): TransitionInSpeedType;
    set transitionInSpeedType(v: TransitionInSpeedType);
    /**
     * Gets or sets the duration of the current series' transition out morph.
    */
    get transitionOutSpeedType(): TransitionOutSpeedType;
    set transitionOutSpeedType(v: TransitionOutSpeedType);
    /**
     * Gets or sets the style of the starting point of any lines or polylines representing this series.
     * Not every series type has a line at which it would be appropriate to display a start cap, so this property does not affect every series type.  LineSeries, for example, is affected by StartCap, but ColumnSeries is not.
    */
    get lineCap(): PenLineCap;
    set lineCap(v: PenLineCap);
    /**
     * Gets or sets the AutoCalloutLabel format string to use for the AutoCalloutLabel.
    */
    get autoCalloutLabelFormat(): string;
    set autoCalloutLabelFormat(v: string);
    /**
     * Gets or sets the format specifiers to use with the AutoCalloutLabelFormat string.
    */
    get autoCalloutLabelFormatSpecifiers(): any[];
    set autoCalloutLabelFormatSpecifiers(v: any[]);
    /**
     * Gets or sets the AutoCalloutLabel format string to use for the AutoCalloutLabel.
    */
    get autoCalloutValueLabelFormat(): string;
    set autoCalloutValueLabelFormat(v: string);
    /**
     * Gets or sets the format specifiers to use with the AutoCalloutValueLabelFormat string.
    */
    get autoCalloutValueLabelFormatSpecifiers(): any[];
    set autoCalloutValueLabelFormatSpecifiers(v: any[]);
    /**
     * Gets or sets the whether the chart reacts to mouse move events.
    */
    get mouseOverEnabled(): boolean;
    set mouseOverEnabled(v: boolean);
    /**
     * Gets or sets the coercion methods to use when loading data from data sources.
     * Should be specified before setting any member paths, if being used. Setting it later
     * will not cause data to be reimported into the chart.
    *
    * &lt;-- position: content member-->
    *
    * ```ts
    * cMethods: any = {
    *     ValueCoercion: function(value:number): number {return value+2;}
    *  }
    * ```
    *
    * ```ts
    *  <IgrDataChart
    *     dataSource={this.state.dataSource}
    *     width="700px"
    *     height="500px">
    *
    *     <IgrNumericXAxis name="xAxis" />
    *     <IgrNumericYAxis name="yAxis" />
    *
    *     <IgrScatterPolygonSeries
    *      name="series1"
    *      shapeMemberPath="Points"
    *      title="House Floor Plan"
    *      brush="Gray"
    *      outline="Black"
    * 	 coercionMethods = {this.ValueCoercion} />
    *  </IgrDataChart>
    * ```
    */
    get coercionMethods(): any;
    set coercionMethods(v: any);
    /**
     * Gets or sets whether the series should expect that properties in its items source may be functions that need to be
     * evaluated to yield their value. This defaults to false, as there will be a subtle performance impact to using this feature.
     * This value must be set before assigning an item's source to take effect.
    *
    * `expectFunctions` is used to decide whether the series should expect that its data source members need to be called as functions to get their values.
    *
    * ```ts
    *  <IgrDataChart
    *     dataSource={this.state.dataSource} >
    *
    *     <IgrNumericXAxis name="xAxis" />
    *     <IgrNumericYAxis name="yAxis" />
    *
    *     <IgrAreaSeries
    *      name="series1"
    *     xAxisName="xAxis"
    * 	yAxisName="yAxis"
    * 	valueMemberPath="MyFunction"
    *     expectFunctions={true} />
    *  </IgrDataChart>
    * ```
    *
    * ```ts
    * this.series.expectFunctions=true;
    * ```
    */
    get expectFunctions(): boolean;
    set expectFunctions(v: boolean);
    /**
     * Method of hit testing to use when pointing to items in this series.
    *
    * The `HitTestMode` can be set to either:
    *
    * -   `Auto`: automatically decide the appropriate hit test mode for the series.
    * -   `ColorEncoded`: use a color encoded off screen buffer for hit testing. Should always be O(1) time for determining a hit series. This increases frame render time and memory usage, however. Consider using this if hit testing time is degrading performance.
    * -   `Computational`: use a computational based approach to determine whether the series has been hit. This uses loose bounding boxes, in some cases, and can range in time complexity between O(1) and O(log n) to find a hit. This decreases frame render time compared to color encoded
    *
    * ```ts
    * this.series.hitTestMode = SeriesHitTestMode.Computational;
    * ```
    */
    get hitTestMode(): SeriesHitTestMode;
    set hitTestMode(v: SeriesHitTestMode);
    /**
     * Resolved method of hit testing to use when pointing to items in the chart.
    *
    * ```ts
    * let hitTestMode: SeriesHitTestMode = this.series.actualHitTestMode;
    * ```
    */
    get actualHitTestMode(): SeriesHitTestMode;
    set actualHitTestMode(v: SeriesHitTestMode);
    /**
     * Overridden by derived series classes to indicate when negative colors are supported or not.
    */
    get isNegativeColorSupported(): boolean;
    /**
     * Overridden by derived series classes to indicate when markerless display is preferred or not.
    */
    get isMarkerlessDisplayPreferred(): boolean;
    /**
     * The final value of this series.
    */
    get finalValue(): number;
    set finalValue(v: number);
    /**
     * The percent change from the beginning to the end of this series.
    */
    get percentChange(): number;
    set percentChange(v: number);
    /**
     * Gets the text that is displayed for the Open label in the tooltip.
    */
    get actualOpenLabel(): string;
    /**
     * Gets the text that is displayed for the Close label in the tooltip.
    */
    get actualCloseLabel(): string;
    /**
     * Gets the text that is displayed for the High label in the tooltip.
    */
    get actualHighLabel(): string;
    /**
     * Gets the text that is displayed for the Low label in the tooltip.
    */
    get actualLowLabel(): string;
    /**
     * Gets the text that is displayed for the Volume label in the tooltip.
    */
    get actualVolumeLabel(): string;
    /**
     * Gets the text that is displayed for the Value label in the tooltip.
    */
    get actualValueLabel(): string;
    /**
     * Gets the text that is displayed for the Value label in the tooltip.
    */
    get actualRadiusLabel(): string;
    private _layers;
    /**
     * Gets the current extra layers for the series.
    */
    get layers(): IgrSeriesLayerCollection;
    set layers(v: IgrSeriesLayerCollection);
    private _actualLayers;
    /**
     * Gets the actual extra layers for the series.
    */
    get actualLayers(): IgrSeriesLayerCollection;
    set actualLayers(v: IgrSeriesLayerCollection);
    get opacity(): number;
    set opacity(v: number);
    get visibility(): Visibility;
    set visibility(v: Visibility);
    findByName(name: string): any;
    protected __p: string;
    protected _hasUserValues: Set<string>;
    protected get hasUserValues(): Set<string>;
    protected __m(propertyName: string): void;
    protected _stylingContainer: any;
    protected _stylingParent: any;
    protected _inStyling: boolean;
    protected _styling(container: any, component: any, parent?: any): void;
    /**
 * Gets the brush for tooltip labels.

*/
    resolveTooltipBrush(): string;
    getItemValue(item: any, memberPathName: string): any;
    /**
     * Gets the value of a requested member path from the series.
    
    * @param memberPathName  * The property name of a valid member path for the series
    */
    getMemberPathValue(memberPathName: string): string;
    /**
     * Gets the precise item index, if possible, based on the closeness to the previous or next whole integer. If the series cannot provide this information, GetExactItemIndex will return the same integer value as GetItemIndex.
    
    * @param world  * The world position for which to return the index.
    *
    * ```ts
    * let index: number = this.series.getExactItemIndex({x:.5,y:.5});
    * ```
    */
    getExactItemIndex(world: IgPoint): number;
    /**
     * Gets the item index associated with the specified world position
    
    *
    * ```ts
    * let index: number = this.series.getItemIndex({x:.5,y:.5});
    * ```
    */
    getItemIndex(world: IgPoint): number;
    /**
     * Gets the item that is the best match for the specified world coordinates.
    
    * @param world  * The world coordinates to use.
    *
    * ```ts
    * let item: number = this.series.getItem({x:.5,y:.5});
    * ```
    */
    getItem(world: IgPoint): any;
    getPreviousOrExactIndex(world: IgPoint, skipUnknowns: boolean): number;
    getNextOrExactIndex(world: IgPoint, skipUnknowns: boolean): number;
    getSeriesValue(world: IgPoint, useInterpolation: boolean, skipUnknowns: boolean): number;
    getSeriesValuePosition(world: IgPoint, useInterpolation: boolean, skipUnknowns: boolean): IgPoint;
    /**
     * If possible, will return the best available value bounding box within the series that has the best value match for the world position provided.
    
    * @param world  * The world coordinate for which to get a value bounding box for
    */
    getSeriesValueBoundingBox(world: IgPoint): IgRect;
    /**
     * If possible, will return the best available value marker bounding box within the series that has the best value match for the world position provided.
    
    * @param world  * The world coordinates for which to get a value marker bounding box for
    */
    getSeriesValueMarkerBoundingBox(world: IgPoint): IgRect;
    getSeriesHighValue(world: IgPoint, useInterpolation: boolean, skipUnknowns: boolean): number;
    getSeriesHighValuePosition(world: IgPoint, useInterpolation: boolean, skipUnknowns: boolean): IgPoint;
    getSeriesLowValue(world: IgPoint, useInterpolation: boolean, skipUnknowns: boolean): number;
    getSeriesLowValuePosition(world: IgPoint, useInterpolation: boolean, skipUnknowns: boolean): IgPoint;
    getSeriesValuePositionFromSeriesPixel(mouse: IgPoint, useInterpolation: boolean, skipUnknowns: boolean): IgPoint;
    getSeriesValueFromSeriesPixel(mouse: IgPoint, useInterpolation: boolean, skipUnknowns: boolean): number;
    /**
     * For a category plotted series, returns the current width of the items within the categories. This only returns a value if the items have some form of width (e.g. columns, bars, etc.) otherwise 0 is returned.
    
    *
    * ```ts
    * let span: number = this.series.getItemSpan();
    * ```
    */
    getItemSpan(): number;
    /**
     * Gets the data values of each axis associated with the specified value type. For example, if you specify
     * mode as Maximum then it will return the maximum numerical value for each axis. For non-numerical axes it
     * will return NaN.
    
    * @param mode  * The type of value desired from the series axes.
    */
    getSeriesValueType(mode: ValueLayerValueMode): number[];
    /**
     * Gets position of series value for specified layer value mode
    
    */
    getSeriesValueTypePosition(mode: ValueLayerValueMode): IgPoint;
    getSeriesValueTypePositionFromValue(values: number[]): IgPoint;
    /**
     * Hides any internal tooltips presented by the series, if any.
    
    */
    hideToolTips(): void;
    /**
     * Hides any internal tooltips presented by the series, if any.
    
    */
    hideToolTipsImmediate(): void;
    /**
     * Converts a point from coordinates within the series plot area to a world position within axis space.
    
    * @param seriesPoint  * The pixel location within the plot area of the series.
    *
    * ```ts
    * this.series.toWorldPosition({x:500,y:500});
    * ```
    */
    toWorldPosition(seriesPoint: IgPoint): IgPoint;
    /**
     * Converts a rect from coordinates within the series plot area to a world position within axis space.
    
    * @param rect  * The pixel rect within the plot area of the series.
    */
    toWorldRect(rect: IgRect): IgRect;
    /**
     * Converts a point from world coordinates to coordinates within the viewport of the series.
    
    * @param world  * The world position from which to convert.
    */
    fromWorldPosition(world: IgPoint): IgPoint;
    /**
     * Requests that the provided item should be brought into view if possible.
    
    * @param item  * The item to attempt to bring into view.
    *
    * ```ts
    * this.series.scrollIntoView(dataItem);
    * ```
    */
    scrollIntoView(item: any): boolean;
    /**
     * Renders the series.
    
    * @param animate  * True if the change should be animated.
    *
    * ```ts
    * this.series.renderSeries(true);
    * ```
    */
    renderSeries(animate: boolean): void;
    getMainContentViewport(): IgRect;
    /**
     * Gets the effective viewport, adjusted to account for margins and other factors.
    
    */
    getEffectiveViewport(): IgRect;
    /**
     * Removes all alternate views of this series.
    
    */
    removeAllAlternateViews(): void;
    /**
     * Removes an alternate view of this series.
    
    * @param viewIdentifier  * The string identifier for the view to remove.
    */
    removeAlternateView(viewIdentifier: string): void;
    /**
     * Called to notify about changes to indexed-based properties, e.g. Brushes, Outlines, MarkerBrushes, MarkerOutlines and refresh series
    
    */
    notifyIndexedPropertiesChanged(): void;
    /**
     * Notifies the series that a visual property has changed, requiring a visual update.
    
    */
    notifyVisualPropertiesChanged(): void;
    /**
     * Replays the assigned transition in animation, if any.
    
    *
    * ```ts
    * this.series.replayTransitionIn();
    * ```
    */
    replayTransitionIn(): void;
    /**
     * Plays the assigned transition out animation, if any.
    
    */
    playTransitionOut(): void;
    /**
     * Plays the assigned transition out animation, if any.
    
    */
    playTransitionIn(): void;
    /**
     * Plays the assigned transition out animation, if any.
    
    */
    playTransitionOutAndRemove(): void;
    /**
     * Call to null out the axes of the series;
    
    */
    removeAxes(): void;
    /**
     * Simulates a pointer hover over the series surface.
    
    * @param point  * The pointer position relative to the series viewport over which to hover.
    *
    * When tooltips are enabled, `SimulateHover` can be used to automatically display the tooltip over a particular series item.
    *
    * ```ts
    * this.series.simulateHover({x:250,y:250});
    * ```
    */
    simulateHover(point: IgPoint): void;
    /**
     * Called when this series' Style is updated.
    
    */
    styleUpdated(): void;
    setNegativeColors(negativeBrush: string, negativeOutline: string): void;
    /**
     * Moves the cursor point to the provided world position. Some series may react to the current cursor position.
    
    * @param point  * The cursor point, in world coordinates.
    *
    * `MoveCursorPoint` can be used on annotation layers to programitically show the annotation at the given point.
    *
    * ```ts
    * this.crosshair.moveCursorPoint({x:.5,y:.5});
    * ```
    */
    moveCursorPoint(point: IgPoint): void;
    private _transitionOutCompleted;
    private _transitionOutCompleted_wrapped;
    /**
     * Fired when a transition out has completed.
    */
    get transitionOutCompleted(): (s: IgrSeries, e: IgrTransitionOutCompletedEventArgs) => void;
    set transitionOutCompleted(ev: (s: IgrSeries, e: IgrTransitionOutCompletedEventArgs) => void);
    private _renderRequested;
    private _renderRequested_wrapped;
    /**
     * This event is raised every time a render has been requested from a series.
    *
    * ```ts
    *  const series1 = new IgrAreaSeries({ name: "series1" });
    * series1.valueMemberPath = "USA";
    * series1.title = "USA";
    * series1.xAxisName = "xAxis";
    * series1.yAxisName = "yAxis";
    * series1.renderRequested= this.onRenderRequested;
    *
    * public onRenderRequested =( s:IgrSeries, e: RenderRequestedEventArgs) => {
    *           }
    * ```
    *
    * ```ts
    *  <IgrDataChart
    *     dataSource={this.state.dataSource} >
    *
    *     <IgrNumericXAxis name="xAxis" />
    *     <IgrNumericYAxis name="yAxis" />
    *
    *     <IgrAreaSeries
    *      name="series1"
    *     xAxisName="xAxis"
    * 	yAxisName="yAxis"
    * 	valueMemberPath="Value"
    *     shadowBlur="7"
    *     shadowColor="blue"
    * 	renderRequested= {this.onRenderRequested}/>
    *  </IgrDataChart>
    * ```
    */
    get renderRequested(): (s: IgrSeries, e: IgrRenderRequestedEventArgs) => void;
    set renderRequested(ev: (s: IgrSeries, e: IgrRenderRequestedEventArgs) => void);
}
export interface IIgrSeriesProps {
    /**
     * Sets or gets a required unique name for the series.
     * */
    name: string;
    children?: React.ReactNode;
    dataSource?: any;
    highlightedDataSource?: any;
    tooltipTemplate?: React.FunctionComponent<IChartTooltipProps> | React.Component<IChartTooltipProps>;
    /**
     * Gets or sets the legend used for the current series.
    */
    legend?: any;
    /**
 * Gets or sets a name used for grouping multiple series in the Data Legend
 * If not set, series will be grouped by series family, e.g. Category, Range, Financial, Scatter
*/
    dataLegendGroup?: string;
    /**
     * Gets or sets a name used for grouping highlighted series in the Data Legend
     * If not set, series will default to parent series' DataLegendGroup, e.g. Category, Range, Financial, Scatter
    */
    highlightedValuesDataLegendGroup?: string;
    /**
     * Gets or sets whether or not the current series will have a legend item displayed in a legend.
    *
    * The `LegendItemVisibilty` can be used to exclude only certain `Series` from the `Legend`.
    *
    * ```ts
    *  <IgrDataChart
    *     dataSource={this.state.dataSource} >
    *
    *     <IgrNumericXAxis name="xAxis" />
    *     <IgrNumericYAxis name="yAxis" />
    *
    *     <IgrAreaSeries
    *      name="series1"
    *     xAxisName="xAxis"
    * 	yAxisName="yAxis"
    * 	valueMemberPath="Value"
    *     legendItemVisibility= "collapsed" />
    *  </IgrDataChart>
    * ```
    */
    legendItemVisibility?: Visibility | string;
    /**
     * Gets or sets the LegendItemBadgeTemplate property.
     * The legend item badge is created according to the LegendItemBadgeTemplate on-demand by
     * the series object itself.
    */
    legendItemBadgeTemplate?: IgDataTemplate;
    /**
     * Gets the actual legend item badge template used by the series.
    */
    actualLegendItemBadgeTemplate?: IgDataTemplate;
    /**
     * Gets the effective legend badge outline for the current series.
    */
    actualLegendItemBadgeOutline?: string;
    /**
     * Gets the effective legend badge fill for the current series.
    */
    actualLegendItemBadgeBrush?: string;
    /**
     * Gets or sets the type of legend badge representing the current series in a legend.
     * This property will be ignored when the LegendItemTemplate/LegendItemBadgeTemplate property is set on the series
    */
    legendItemBadgeShape?: LegendItemBadgeShape | string;
    /**
     * Gets or sets the mode of legend badge representing the current series in a legend.
     * This property will be ignored when the LegendItemTemplate/LegendItemBadgeTemplate property is set on the series
    */
    legendItemBadgeMode?: LegendItemBadgeMode | string;
    /**
     * Gets or sets the LegendItemTemplate property.
     * The legend item control content is created according to the LegendItemTemplate on-demand by
     * the series object itself.
    */
    legendItemTemplate?: IgDataTemplate;
    /**
     * Gets or sets the DiscreteLegendItemTemplate property.
     * The legend item control content is created according to the DiscreteLegendItemTemplate on-demand by
     * the series object itself.
    */
    discreteLegendItemTemplate?: IgDataTemplate;
    /**
     * Gets the Index property.
    */
    index?: number | string;
    /**
     * Gets or sets the easing function used to morph the current series.
    *
    * The `TransitioninDuration` and `TransitionEasingFunction` can be used to play animation when data is added or removed from a `Series`. To play an initial animation see `TransitionInDuration`.
    *
    * ```ts
    *  <IgrDataChart
    *     dataSource={this.state.dataSource} >
    *
    *     <IgrNumericXAxis name="xAxis" />
    *     <IgrNumericYAxis name="yAxis" />
    *
    *     <IgrAreaSeries
    *      name="series1"
    *     xAxisName="xAxis"
    * 	yAxisName="yAxis"
    * 	valueMemberPath="Value"
    *     isDropShadowEnabled=true
    *     markerType="circle"
    *    transitionEasingFunction ="cubicEase"
    *    isTransitionInEnabled= {true}  />
    *  </IgrDataChart>
    * ```
    *
    * ```ts
    * this.series.transitionEasingFunction =  EasingFunctions.cubicEase;
    * ```
    */
    transitionEasingFunction?: (time: number) => number;
    /**
     * Gets or sets the EasingFunction used to morph the current series during the initial transition.
    *
    * The `TransitionInEasingFunction` can be used with `IsTransitionInEnabled` to cofigure the animation when a new datasource is loaded.
    *
    * ```ts
    *  <IgrDataChart
    *     dataSource={this.state.dataSource} >
    *
    *     <IgrNumericXAxis name="xAxis" />
    *     <IgrNumericYAxis name="yAxis" />
    *
    *     <IgrAreaSeries
    *      name="series1"
    *     xAxisName="xAxis"
    * 	yAxisName="yAxis"
    * 	valueMemberPath="Value"
    *     isDropShadowEnabled=true
    *     markerType="circle"
    *    transitionInEasingFunction ="cubicEase"
    *    isTransitionInEnabled= {true}  />
    *  </IgrDataChart>
    * ```
    *
    * ```ts
    * this.series.transitionInEasingFunction =  EasingFunctions.cubicEase;
    * ```
    */
    transitionInEasingFunction?: (time: number) => number;
    /**
     * Gets or sets the EasingFunction used to morph the current series during the initial transition.
    */
    transitionOutEasingFunction?: (time: number) => number;
    /**
     * Gets or sets the duration of the current series' morph.
    *
    * The `TransitionDuration` can be used to play animation when data is added or removed from a `Series`. To play an initial animation see `TransitionInDuration`.
    *
    * ```ts
    * this.series.transitionDuration = 500;
    * ```
    *
    * ```ts
    *  <IgrDataChart
    *     dataSource={this.state.dataSource} >
    *
    *     <IgrNumericXAxis name="xAxis" />
    *     <IgrNumericYAxis name="yAxis" />
    *
    *     <IgrAreaSeries
    *      name="series1"
    *     xAxisName="xAxis"
    * 	yAxisName="yAxis"
    * 	valueMemberPath="Value"
    *     isTransitionInEnabled=true
    *     transitionInSpeedType="indexScaled"
    *     transitionDuration= {500}
    *     transitionInDuration = {500} />
    *  </IgrDataChart>
    * ```
    */
    transitionDuration?: number | string;
    actualResolution?: number | string;
    /**
     * Gets or sets the current series object's rendering resolution.
    *
    * Setting the `Resolution` on a Series to a higher value can help with performance, but it will lower the graphical fidelity of the line. As such, it can be increased up until the fidelity is unacceptable.
    *
    * ```ts
    * this.series.resolution = 1.5;
    * ```
    *
    * ```ts
    *  <IgrDataChart
    *     dataSource={this.state.dataSource} >
    *
    *     <IgrNumericXAxis name="xAxis" />
    *     <IgrNumericYAxis name="yAxis" />
    *
    *     <IgrAreaSeries
    *      name="series1"
    *     xAxisName="xAxis"
    * 	yAxisName="yAxis"
    * 	valueMemberPath="Value"
    *     resolution= {1.5} />
    *  </IgrDataChart>
    * ```
    */
    resolution?: number | string;
    /**
     * Gets or sets the top margin to use when getting a visible axis range for the series.
    */
    visibleRangeMarginTop?: number | string;
    /**
     * Gets or sets the bottom margin to use when getting a visible axis range for the series.
    */
    visibleRangeMarginBottom?: number | string;
    /**
     * Gets or sets the left margin to use when getting a visible axis range for the series.
    */
    visibleRangeMarginLeft?: number | string;
    /**
     * Gets or sets the right margin to use when getting a visible axis range for the series.
    */
    visibleRangeMarginRight?: number | string;
    /**
     * Gets or sets the Title property.
     * The legend item control is created according to the Title on-demand by
     * the series object itself.
    *
    * The `Series` `Title` may be used in tooltips and legends.
    *
    * ```ts
    * this.series.title = "InStock Items";
    * ```
    *
    * ```ts
    *  <IgrDataChart
    *     dataSource={this.state.dataSource} >
    *
    *     <IgrNumericXAxis name="xAxis" />
    *     <IgrNumericYAxis name="yAxis" />
    *
    *     <IgrAreaSeries
    *      name="series1"
    *     xAxisName="xAxis"
    * 	yAxisName="yAxis"
    * 	valueMemberPath="Value"
    *    title="InStock Items" />
    *  </IgrDataChart>
    * ```
    */
    title?: any;
    /**
     * Gets or sets the HighlightedTitleSuffix property.
    */
    highlightedTitleSuffix?: string;
    /**
     * Gets or sets whether the highlighted values layer should have a legend item.
    */
    highlightedLegendItemVisibility?: Visibility | string;
    /**
     * Gets or sets the brush to use for the series.
    *
    * The `Brush` along with the `Outline` and `Negative Brush` can be used to affect the visuals of the `Series`.
    *
    * ```ts
    * this.series.brush = "red";
    * ```
    *
    * ```ts
    *  <IgrDataChart
    *     dataSource={this.state.dataSource} >
    *
    *     <IgrNumericXAxis name="xAxis" />
    *     <IgrNumericYAxis name="yAxis" />
    *
    *     <IgrAreaSeries
    *      name="series1"
    *     xAxisName="xAxis"
    * 	yAxisName="yAxis"
    * 	valueMemberPath="Value"
    *     brush="Gray"
    *     outline="Black" />
    *  </IgrDataChart>
    * ```
    */
    brush?: string;
    /**
     * Gets the effective brush for the current series object.
    *
    * ```ts
    * let actualBrush: string = series.actualBrush;
    * ```
    */
    actualBrush?: string;
    /**
     * Gets or sets the selection brush to use for the series.
    */
    selectionBrush?: string;
    /**
     * Gets or sets the Focus brush to use for the series.
    */
    focusBrush?: string;
    /**
     * Gets the effective emphasis brush for the current series object.
    */
    actualSelectionBrush?: string;
    /**
     * Gets the effective emphasis brush for the current series object.
    */
    actualFocusBrush?: string;
    /**
     * Gets the effective brush for the current series object with opacity removed so its contrasty for use as a font color.
    */
    safeActualBrush?: string;
    /**
     * Gets or sets the brush to use for the outline of the series.
     * Some series types, such as LineSeries, do not display outlines.  Therefore, this property does not affect some charts.
    *
    * The `Outline` along with the `Brush` and `NegativeBrush` can be used to affect the visuals of the `Series`.
    *
    * ```ts
    * this.series.brush = "red";
    * ```
    *
    * ```ts
    *  <IgrDataChart
    *     dataSource={this.state.dataSource} >
    *
    *     <IgrNumericXAxis name="xAxis" />
    *     <IgrNumericYAxis name="yAxis" />
    *
    *     <IgrAreaSeries
    *      name="series1"
    *     xAxisName="xAxis"
    * 	yAxisName="yAxis"
    * 	valueMemberPath="Value"
    *     brush="Gray"
    *     outline="Black" />
    *  </IgrDataChart>
    * ```
    */
    outline?: string;
    /**
     * Gets the effective outline for the current series object.
    *
    * ```ts
    * let actualOutline: string = series.ActualOutline;
    * ```
    */
    actualOutline?: string;
    /**
     * Gets or sets the brush that specifies current series object's line join style.
    */
    lineJoin?: PenLineJoin | string;
    /**
     * Gets or sets whether and how to display highlighted values for the series. Note, this is distinct from the highlighting feature that indicates what is closest or under the mouse.
    */
    highlightedValuesDisplayMode?: SeriesHighlightedValuesDisplayMode | string;
    /**
     * Gets or sets whether and how to display highlighted values for the series. Note, this is distinct from the highlighting feature that indicates what is closest or under the mouse.
    */
    shouldAnimateOnDataSourceSwap?: boolean | string;
    /**
     * Gets or sets the width of the current series object's line thickness.
    *
    * Depending on the `Series` type, this can be the main brush used, or just the outline. For example, when using a `LineSeries` it will affect the thickness of the lines drawn, whereas when using a `ColumnSeries` it will affect the outer border thickness of the columns.
    *
    * ```ts
    * this.series.thickness=5;
    * ```
    *
    * ```ts
    *  <IgrDataChart
    *     dataSource={this.state.dataSource} >
    *
    *     <IgrNumericXAxis name="xAxis" />
    *     <IgrNumericYAxis name="yAxis" />
    *
    *     <IgrAreaSeries
    *      name="series1"
    *     xAxisName="xAxis"
    * 	yAxisName="yAxis"
    * 	valueMemberPath="Value"
    *     thickness= {5} />
    *  </IgrDataChart>
    * ```
    */
    thickness?: number | string;
    /**
     * Gets the effective Thickness for the current series object.
    */
    actualThickness?: number | string;
    /**
     * Gets or sets a collection of Double values that indicate the pattern of dashes and gaps that
     * is used to outline the current series object.
    */
    dashArray?: number[] | string;
    /**
     * Gets actual highlighting mode
    */
    actualHighlightingMode?: SeriesHighlightingMode | string;
    /**
     * Gets actual Selection mode
    */
    actualSelectionMode?: SeriesSelectionMode | string;
    /**
     * Gets actual Selection mode
    */
    actualFocusMode?: SeriesSelectionMode | string;
    /**
     * Gets actual HighlightedValues fade opacity
    */
    actualHighlightedValuesFadeOpacity?: number | string;
    /**
     * Gets or sets the target opacity to fade to for fade style HighlightedValues.
    */
    highlightedValuesFadeOpacity?: number | string;
    /**
     * Gets actual highlighting fade opacity
    */
    actualHighlightingFadeOpacity?: number | string;
    /**
     * Gets or sets the target opacity to fade to for fade style highlighting.
    */
    highlightingFadeOpacity?: number | string;
    /**
     * Gets or sets whether the ActualLegend is FinancialLegend or normal Legend.
    */
    isActualLegendFinancial?: boolean | string;
    /**
     * Gets or sets whether the component level highlight mode is ignored.
    */
    isComponentHighlightingModeIgnored?: boolean | string;
    /**
     * Gets or sets whether highlighting should be enabled for this series, if this type of series supports highlighting.
    *
    * ```ts
    * this.series.isHighlightingEnabled = true;
    * ```
    *
    * ```ts
    * <IgrDataChart
    *     dataSource={this.state.dataSource} >
    *
    *     <IgrNumericXAxis name="xAxis" />
    *     <IgrNumericYAxis name="yAxis" />
    *
    *     <IgrAreaSeries
    *      name="series1"
    *     xAxisName="xAxis"
    * 	yAxisName="yAxis"
    * 	valueMemberPath="Value"
    *     isHighlightingEnabled="true" />
    *  </IgrDataChart>
    * ```
    */
    isHighlightingEnabled?: boolean | string;
    /**
     * Gets or sets whether the series should use individual palette colors for each item.
    */
    useItemWiseColors?: boolean | string;
    /**
     * Gets or sets whether the opacity should be automatically shifted for the safe actual brush.
    */
    shouldShiftOpacityForSafeActualBrush?: boolean | string;
    /**
     * Gets or sets whether the opacity should be automatically shifted for the safe actual brush.
    */
    shouldRemoveHighlightedDataOnLayerHidden?: boolean | string;
    /**
     * Gets or sets whether this series should suppress it's auto callouts
    */
    shouldHideAutoCallouts?: boolean | string;
    /**
     * Gets or sets whether drop shadow should be enabled for this series.
    *
    * `IsDropShadowEnabled` is used to decide whether drop shadow should be enabled for this series.
    *
    * ```ts
    * this.series.isDropShadowEnabled = true;
    * ```
    *
    * ```ts
    * <IgrDataChart
    *     dataSource={this.state.dataSource} >
    *
    *     <IgrNumericXAxis name="xAxis" />
    *     <IgrNumericYAxis name="yAxis" />
    *
    *     <IgrAreaSeries
    *      name="series1"
    *     xAxisName="xAxis"
    * 	yAxisName="yAxis"
    * 	valueMemberPath="Value"
    *     isDropShadowEnabled="true" />
    *  </IgrDataChart>
    * ```
    */
    isDropShadowEnabled?: boolean | string;
    /**
     * Gets or sets the shadow blur.
     * This property is ignored when
     * Series.UseSingleShadow is set to true.
    *
    * `ShadowBlur` can be set in conjection with `IsDropShadowEnabled` to further define the drop shadow effect.
    *
    * ```ts
    * this.series.shadowBlur = 7;
    * ```
    *
    * ```ts
    *  <IgrDataChart
    *     dataSource={this.state.dataSource} >
    *
    *     <IgrNumericXAxis name="xAxis" />
    *     <IgrNumericYAxis name="yAxis" />
    *
    *     <IgrAreaSeries
    *      name="series1"
    *     xAxisName="xAxis"
    * 	yAxisName="yAxis"
    * 	valueMemberPath="Value"
    *     shadowBlur={7}
    *     shadowColor="blue" />
    *  </IgrDataChart>
    * ```
    */
    shadowBlur?: number | string;
    /**
     * Gets or sets the drop shadow color.
    *
    * `ShadowColor` can be set in conjection with `IsDropShadowEnabled` to further define the drop shadow effect.
    *
    * ```ts
    * this.series.shadowColor = "blue";
    * ```
    *
    * ```ts
    *  <IgrDataChart
    *     dataSource={this.state.dataSource} >
    *
    *     <IgrNumericXAxis name="xAxis" />
    *     <IgrNumericYAxis name="yAxis" />
    *
    *     <IgrAreaSeries
    *      name="series1"
    *     xAxisName="xAxis"
    * 	yAxisName="yAxis"
    * 	valueMemberPath="Value"
    *     shadowBlur="7"
    *     shadowColor="blue" />
    *  </IgrDataChart>
    * ```
    */
    shadowColor?: string;
    /**
     * Gets or sets whether drop shadow is applied to the whole series visual or to each of the individual shapes forming the series.
     * When this property is set to true, no
     * Series.ShadowBlur is applied.
    *
    * ```ts
    * this.series.useSingleShadow = true;
    * ```
    *
    * ```ts
    *  <IgrDataChart
    *     dataSource={this.state.dataSource} >
    *
    *     <IgrNumericXAxis name="xAxis" />
    *     <IgrNumericYAxis name="yAxis" />
    *
    *     <IgrAreaSeries
    *      name="series1"
    *     xAxisName="xAxis"
    * 	yAxisName="yAxis"
    * 	valueMemberPath="Value"
    *     isDropShadowEnabled=true
    *     markerType="circle"
    *     useSingleShadow= {true} />
    *  </IgrDataChart>
    * ```
    */
    useSingleShadow?: boolean | string;
    /**
     * Gets or sets the drop shadow x-offset.
    *
    * `ShadowOffsetX` can be set in conjection with `IsDropShadowEnabled` to further define the drop shadow effect.
    *
    * ```ts
    * this.series.shadowOffsetX = 10;
    * ```
    *
    * ```ts
    *  <IgrDataChart
    *     dataSource={this.state.dataSource} >
    *
    *     <IgrNumericXAxis name="xAxis" />
    *     <IgrNumericYAxis name="yAxis" />
    *
    *     <IgrAreaSeries
    *      name="series1"
    *     xAxisName="xAxis"
    * 	yAxisName="yAxis"
    * 	valueMemberPath="Value"
    *     shadowOffsetX= {10}
    *     shadowOffsetY={10] />
    *  </IgrDataChart>
    * ```
    */
    shadowOffsetX?: number | string;
    /**
     * Gets or sets the drop shadow y-offset.
    *
    * `ShadowOffsetY` can be set in conjection with `IsDropShadowEnabled` to further define the drop shadow effect.
    *
    * ```ts
    * this.series.shadowOffsetY = 10;
    * ```
    *
    * ```ts
    *  <IgrDataChart
    *     dataSource={this.state.dataSource} >
    *
    *     <IgrNumericXAxis name="xAxis" />
    *     <IgrNumericYAxis name="yAxis" />
    *
    *     <IgrAreaSeries
    *      name="series1"
    *     xAxisName="xAxis"
    * 	yAxisName="yAxis"
    * 	valueMemberPath="Value"
    *     shadowOffsetX= {10}
    *     shadowOffsetY= {10} />
    *  </IgrDataChart>
    * ```
    */
    shadowOffsetY?: number | string;
    /**
     * Gets or sets the opacity applied to the area fill visual.
     * This property only applies to series that have area visual.
    *
    * ```ts
    *  <IgrDataChart
    *     dataSource={this.state.dataSource} >
    *
    *     <IgrNumericXAxis name="xAxis" />
    *     <IgrNumericYAxis name="yAxis" />
    *
    *     <IgrAreaSeries
    *      name="series1"
    *     xAxisName="xAxis"
    * 	yAxisName="yAxis"
    * 	valueMemberPath="Value"
    *    actualAreaFillOpacity= {1} />
    *  </IgrDataChart>
    * ```
    */
    areaFillOpacity?: number | string;
    /**
     * Gets the actual opacity applied to the area fill visual.
    *
    * ```ts
    * let actualFillOpacity: number = series.actualAreaFillOpacity;
    * ```
    */
    actualAreaFillOpacity?: number | string;
    /**
     * Gets or sets the opacity applied to the fill of the markers.
     * This property only applies to series that have area visual.
    */
    markerFillOpacity?: number | string;
    /**
     * Gets the actual opacity applied to the fill of the markers.
    */
    actualMarkerFillOpacity?: number | string;
    /**
     * Gets if the default tooltip has been selected for display.
    *
    * To use the default tooltip set `ShowDefaultTooltip` to true.
    *
    * ```ts
    * let isDefaultToolTipSelected: boolean = this.series.isDefaultToolTipSelected;
    * ```
    */
    isDefaultToolTipSelected?: boolean | string;
    /**
     * Gets or sets whether default tooltip will be shown.
    *
    * The default tooltips display all the information relevant to the particular series item (series title, data values, axis values etc.) and are styled to match the series' style. When using default tooltips, you should also set the series `Title`.
    *
    * ```ts
    *  <IgrDataChart
    *     dataSource={this.state.dataSource} >
    *
    *     <IgrNumericXAxis name="xAxis" />
    *     <IgrNumericYAxis name="yAxis" />
    *
    *     <IgrAreaSeries
    *      name="series1"
    *     xAxisName="xAxis"
    * 	yAxisName="yAxis"
    * 	valueMemberPath="Value"
    *     showDefaultTooltip ="true"
    *     title="InStock Items" />
    *  </IgrDataChart>
    * ```
    *
    * ```ts
    * this.series.showDefaultTooltip ="true";
    * ```
    */
    showDefaultTooltip?: boolean | string;
    /**
     * Gets or sets the visible range mode to use.
    */
    visibleRangeMode?: SeriesVisibleRangeMode | string;
    /**
     * Gets or sets the outline mode to use for the series.
    */
    outlineMode?: SeriesOutlineMode | string;
    /**
     * Gets or sets the duration of the current series' transition in morph.
    *
    * The `TransitionInDuration` can be used with `IsTransitionInEnabled` to cofigure the animation when a new datasource is loaded.
    *
    * ```ts
    * this.series.transitionDuration = 500;
    * ```
    *
    * ```ts
    *  <IgrDataChart
    *     dataSource={this.state.dataSource} >
    *
    *     <IgrNumericXAxis name="xAxis" />
    *     <IgrNumericYAxis name="yAxis" />
    *
    *     <IgrAreaSeries
    *      name="series1"
    *     xAxisName="xAxis"
    * 	yAxisName="yAxis"
    * 	valueMemberPath="Value"
    *     isTransitionInEnabled= {true}
    *     transitionInSpeedType="indexScaled"
    *     transitionDuration={500}
    *     transitionInDuration= {500} />
    *  </IgrDataChart>
    * ```
    */
    transitionInDuration?: number | string;
    /**
     * Gets or sets the duration of the current series' transition out morph.
    */
    transitionOutDuration?: number | string;
    /**
     * Gets or sets the duration of the current series' transition in morph.
    *
    * The `TransitionInSpeedType` can be used with `IsTransitionInEnabled` to cofigure the animation when a new datasource is loaded.
    *
    * ```ts
    * this.series.transitionInSpeedType = TransitionInSpeedType.IndexScaled;
    * ```
    *
    * ```ts
    *  <IgrDataChart
    *     dataSource={this.state.dataSource} >
    *
    *     <IgrNumericXAxis name="xAxis" />
    *     <IgrNumericYAxis name="yAxis" />
    *
    *     <IgrAreaSeries
    *      name="series1"
    *     xAxisName="xAxis"
    * 	yAxisName="yAxis"
    * 	valueMemberPath="Value"
    *     isTransitionInEnabled=true
    *     transitionInSpeedType="indexScaled"
    *     transitionDuration=500
    *     transitionInDuration=500 />
    *  </IgrDataChart>
    * ```
    */
    transitionInSpeedType?: TransitionInSpeedType | string;
    /**
     * Gets or sets the duration of the current series' transition out morph.
    */
    transitionOutSpeedType?: TransitionOutSpeedType | string;
    /**
     * Gets or sets the style of the starting point of any lines or polylines representing this series.
     * Not every series type has a line at which it would be appropriate to display a start cap, so this property does not affect every series type.  LineSeries, for example, is affected by StartCap, but ColumnSeries is not.
    */
    lineCap?: PenLineCap | string;
    /**
     * Gets or sets the AutoCalloutLabel format string to use for the AutoCalloutLabel.
    */
    autoCalloutLabelFormat?: string;
    /**
     * Gets or sets the format specifiers to use with the AutoCalloutLabelFormat string.
    */
    autoCalloutLabelFormatSpecifiers?: any[];
    /**
     * Gets or sets the AutoCalloutLabel format string to use for the AutoCalloutLabel.
    */
    autoCalloutValueLabelFormat?: string;
    /**
     * Gets or sets the format specifiers to use with the AutoCalloutValueLabelFormat string.
    */
    autoCalloutValueLabelFormatSpecifiers?: any[];
    /**
     * Gets or sets the whether the chart reacts to mouse move events.
    */
    mouseOverEnabled?: boolean | string;
    /**
     * Gets or sets the coercion methods to use when loading data from data sources.
     * Should be specified before setting any member paths, if being used. Setting it later
     * will not cause data to be reimported into the chart.
    *
    * &lt;-- position: content member-->
    *
    * ```ts
    * cMethods: any = {
    *     ValueCoercion: function(value:number): number {return value+2;}
    *  }
    * ```
    *
    * ```ts
    *  <IgrDataChart
    *     dataSource={this.state.dataSource}
    *     width="700px"
    *     height="500px">
    *
    *     <IgrNumericXAxis name="xAxis" />
    *     <IgrNumericYAxis name="yAxis" />
    *
    *     <IgrScatterPolygonSeries
    *      name="series1"
    *      shapeMemberPath="Points"
    *      title="House Floor Plan"
    *      brush="Gray"
    *      outline="Black"
    * 	 coercionMethods = {this.ValueCoercion} />
    *  </IgrDataChart>
    * ```
    */
    coercionMethods?: any;
    /**
     * Gets or sets whether the series should expect that properties in its items source may be functions that need to be
     * evaluated to yield their value. This defaults to false, as there will be a subtle performance impact to using this feature.
     * This value must be set before assigning an item's source to take effect.
    *
    * `expectFunctions` is used to decide whether the series should expect that its data source members need to be called as functions to get their values.
    *
    * ```ts
    *  <IgrDataChart
    *     dataSource={this.state.dataSource} >
    *
    *     <IgrNumericXAxis name="xAxis" />
    *     <IgrNumericYAxis name="yAxis" />
    *
    *     <IgrAreaSeries
    *      name="series1"
    *     xAxisName="xAxis"
    * 	yAxisName="yAxis"
    * 	valueMemberPath="MyFunction"
    *     expectFunctions={true} />
    *  </IgrDataChart>
    * ```
    *
    * ```ts
    * this.series.expectFunctions=true;
    * ```
    */
    expectFunctions?: boolean | string;
    /**
     * Method of hit testing to use when pointing to items in this series.
    *
    * The `HitTestMode` can be set to either:
    *
    * -   `Auto`: automatically decide the appropriate hit test mode for the series.
    * -   `ColorEncoded`: use a color encoded off screen buffer for hit testing. Should always be O(1) time for determining a hit series. This increases frame render time and memory usage, however. Consider using this if hit testing time is degrading performance.
    * -   `Computational`: use a computational based approach to determine whether the series has been hit. This uses loose bounding boxes, in some cases, and can range in time complexity between O(1) and O(log n) to find a hit. This decreases frame render time compared to color encoded
    *
    * ```ts
    * this.series.hitTestMode = SeriesHitTestMode.Computational;
    * ```
    */
    hitTestMode?: SeriesHitTestMode | string;
    /**
     * Resolved method of hit testing to use when pointing to items in the chart.
    *
    * ```ts
    * let hitTestMode: SeriesHitTestMode = this.series.actualHitTestMode;
    * ```
    */
    actualHitTestMode?: SeriesHitTestMode | string;
    /**
     * The final value of this series.
    */
    finalValue?: number | string;
    /**
     * The percent change from the beginning to the end of this series.
    */
    percentChange?: number | string;
    opacity?: number | string;
    visibility?: Visibility | string;
    /**
 * Fired when a transition out has completed.
*/
    transitionOutCompleted?: (s: IgrSeries, e: IgrTransitionOutCompletedEventArgs) => void;
    /**
     * This event is raised every time a render has been requested from a series.
    *
    * ```ts
    *  const series1 = new IgrAreaSeries({ name: "series1" });
    * series1.valueMemberPath = "USA";
    * series1.title = "USA";
    * series1.xAxisName = "xAxis";
    * series1.yAxisName = "yAxis";
    * series1.renderRequested= this.onRenderRequested;
    *
    * public onRenderRequested =( s:IgrSeries, e: RenderRequestedEventArgs) => {
    *           }
    * ```
    *
    * ```ts
    *  <IgrDataChart
    *     dataSource={this.state.dataSource} >
    *
    *     <IgrNumericXAxis name="xAxis" />
    *     <IgrNumericYAxis name="yAxis" />
    *
    *     <IgrAreaSeries
    *      name="series1"
    *     xAxisName="xAxis"
    * 	yAxisName="yAxis"
    * 	valueMemberPath="Value"
    *     shadowBlur="7"
    *     shadowColor="blue"
    * 	renderRequested= {this.onRenderRequested}/>
    *  </IgrDataChart>
    * ```
    */
    renderRequested?: (s: IgrSeries, e: IgrRenderRequestedEventArgs) => void;
}
