import { Control } from "igniteui-react-core";
import { INotifyPropertyChanged, Base, Type, Point, EventArgs, PropertyChangedEventArgs, IEnumerable, IEnumerable$1, IList$1 } from "igniteui-react-core";
import { ILegendOwner } from "igniteui-react-core";
import { IInternalLegendOwner } from "igniteui-react-core";
import { IDataLegendTarget } from "igniteui-react-core";
import { IToolbarTarget } from "igniteui-react-core";
import { ISupportsAnimation } from "igniteui-react-core";
import { ISeriesViewerWidget } from "./ISeriesViewerWidget";
import { SRProvider } from "igniteui-react-core";
import { ToolCommand } from "igniteui-react-core";
import { SeriesPlotAreaMarginHorizontalMode } from "./SeriesPlotAreaMarginHorizontalMode";
import { SeriesPlotAreaMarginVerticalMode } from "./SeriesPlotAreaMarginVerticalMode";
import { SeriesViewerScrollbarMode } from "./SeriesViewerScrollbarMode";
import { IHighlightingManager } from "igniteui-react-core";
import { DoubleAnimator } from "igniteui-react-core";
import { BrushCollection } from "igniteui-react-core";
import { DependencyProperty } from "igniteui-react-core";
import { DependencyObject } from "igniteui-react-core";
import { MarkerAutomaticBehavior } from "./MarkerAutomaticBehavior";
import { IChartLegend } from "igniteui-react-core";
import { SeriesHighlightingMode } from "./SeriesHighlightingMode";
import { SeriesSelectionMode } from "./SeriesSelectionMode";
import { SeriesSelectionBehavior } from "./SeriesSelectionBehavior";
import { SeriesViewerHorizontalScrollbarPosition } from "./SeriesViewerHorizontalScrollbarPosition";
import { SeriesViewerVerticalScrollbarPosition } from "./SeriesViewerVerticalScrollbarPosition";
import { Brush } from "igniteui-react-core";
import { SeriesHighlightingBehavior } from "./SeriesHighlightingBehavior";
import { LegendHighlightingMode } from "./LegendHighlightingMode";
import { LegendItemBadgeShape } from "igniteui-react-core";
import { LegendItemBadgeMode } from "igniteui-react-core";
import { Rect } from "igniteui-react-core";
import { ChartHitTestMode } from "./ChartHitTestMode";
import { InteractionState } from "igniteui-react-core";
import { WindowResponse } from "./WindowResponse";
import { Visibility } from "igniteui-react-core";
import { IOverviewPlusDetailPane } from "igniteui-react-core";
import { SeriesViewerComponentsFromView } from "./SeriesViewerComponentsFromView";
import { ZoomCoercionMode } from "./ZoomCoercionMode";
import { ModifierKeys } from "igniteui-react-core";
import { SeriesHighlightedValuesDisplayMode } from "igniteui-react-core";
import { DataTemplate } from "igniteui-react-core";
import { HorizontalAlignment } from "igniteui-react-core";
import { CanvasRenderScheduler } from "igniteui-react-core";
import { SyncSettings } from "./SyncSettings";
import { ToolActionInfo } from "igniteui-react-core";
import { ToolCommandExecutionState } from "igniteui-react-core";
import { ICommandAvailabilityListener } from "igniteui-react-core";
import { ICommandStateChangedListener } from "igniteui-react-core";
import { List$1 } from "igniteui-react-core";
import { IToolbarContextAccessor } from "igniteui-react-core";
import { SeriesViewerComponentsForView } from "./SeriesViewerComponentsForView";
import { Dictionary$2 } from "igniteui-react-core";
import { IDataLegend } from "igniteui-react-core";
import { PropertyUpdatedEventArgs } from "igniteui-react-core";
import { NotifyCollectionChangedEventArgs } from "igniteui-react-core";
import { ObservableCollection$1 } from "igniteui-react-core";
import { Size } from "igniteui-react-core";
import { FrameworkElement } from "igniteui-react-core";
import { EventProxy } from "igniteui-react-core";
import { MouseEventArgs } from "igniteui-react-core";
import { MouseButtonEventArgs } from "igniteui-react-core";
import { Tuple$2 } from "igniteui-react-core";
import { ScalerParams } from "./ScalerParams";
import { SeriesViewerManipulationEventArgs } from "./SeriesViewerManipulationEventArgs";
import { IFastItemsSource } from "igniteui-react-core";
import { Key } from "igniteui-react-core";
import { RectChangedEventArgs } from "igniteui-react-core";
import { RefreshCompletedEventArgs } from "./RefreshCompletedEventArgs";
import { Thickness } from "igniteui-react-core";
import { AxisTitlePosition } from "./AxisTitlePosition";
import { FontInfo } from "igniteui-react-core";
import { CoercionInfo } from "./CoercionInfo";
import { IDataLegendSeries } from "igniteui-react-core";
import { CaptureImageSettings } from "igniteui-react-core";
import { CultureInfo } from "igniteui-react-core";
import { ImageCapturedEventArgs } from "igniteui-react-core";
import { ChartContentType } from "./ChartContentType";
import { ISchedulableRender } from "igniteui-react-core";
import { Rectangle } from "igniteui-react-core";
import { Path } from "igniteui-react-core";
import { Line } from "igniteui-react-core";
import { RenderingContext } from "igniteui-react-core";
import { TextBlock } from "igniteui-react-core";
import { ITileZoomTile } from "./ITileZoomTile";
import { IExecutionContext } from "igniteui-react-core";
import { RenderSurface } from "./RenderSurface";
import { PathGeometry } from "igniteui-react-core";
import { Geometry } from "igniteui-react-core";
import { DataContext } from "igniteui-react-core";
import { LabelPanelsArrangeState } from "./LabelPanelsArrangeState";
import { DataTemplateRenderInfo } from "igniteui-react-core";
import { DataTemplateMeasureInfo } from "igniteui-react-core";
import { AxisLabelsLocation } from "./AxisLabelsLocation";
import { IProvidesViewport } from "./IProvidesViewport";
import { ActualLegendItemBadgeShape } from "./ActualLegendItemBadgeShape";
import { StandardLegendItems } from "igniteui-react-core";
import { DomRenderer, DomWrapper } from "igniteui-react-core";
import { PointerTooltipStyle } from "./PointerTooltipStyle";
import { DefaultPaletteInfo } from "./DefaultPaletteInfo";
import { AxisRange } from "./AxisRange";
import { AxisAnnotationCollection } from "./AxisAnnotationCollection";
import { VerticalAlignment } from "igniteui-react-core";
import { Canvas } from "igniteui-react-core";
import { IFastItemsSourceProvider } from "igniteui-react-core";
import { AxisExtentType } from "./AxisExtentType";
import { DoubleCollection } from "igniteui-react-core";
import { LabelPosition } from "./LabelPosition";
import { BindingFormatter } from "igniteui-react-core";
import { LabelFontHeuristics } from "./LabelFontHeuristics";
import { AxisOrientation } from "./AxisOrientation";
import { Pool$1 } from "igniteui-react-core";
import { AxisComponentsFromView } from "./AxisComponentsFromView";
import { AxisRangeChangedEventArgs } from "./AxisRangeChangedEventArgs";
import { GeometryCollection } from "igniteui-react-core";
import { PathRenderingInfo } from "./PathRenderingInfo";
import { RenderRequestedEventArgs } from "./RenderRequestedEventArgs";
import { CategoryMode } from "./CategoryMode";
import { GridMode } from "./GridMode";
import { Panel } from "igniteui-react-core";
import { UIElement } from "igniteui-react-core";
import { TickmarkValues } from "./TickmarkValues";
import { ICategoryScaler } from "./ICategoryScaler";
import { FastItemsSourceEventArgs } from "igniteui-react-core";
import { FastItemsSourceEventAction } from "igniteui-react-core";
import { AxisRangeBufferMode } from "./AxisRangeBufferMode";
import { NumericAxisRenderingParameters } from "./NumericAxisRenderingParameters";
import { AxisRenderingParametersBase } from "./AxisRenderingParametersBase";
import { AutomaticSeriesPurpose } from "./AutomaticSeriesPurpose";
import { SeriesMatcher } from "./SeriesMatcher";
import { Stack$1 } from "igniteui-react-core";
import { RenderValidEventArgs } from "./RenderValidEventArgs";
import { SeriesLayerPropertyOverlayValueResolvingEventArgs } from "./SeriesLayerPropertyOverlayValueResolvingEventArgs";
import { HighlightingInfo } from "igniteui-react-core";
import { Marker } from "./Marker";
import { Polyline } from "igniteui-react-core";
import { ContentControl } from "igniteui-react-core";
import { Polygon } from "igniteui-react-core";
import { AutoMarginsAndAngleUpdateMode } from "./AutoMarginsAndAngleUpdateMode";
import { ComputedPlotAreaMarginMode } from "./ComputedPlotAreaMarginMode";
import { ILegendSeries } from "igniteui-react-core";
import { ILegendSeriesInternal } from "igniteui-react-core";
import { ILegendTemplateProvider } from "igniteui-react-core";
import { PenLineJoin } from "igniteui-react-core";
import { PenLineCap } from "igniteui-react-core";
import { Color } from "igniteui-react-core";
import { SeriesVisibleRangeMode } from "./SeriesVisibleRangeMode";
import { SeriesOutlineMode } from "./SeriesOutlineMode";
import { TransitionInSpeedType } from "./TransitionInSpeedType";
import { TransitionOutSpeedType } from "./TransitionOutSpeedType";
import { SeriesHitTestMode } from "./SeriesHitTestMode";
import { SeriesComponentsForView } from "./SeriesComponentsForView";
import { MarkerOutlineMode } from "./MarkerOutlineMode";
import { MarkerFillMode } from "./MarkerFillMode";
import { CollisionGeometry } from "igniteui-react-core";
import { SeriesPointOfInterest } from "./SeriesPointOfInterest";
import { ValueLayerValueMode } from "./ValueLayerValueMode";
import { TransitionOutCompletedEventArgs } from "./TransitionOutCompletedEventArgs";
import { ISortingAxis } from "./ISortingAxis";
import { SeriesComponentsFromView } from "./SeriesComponentsFromView";
import { IFastItemColumn$1 } from "igniteui-react-core";
import { MarkerType } from "./MarkerType";
import { Style } from "igniteui-react-core";
import { HashPool$2 } from "igniteui-react-core";
/**
 * @hidden
 */
export declare abstract class SeriesViewer extends Control implements INotifyPropertyChanged, ILegendOwner, IInternalLegendOwner, IDataLegendTarget, IToolbarTarget, ISupportsAnimation {
    static $t: Type;
    private _widget;
    get widget(): ISeriesViewerWidget;
    set widget(a: ISeriesViewerWidget);
    c9: SeriesViewerView;
    static staticInit(): void;
    private dt;
    private get du();
    private an;
    ao(a: SeriesViewer): AutomaticSeriesManager;
    getDesiredToolbarActions(): ToolActionInfo[];
    onToolCommandExecuting(a: ToolCommand): ToolCommandExecutionState;
    addCommandAvailabilityListener(a: ICommandAvailabilityListener): void;
    removeCommandAvailabilityListener(a: ICommandAvailabilityListener): void;
    private gn;
    addCommandStateChangedListener(a: ICommandStateChangedListener): void;
    removeCommandStateChangedListener(a: ICommandStateChangedListener): void;
    private _commandCompleted;
    get commandCompleted(): (arg1: ToolCommand) => void;
    set commandCompleted(a: (arg1: ToolCommand) => void);
    private _invalidateActions;
    get invalidateActions(): () => void;
    set invalidateActions(a: () => void);
    private da;
    provideContextAccessor(a: IToolbarContextAccessor): void;
    private n4;
    private a8;
    get a9(): IDataChartToolbarProvider;
    get fi(): boolean;
    private ba;
    get bb(): ISeriesViewerInteractionManager;
    get fa(): boolean;
    constructor();
    private q9;
    private ns;
    private ec;
    protected ps(a: any, b: NotifyCollectionChangedEventArgs): void;
    private eb;
    protected o5(a: any, b: NotifyCollectionChangedEventArgs): void;
    private pc;
    private pa;
    nu(a: (arg1: Series) => void): void;
    private pd;
    private pb;
    private c1;
    nz(): void;
    private qd;
    protected get_ft(): boolean;
    get ft(): boolean;
    protected get_fs(): boolean;
    get fs(): boolean;
    n0(): void;
    get series(): SeriesCollection;
    private br;
    private iy;
    private rb;
    private bz;
    get b0(): SeriesPlotAreaMarginHorizontalMode;
    set b0(a: SeriesPlotAreaMarginHorizontalMode);
    private b1;
    get b2(): SeriesPlotAreaMarginVerticalMode;
    set b2(a: SeriesPlotAreaMarginVerticalMode);
    n2(): void;
    protected oq(): void;
    private _skipDataCleanup;
    get skipDataCleanup(): boolean;
    set skipDataCleanup(a: boolean);
    protected q3(a: any): void;
    get ew(): boolean;
    private rc;
    n6(a: number, b: number, c: boolean, d: boolean): {
        p0?: number;
        p1?: number;
    };
    ev(): boolean;
    get f8(): boolean;
    protected get e6(): boolean;
    protected get eo(): boolean;
    protected get en(): boolean;
    get em(): boolean;
    get dl(): IHighlightingManager;
    get dm(): IHighlightingManager;
    get dk(): IHighlightingManager;
    get bc(): ISeriesViewerScrollbarManager;
    private no;
    private np;
    private nn;
    dc: DoubleAnimator;
    de: DoubleAnimator;
    db: DoubleAnimator;
    dd: DoubleAnimator;
    private ny;
    private ra;
    private nt;
    ge(a: number): boolean;
    gf(a: number): boolean;
    gd(a: number): boolean;
    nx(): void;
    va(a: number): Brush;
    vg(a: number): Brush;
    ve(a: number): Brush;
    vf(a: number): Brush;
    private u9;
    ag: BrushCollection;
    aj: BrushCollection;
    ah: BrushCollection;
    ai: BrushCollection;
    bg: MarkerAutomaticBehavior;
    ar: ChartContentManager;
    get vv(): Point;
    set vv(a: Point);
    private vu;
    qz(): void;
    get e9(): boolean;
    get legend(): IChartLegend;
    set legend(a: IChartLegend);
    static readonly td: DependencyProperty;
    get ek(): boolean;
    set ek(a: boolean);
    get f2(): boolean;
    set f2(a: boolean);
    plotAreaMouseLeftButtonDown: (sender: any, e: PlotAreaMouseButtonEventArgs) => void;
    plotAreaMouseLeftButtonUp: (sender: any, e: PlotAreaMouseButtonEventArgs) => void;
    plotAreaClicked: (sender: any, e: PlotAreaMouseButtonEventArgs) => void;
    plotAreaMouseEnter: (sender: any, e: PlotAreaMouseEventArgs) => void;
    plotAreaMouseLeave: (sender: any, e: PlotAreaMouseEventArgs) => void;
    plotAreaMouseOver: (sender: any, e: PlotAreaMouseEventArgs) => void;
    pn(a: Point, b: boolean): void;
    private bh;
    private bl;
    po(a: Point, b: boolean, c: boolean): void;
    static readonly sd: DependencyProperty;
    static readonly t0: DependencyProperty;
    get fj(): boolean;
    set fj(a: boolean);
    static readonly s9: DependencyProperty;
    get f7(): boolean;
    set f7(a: boolean);
    static readonly t3: DependencyProperty;
    get by(): SeriesHighlightingMode;
    set by(a: SeriesHighlightingMode);
    static readonly sr: DependencyProperty;
    get cb(): SeriesSelectionMode;
    set cb(a: SeriesSelectionMode);
    static readonly tx: DependencyProperty;
    get b6(): SeriesSelectionBehavior;
    set b6(a: SeriesSelectionBehavior);
    static readonly tv: DependencyProperty;
    get b9(): SeriesSelectionMode;
    set b9(a: SeriesSelectionMode);
    static readonly sl: DependencyProperty;
    get ch(): SeriesViewerScrollbarMode;
    set ch(a: SeriesViewerScrollbarMode);
    protected cf: SeriesViewerScrollbarMode;
    static readonly sz: DependencyProperty;
    get ci(): SeriesViewerScrollbarMode;
    set ci(a: SeriesViewerScrollbarMode);
    protected cg: SeriesViewerScrollbarMode;
    static readonly uh: DependencyProperty;
    get ce(): SeriesViewerHorizontalScrollbarPosition;
    set ce(a: SeriesViewerHorizontalScrollbarPosition);
    static readonly s1: DependencyProperty;
    get cl(): SeriesViewerVerticalScrollbarPosition;
    set cl(a: SeriesViewerVerticalScrollbarPosition);
    static readonly uj: DependencyProperty;
    get vi(): Brush;
    set vi(a: Brush);
    static readonly sv: DependencyProperty;
    get vj(): Brush;
    set vj(a: Brush);
    static readonly s0: DependencyProperty;
    get hy(): number;
    set hy(a: number);
    static readonly s3: DependencyProperty;
    get hx(): number;
    set hx(a: number);
    static readonly sy: DependencyProperty;
    get hu(): number;
    set hu(a: number);
    static readonly su: DependencyProperty;
    get hv(): number;
    set hv(a: number);
    static readonly sw: DependencyProperty;
    get hw(): number;
    set hw(a: number);
    static readonly sx: DependencyProperty;
    get h0(): number;
    set h0(a: number);
    static readonly s5: DependencyProperty;
    get hz(): number;
    set hz(a: number);
    static readonly s4: DependencyProperty;
    get ey(): boolean;
    set ey(a: boolean);
    static readonly kj: string;
    static readonly s2: DependencyProperty;
    get vs(): Brush;
    set vs(a: Brush);
    static readonly ue: DependencyProperty;
    get vt(): Brush;
    set vt(a: Brush);
    static readonly ui: DependencyProperty;
    get il(): number;
    set il(a: number);
    static readonly ul: DependencyProperty;
    get ik(): number;
    set ik(a: number);
    static readonly ug: DependencyProperty;
    get ii(): number;
    set ii(a: number);
    static readonly ud: DependencyProperty;
    get ip(): number;
    set ip(a: number);
    ne(): void;
    private pq;
    static readonly uo: DependencyProperty;
    get ij(): number;
    set ij(a: number);
    static readonly uf: DependencyProperty;
    get io(): number;
    set io(a: number);
    static readonly un: DependencyProperty;
    get im(): number;
    set im(a: number);
    static readonly um: DependencyProperty;
    get gj(): boolean;
    set gj(a: boolean);
    static readonly mo: string;
    static readonly uk: DependencyProperty;
    private ca;
    private b5;
    private bx;
    private bu;
    get bv(): SeriesHighlightingBehavior;
    private b7;
    get b8(): SeriesSelectionMode;
    private b3;
    get b4(): SeriesSelectionBehavior;
    get bw(): SeriesHighlightingBehavior;
    set bw(a: SeriesHighlightingBehavior);
    static readonly sq: DependencyProperty;
    get bd(): LegendHighlightingMode;
    set bd(a: LegendHighlightingMode);
    static readonly ta: DependencyProperty;
    get bf(): LegendItemBadgeShape;
    set bf(a: LegendItemBadgeShape);
    static readonly tc: DependencyProperty;
    get be(): LegendItemBadgeMode;
    set be(a: LegendItemBadgeMode);
    static readonly tb: DependencyProperty;
    propertyChanged: (sender: any, e: PropertyChangedEventArgs) => void;
    propertyUpdated: (sender: any, e: PropertyUpdatedEventArgs) => void;
    protected qm(a: string, b: any, c: any): void;
    ja: any;
    pe(): void;
    pf(a: IEnumerable): void;
    pv(a: Series, b: any, c: any, d: Point): void;
    pz(a: Series, b: any, c: any, d: Point): void;
    pw(a: Series, b: any, c: any, d: Point): void;
    px(a: Series, b: any, c: any, d: Point): void;
    py(a: Series, b: any, c: any, d: Point): void;
    m4(a: Rect, b: ScalerParams): Tuple$2<boolean, number>;
    get fp(): boolean;
    private d7;
    op(a: boolean): void;
    on(a: boolean): void;
    p0(a: Series, b: any, c: any, d: Point): void;
    p1(a: Series, b: any, c: any, d: Point): void;
    seriesCursorMouseMove: (sender: any, e: ChartCursorEventArgs) => void;
    qq(a: Series, b: any): void;
    seriesMouseLeftButtonDown: (sender: any, e: DataChartMouseButtonEventArgs) => void;
    qu(a: Series, b: any, c: MouseButtonEventArgs, d: Point): void;
    seriesMouseLeftButtonUp: (sender: any, e: DataChartMouseButtonEventArgs) => void;
    seriesClick: (sender: any, e: DataChartMouseButtonEventArgs) => void;
    qv(a: Series, b: any, c: MouseButtonEventArgs, d: Point): void;
    qp(a: Series, b: any, c: MouseButtonEventArgs, d: Point): void;
    pt(a: Series, b: any): void;
    private gs;
    private gt;
    private fc;
    private gp;
    private nv;
    private gq;
    seriesMouseMove: (sender: any, e: ChartMouseEventArgs) => void;
    rg(a: Point): void;
    rh(a: Point): void;
    qw(a: Series, b: any, c: MouseEventArgs, d: Point): void;
    seriesMouseEnter: (sender: any, e: ChartMouseEventArgs) => void;
    qs(a: Series, b: any, c: MouseEventArgs, d: Point): void;
    seriesMouseLeave: (sender: any, e: ChartMouseEventArgs) => void;
    qt(a: Series, b: any, c: MouseEventArgs, d: Point): void;
    private d1;
    oo(): void;
    private d0;
    om(): void;
    private v3;
    protected get_wk(): Rect;
    get wk(): Rect;
    private v1;
    get v8(): Rect;
    set v8(a: Rect);
    protected get_ex(): boolean;
    get ex(): boolean;
    wd(a: Rect, b: Rect, c: Rect): Rect;
    private dy;
    private v0;
    protected get_v7(): Rect;
    get v7(): Rect;
    wb(a: Rect, b: Rect, c: Rect): Rect;
    protected v6(a: Rect): Rect;
    wc(): Rect;
    protected rl(a: Axis): void;
    wl: Rect;
    gi: boolean;
    eh: boolean;
    fz: boolean;
    i8: number;
    private ix;
    get i1(): number;
    set i1(a: number);
    i5: number;
    i7: number;
    i3: number;
    i6: number;
    protected fq: boolean;
    protected ej: boolean;
    qg(a: Rect, b: Rect): void;
    private cc;
    cd(): SeriesViewerComponentsForView;
    private d5;
    nd(a: Point, b: boolean): void;
    fe: boolean;
    private at;
    get av(): ChartHitTestMode;
    set av(a: ChartHitTestMode);
    qy(): void;
    protected aw(): ChartHitTestMode;
    private as;
    get au(): ChartHitTestMode;
    set au(a: ChartHitTestMode);
    ff: boolean;
    seriesAnimating: (series: Series) => void;
    private dv;
    queueForAnimationIdle(a: () => void, b: number): void;
    getAnimationIdleVersionNumber(): number;
    isAnimationActive(): boolean;
    pu(a: Series): void;
    o7(): void;
    protected p2(): void;
    qo(a: Series): void;
    abstract fl(): boolean;
    abstract fm(): boolean;
    fk(): boolean;
    private d4;
    onDetachedFromUI(): void;
    onAttachedToUI(): void;
    get c0(): InteractionState;
    set c0(a: InteractionState);
    private d2;
    private cv;
    ph(a: Point): void;
    pi(a: Point, b: boolean): void;
    fx(a: Point, b: number): boolean;
    o0(a: Point): void;
    fw(a: Key): boolean;
    private d9;
    er: boolean;
    private dz;
    get el(): boolean;
    set el(a: boolean);
    protected get_fb(): boolean;
    get fb(): boolean;
    o2(a: Point): void;
    get eu(): boolean;
    md: string;
    pm(a: Point): void;
    o3(a: Point, b: boolean): void;
    o1(a: Point): void;
    get fy(): boolean;
    set fy(a: boolean);
    private qb;
    pl(a: Point): void;
    qc(a: Point, b: number, c: number, d: number): void;
    pk(a: number): void;
    p8(a: Point, b: number, c: number, d: number): void;
    pg(a: Point): void;
    pj(a: number): void;
    o6(a: Point): void;
    p7(a: Point, b: number, c: number, d: number): void;
    p4(): void;
    o9(a: Size): void;
    nw(): void;
    ot(a: Point, b: boolean): void;
    cy(a: boolean): InteractionState;
    viewerManipulationStarting: (sender: any, e: SeriesViewerManipulationEventArgs) => void;
    viewerManipulationEnding: (sender: any, e: SeriesViewerManipulationEventArgs) => void;
    private ef;
    qa(a: boolean): void;
    p9(): void;
    ri(): void;
    nl(): void;
    ng(): void;
    nf(): void;
    qe(): void;
    q2(): void;
    q0(): void;
    os(a: Point, b: boolean): void;
    f4(): boolean;
    private ea;
    get ga(): boolean;
    set ga(a: boolean);
    or(a: Point, b: boolean, c: boolean): void;
    ru(a: any, b: PropertyUpdatedEventArgs): void;
    rt(a: SyncLink, b: SyncLink): void;
    nh(a: Point): void;
    rx(a: Rect, b: boolean): void;
    ry(a: Rect, b: boolean, c: boolean): void;
    qf(a: Rect, b: boolean): void;
    get fg(): boolean;
    private _gm;
    gm(): IEnumerable$1<SeriesViewer>;
    vy(a: Point): Point;
    vw(a: Point): Point;
    wj(a: Rect): Rect;
    windowRectChanged: (sender: any, e: RectChangedEventArgs) => void;
    private qx;
    p6(a: Rect, b: Rect): void;
    sizeChanged: (sender: any, e: RectChangedEventArgs) => void;
    p3(a: Size, b: Size): void;
    e1: boolean;
    f0(a: Rect, b: Rect): boolean;
    actualWindowRectChanged: (sender: any, e: RectChangedEventArgs) => void;
    private qj;
    rz(a: number): void;
    r0(a: number): void;
    q8(): void;
    gridAreaRectChanged: (sender: any, e: RectChangedEventArgs) => void;
    private qk;
    protected get_fd(): boolean;
    get fd(): boolean;
    pp(a: Rect, b: Rect): void;
    cp: WindowResponse;
    n5(): void;
    et: boolean;
    it: number;
    is: number;
    private g0;
    get hm(): number;
    set hm(a: number);
    private gz;
    get hl(): number;
    set hl(a: number);
    iv: number;
    iu: number;
    private _syncChannel;
    get syncChannel(): string;
    set syncChannel(a: string);
    private cm;
    get actualSyncLink(): SyncLink;
    set actualSyncLink(a: SyncLink);
    gb: boolean;
    n3(): void;
    wq: Visibility;
    private ee;
    oy(): void;
    ow(): void;
    ox(): void;
    get c2(): IOverviewPlusDetailPane;
    protected rq(a: boolean): void;
    wp: Visibility;
    e0: boolean;
    gh: boolean;
    vh: Brush;
    vr: Brush;
    private cq;
    get cr(): ZoomCoercionMode;
    set cr(a: ZoomCoercionMode);
    cs(): ZoomCoercionMode;
    ct: ZoomCoercionMode;
    vl: Brush;
    u6: Brush;
    vk: Brush;
    f5: boolean;
    eq(): boolean;
    ei(): boolean;
    wm: Rect;
    na(): void;
    private i0;
    private notifyCrosshairUpdate;
    rv(a: number, b: number): void;
    rw(a: number, b: number, c: number, d: number): void;
    hs(): number;
    ht(): number;
    private h6;
    private h5;
    protected qh(a: any, b: string, c: any, d: any): void;
    get e7(): boolean;
    protected get fv(): boolean;
    bq: Series;
    rp(a: Point): void;
    private m3;
    rs(): void;
    protected oj(): void;
    rr(): void;
    private ed;
    protected gc: boolean;
    cw: InteractionState;
    cx: InteractionState;
    cz: InteractionState;
    u1: ModifierKeys;
    u2: ModifierKeys;
    u3: ModifierKeys;
    private v2;
    get we(): Rect;
    set we(a: Rect);
    bt: SeriesHighlightedValuesDisplayMode;
    private _selectedSeriesItems;
    get selectedSeriesItems(): ChartSelectedItemCollection;
    set selectedSeriesItems(a: ChartSelectedItemCollection);
    private _focusedSeriesItems;
    get focusedSeriesItems(): ChartSelectedItemCollection;
    set focusedSeriesItems(a: ChartSelectedItemCollection);
    selectedSeriesItemsChanged: (sender: any, e: SeriesViewerSelectedSeriesItemsChangedEventArgs) => void;
    pr(a: any, b: SeriesViewerSelectedSeriesItemsChangedEventArgs): void;
    focusedSeriesItemsChanged: (sender: any, e: SeriesViewerSelectedSeriesItemsChangedEventArgs) => void;
    o4(a: any, b: SeriesViewerSelectedSeriesItemsChangedEventArgs): void;
    gu: Date;
    gk: boolean;
    protected rk(): void;
    m5(a: Rect, b: Rect): void;
    f1(): boolean;
    protected ok(a: Rect, b: Rect): void;
    iq: number;
    ir: number;
    private wh;
    refreshCompleted: (sender: any, e: RefreshCompletedEventArgs) => void;
    qn(): void;
    protected abstract c8(): SeriesViewerView;
    protected p5(a: SeriesViewerView): void;
    vo: Brush;
    u7: Brush;
    static wg: Rect;
    r1: DataTemplate;
    sa: DataTemplate;
    r7: DataTemplate;
    r8: DataTemplate;
    r2: DataTemplate;
    r5: DataTemplate;
    r3: DataTemplate;
    r9: DataTemplate;
    r6: DataTemplate;
    r4: DataTemplate;
    l3: string;
    u0: HorizontalAlignment;
    uz: HorizontalAlignment;
    private jf;
    get ma(): string;
    set ma(a: string);
    private je;
    get ly(): string;
    set ly(a: string);
    private u5;
    get vq(): Brush;
    set vq(a: Brush);
    private u4;
    get vp(): Brush;
    set vp(a: Brush);
    private hf;
    get ig(): number;
    set ig(a: number);
    private hd;
    get id(): number;
    set id(a: number);
    private he;
    get ie(): number;
    set ie(a: number);
    private hc;
    get ic(): number;
    set ic(a: number);
    private hb;
    get ib(): number;
    set ib(a: number);
    private g9;
    get h9(): number;
    set h9(a: number);
    private ha;
    get ia(): number;
    set ia(a: number);
    private g8;
    get h8(): number;
    set h8(a: number);
    lr: string;
    wn(): Thickness;
    wo(): Thickness;
    ap(a: Axis): AxisTitlePosition;
    aq(a: Axis): AxisTitlePosition;
    abstract getFontInfo(): FontInfo;
    getFontHeight(): number;
    protected get_fu(): boolean;
    get fu(): boolean;
    ov(): void;
    abstract getFontBrush(): Brush;
    abstract u8(): Brush;
    jc: any;
    provideContainer(a: any): void;
    ou(a: number, b: number): void;
    notifyContainerResized(): void;
    v9(): Rect;
    nm(): void;
    vx(): Point;
    dg(): FontInfo;
    df(): FontInfo;
    vb(): Brush;
    vc(): Brush;
    m8(a: Series): void;
    q4(a: Series): void;
    al: CanvasRenderScheduler;
    am: CanvasRenderScheduler;
    ak: CanvasRenderScheduler;
    private d8;
    get fr(): boolean;
    set fr(a: boolean);
    private dx;
    get eg(): boolean;
    set eg(a: boolean);
    private _syncSettings;
    get syncSettings(): SyncSettings;
    set syncSettings(a: SyncSettings);
    m7(a: any): void;
    q6(a: any): void;
    og(source_: any, a: number, b: any, c: any): void;
    n7(source_: any): void;
    oe(source_: any, a: number, b: any): void;
    of(source_: any, a: number, b: any): void;
    destroyed: boolean;
    protected i9: any;
    protected gl: Dictionary$2<string, any>;
    fo: boolean;
    destroy(): void;
    protected nk(): void;
    rf(source_: any): void;
    q7(): void;
    re(a: string, source_: any): void;
    q5(a: string, b: boolean): void;
    protected rd(a: Series, b: any): void;
    protected rn(a: any): void;
    protected ro(): void;
    private hg;
    get ih(): number;
    set ih(a: number);
    private g5;
    get h2(): number;
    set h2(a: number);
    private g7;
    get h7(): number;
    set h7(a: number);
    private g3;
    get hp(): number;
    set hp(a: number);
    private g2;
    get ho(): number;
    set ho(a: number);
    private g1;
    get hn(): number;
    set hn(a: number);
    f3(): boolean;
    private d3;
    get e3(): boolean;
    set e3(a: boolean);
    private g6;
    get h3(): number;
    set h3(a: number);
    private g4;
    get h1(): number;
    set h1(a: number);
    static cu(a: string, b: any): CoercionInfo;
    private jd;
    get k1(): string;
    set k1(a: string);
    private gw;
    get hi(): number;
    set hi(a: number);
    private gv;
    get hh(): number;
    set hh(a: number);
    f6: boolean;
    private vz;
    get v4(): Rect;
    set v4(a: Rect);
    wa(): Rect;
    ez: boolean;
    private n1;
    wf(): Rect;
    protected v5(): Rect;
    jb(a: number, b: number): any;
    private gx;
    get hj(): number;
    set hj(a: number);
    private gy;
    get hk(): number;
    set hk(a: number);
    oi(): void;
    oh(): void;
    flush(): void;
    nr(a: boolean, b: boolean, c: boolean): void;
    gg(): boolean;
    private sb;
    private az;
    protected q1(a: DependencyObject, b: (arg1: boolean) => void): void;
    protected rj(a: DependencyObject): void;
    ni(): void;
    e4: boolean;
    e5: boolean;
    e2: boolean;
    o8(): void;
    private d6;
    get fh(): boolean;
    m9(): void;
    fn(): boolean;
    private iz;
    i4(): number;
    dj(): FontInfo;
    di(): FontInfo;
    rm(): void;
    protected ep: boolean;
    vn: Brush;
    vm: Brush;
    h4: number;
    e8: boolean;
    seriesDataUpdated: (sender: any, e: EventArgs) => void;
    qr(): void;
    ob(): void;
    oc(): void;
    private od;
    oa(a: Point): void;
    private go;
    attachDataLegend(a: IDataLegend): void;
    detachDataLegend(a: IDataLegend): void;
    get isDetached(): boolean;
    dw: () => void;
    getDataLegendSeries(): IDataLegendSeries[];
    m6(a: Rect): void;
    wi(a: Rect): Rect;
    protected gr: List$1<CaptureImageSettings>;
    nb(a: CaptureImageSettings): void;
    private nc;
    protected js(a: CaptureImageSettings, b: (arg1: string, arg2: any) => void): string;
    imageCaptured: (sender: any, args: ImageCapturedEventArgs) => void;
    protected ql(a: CaptureImageSettings, b: string, c?: any): void;
    static $$p: string[];
}
/**
 * @hidden
 */
export declare abstract class SeriesViewerView extends Base implements ISchedulableRender {
    static $t: Type;
    constructor(a: SeriesViewer);
    l(): IExecutionContext;
    co(): void;
    p: SeriesViewer;
    c4(): void;
    e(): Series;
    private cn;
    a: CanvasRenderScheduler;
    n: IOverviewPlusDetailPane;
    private dn;
    private dm;
    em(): void;
    private ct;
    private cs;
    o: OverviewPlusDetailViewportHost;
    cb(a: number, b: number, c: RenderSurface): void;
    d5(): void;
    cd(): void;
    d7(): void;
    ck(): void;
    cc(): void;
    ce(): void;
    dy(a: Series): void;
    dc(): void;
    private er;
    aq(a: Series): boolean;
    protected g: SeriesCollection;
    protected b: AxisCollection;
    private ai;
    get au(): boolean;
    set au(a: boolean);
    bp(a: Series): void;
    dt(a: RenderingContext): void;
    bx(): void;
    bt(): void;
    cf(): void;
    ca(): void;
    dr(): void;
    protected fi: Rectangle;
    protected ff: Path;
    d8(): void;
    eg(a: Rect): void;
    bw(): void;
    df(): void;
    eo(a: number, b: number, c: number, d: number): void;
    protected fe: Line;
    protected fd: Line;
    ed(): void;
    cl(): void;
    eh(a: number, b: number, c: number, d: number): void;
    d9(): void;
    cg(): void;
    cj(): void;
    private e6;
    private e7;
    en(a: Rect, b: Rect): void;
    ec(): void;
    ep(a: Rect): void;
    dw(a: Axis): void;
    dx(a: Axis): void;
    bo(a: Axis): void;
    bl(a: Axis): void;
    private h;
    i(): SeriesViewerComponentsFromView;
    static aw(a: Series): List$1<Series>;
    d2(): void;
    j: SeriesViewerViewManager;
    protected w: RenderingContext;
    z: RenderingContext;
    y: RenderingContext;
    x: RenderingContext;
    an: boolean;
    ao: boolean;
    bi: any;
    c0(a: any): void;
    private al;
    protected cy(a: Point, b: boolean): void;
    protected cz(a: Point, b: boolean): void;
    protected c3(a: Point): void;
    protected cx(a: Point, b: boolean, c: boolean): void;
    du(a: RenderingContext): void;
    protected get_ap(): boolean;
    get ap(): boolean;
    k: EventProxy;
    ef(): void;
    a9: number;
    f(a: Point, b: boolean, c: DataContext, d: boolean): {
        ret: Series;
        p2: DataContext;
    };
    bd(): number;
    bc(): number;
    a8: number;
    a7: number;
    private e9;
    private aj;
    cu(): void;
    c1(a: number, b: number): void;
    private fg;
    private fh;
    b6(a: Rectangle): void;
    b9(a: Rectangle): void;
    b8(): void;
    d3(): void;
    private a1;
    private az;
    private a0;
    private ay;
    private ak;
    private aa;
    private b2;
    private ek;
    v(): FontInfo;
    u(): FontInfo;
    private e5;
    private e4;
    private bf;
    private a2;
    private be;
    fm(): Thickness;
    fl(): Thickness;
    protected dv(a: Rect): void;
    cq(): void;
    private fa;
    protected d0(): void;
    isValid(): boolean;
    preRender(): void;
    protected ds(): void;
    protected ab: boolean;
    protected d1(): void;
    c2(): void;
    cw(): void;
    fb(): Rect;
    e8(): Point;
    private d6;
    ee(): void;
    dp(): void;
    protected as(a: Point): boolean;
    c8(a: Point, b: boolean, c: boolean): void;
    protected c7(a: Point): void;
    protected c6(a: Point): void;
    protected c9(a: Point): void;
    d4(): void;
    get ez(): ModifierKeys;
    eq(a: Rect): void;
    cr(a: boolean): void;
    bk(a: boolean): void;
    protected el(): void;
    private af;
    get isDirty(): boolean;
    set isDirty(a: boolean);
    undirty(a: boolean): void;
    get index(): number;
    postRender(): void;
    b7(): void;
    protected ae: boolean;
    ch(): void;
    ea(): void;
    bv(a: boolean): void;
    bm(a: any): void;
    ei(a: number): void;
    ej(a: number): void;
    bn(a: any): void;
    dz(a: any): void;
    da(a: Brush): void;
    bu(a: Point): void;
    av: boolean;
    m(a: boolean): InteractionState;
    c5(): void;
    private et;
    private es;
    bb(a: TextBlock, b: FontInfo): number;
    ba(a: string, b: FontInfo): number;
    dj(): void;
    private eu;
    di(): void;
    de(): void;
    c(a: Axis): AxisTitlePosition;
    d(a: Axis): AxisTitlePosition;
    dk(): void;
    dl(): void;
    t(): FontInfo;
    e3(): Brush;
    q(): FontInfo;
    e0(): Brush;
    s(): FontInfo;
    r(): FontInfo;
    e2(): Brush;
    e1(): Brush;
    get a4(): number;
    get a5(): number;
    get a6(): number;
    get a3(): number;
    get ew(): TextBlock;
    get ev(): TextBlock;
    fc(): Rect;
    fk(): Thickness;
    fj(): Thickness;
    private ad;
    private ac;
    dd(a: any, b: any): void;
    dh(a: any, b: any): void;
    ey(): HorizontalAlignment;
    ex(): HorizontalAlignment;
    private ag;
    bq(): void;
    am(): boolean;
    b5(): void;
    cp(): void;
    at(a: Point): boolean;
    dq(): void;
    private ax;
    b3(a: Dictionary$2<any, ITileZoomTile>, b: List$1<ITileZoomTile>, c: number): void;
    bh(a: Rect, b: ITileZoomTile, c: number): any;
    b0(): void;
    b1(a: ITileZoomTile): void;
    cm(): void;
    ar: boolean;
    private bg;
    by(): void;
    br(): void;
    bz(a: number): void;
    bs(): void;
    private ah;
    ci(): void;
    eb(): void;
    dg(): void;
    cv(): void;
    db(): void;
    b4(a: any): void;
    bj(a: number, b: number, c: number): any;
}
/**
 * @hidden
 */
export declare class OverviewPlusDetailViewportHost extends Base implements IProvidesViewport {
    static $t: Type;
    constructor(a: SeriesViewerView);
    a: SeriesViewerView;
    getViewInfo(a: Rect, b: Rect): {
        p0: Rect;
        p1: Rect;
    };
    getEffectiveViewport(): Rect;
    getMainContentViewport(): Rect;
}
/**
 * @hidden
 */
export declare class LegendTemplates extends Base {
    static $t: Type;
    private static readonly z;
    private static readonly ae;
    private static readonly ad;
    private static readonly ah;
    private static readonly ab;
    private static readonly y;
    private static readonly aa;
    private static readonly ac;
    static af(a: Series): DataTemplate;
    static a(a: DataTemplateRenderInfo): RenderingContext;
    static v(a: DataContext): void;
    private static b;
    private static c;
    static u(a: DataTemplateRenderInfo, b: number, c: Brush, d: Brush, e: number, f: number, g: number, h: number): void;
    static s(a: DataTemplateRenderInfo): void;
    static r(a: DataTemplateRenderInfo, b: number, c: number): void;
    static t(a: DataTemplateRenderInfo, b?: number): void;
    static j(a: DataTemplateRenderInfo): void;
    static n(a: DataTemplateRenderInfo): void;
    static o(a: DataTemplateRenderInfo): void;
    static q(a: DataTemplateRenderInfo): void;
    static p(a: DataTemplateRenderInfo): void;
    static i(a: DataTemplateRenderInfo): void;
    static l(a: DataTemplateRenderInfo): void;
    static m(a: DataTemplateRenderInfo): void;
    static k(a: DataTemplateRenderInfo): void;
    static g(a: DataTemplateRenderInfo): void;
    private static readonly w;
    private static readonly x;
    static resolveLegendItemTemplate(a: StandardLegendItems): DataTemplate;
    static e(a: DataTemplateRenderInfo): void;
    static f(a: DataTemplateMeasureInfo): void;
    static d(a: DataTemplateMeasureInfo): void;
    static h(a: DataTemplateMeasureInfo): void;
}
/**
 * @hidden
 */
export declare class SeriesViewerViewManager extends Base {
    static $t: Type;
    ae: DomRenderer;
    protected af: DomWrapper;
    protected aj: DomWrapper;
    protected ai: DomWrapper;
    protected ag: DomWrapper;
    ak: DomWrapper;
    t: RenderingContext;
    w: RenderingContext;
    v: RenderingContext;
    u: RenderingContext;
    x: RenderingContext;
    f: EventProxy;
    private j;
    constructor(a: SeriesViewerView);
    protected ah: DomWrapper;
    bj(): void;
    bg(a: any): void;
    static by(a: DomRenderer, b: () => void): void;
    private bi;
    ba(): void;
    g(): IOverviewPlusDetailPane;
    bm(): void;
    bn(): void;
    b3(): Brush;
    private ab;
    private aa;
    private ac;
    az(a: number, b: number, c: number): void;
    b8(): Point;
    y(): boolean;
    bc(a: boolean): void;
    a8(a: BrushCollection, b: BrushCollection, c: Brush, d: FontInfo, e: Brush): {
        p0: BrushCollection;
        p1: BrushCollection;
        p2: Brush;
        p3: FontInfo;
        p4: Brush;
    };
    e(): DefaultPaletteInfo;
    a7(a: number, b: number[], c: Brush, d: Brush, e: number, f: boolean): {
        p0: number;
        p1: number[];
        p2: Brush;
        p3: Brush;
        p4: number;
        p5: boolean;
    };
    ay(): void;
    bu(x_: number): void;
    private ad;
    bv(y_: number): void;
    au(a: any): void;
    a9(): void;
    bo(): void;
    av(a: any): void;
    bk(a: any): void;
    bd(): void;
    private l;
    p(): FontInfo;
    private ca;
    ce(): Thickness;
    private aq;
    as(): string;
    private ap;
    ar(): string;
    private b9;
    cd(): Thickness;
    private b0;
    b5(): Brush;
    private bz;
    b4(): Brush;
    private k;
    o(): FontInfo;
    private a;
    c(): AxisTitlePosition;
    private b;
    d(): AxisTitlePosition;
    private n;
    r(): FontInfo;
    private b2;
    b7(): Brush;
    private m;
    q(): FontInfo;
    private b1;
    b6(): Brush;
    private cb;
    cf(): Thickness;
    private cc;
    cg(): Thickness;
    bp(): void;
    private bx;
    private br;
    private bq;
    private bs;
    private bt;
    a6(a: number, b: number): void;
    private h;
    i(): PointerTooltipStyle;
    bb(a: boolean): void;
    private z;
    an(a: Rect, b: ITileZoomTile, c: number): any;
    a3(a: ITileZoomTile): void;
    a2(): void;
    bl(a: List$1<ITileZoomTile>): void;
    private al;
    a0(): void;
    aw(): void;
    private am;
    a1(a: number): void;
    ax(): void;
    private s;
    be(): void;
    bw(a: boolean): void;
    a4(): void;
    a5(): void;
    bh(): void;
    bf(): void;
    ao(a: number, b: number, c: number): any;
    at(a: number, b: number, c: number, d: string, e?: (arg1: string, arg2: any) => void): string;
}
/**
 * @hidden
 */
export declare class AutoRangeCalculator extends Base {
    static $t: Type;
    static a(a: NumericAxisBase, b: number, c: number, d: boolean, e: number, f: number, g: number): {
        p5: number;
        p6: number;
    };
}
/**
 * @hidden
 */
export interface IAxisAnnotationManager {
    owner: Axis;
    onAutoAnnotionsChanged(a: Axis, b: AxisAnnotationCollection, c: NotifyCollectionChangedEventArgs): void;
    onAutoAnnotionsReset(a: Axis, b: AxisAnnotationCollection, c: EventArgs): void;
    onAnnotionsChanged(a: Axis, b: AxisAnnotationCollection, c: NotifyCollectionChangedEventArgs): void;
    onAnnotionsReset(a: Axis, b: AxisAnnotationCollection, c: EventArgs): void;
    onAddAnnotations(a: Axis): void;
    arrangeAnnotations(a: Axis, b: AxisLabelPanelBaseView, c: List$1<FrameworkElement>, d: List$1<Rect>, e: boolean, f: number, g: number, h: number, i: number, j: number): void;
}
/**
 * @hidden
 */
export declare let IAxisAnnotationManager_$type: Type;
/**
 * @hidden
 */
export declare class AxisLabelSettings extends Base implements INotifyPropertyChanged {
    static $t: Type;
    constructor();
    private ab;
    get textStyle(): string;
    set textStyle(a: string);
    private ay;
    get textColor(): Brush;
    set textColor(a: Brush);
    get location(): AxisLabelsLocation;
    set location(a: AxisLabelsLocation);
    private b;
    get visibility(): Visibility;
    set visibility(a: Visibility);
    private a3;
    get showFirstLabel(): boolean;
    set showFirstLabel(a: boolean);
    private i;
    c: AxisLabelsLocation;
    a: Axis;
    registerAxis(a: Axis): void;
    unregisterAxis(a: Axis): void;
    get angle(): number;
    set angle(a: number);
    private n;
    get extent(): number;
    set extent(a: number);
    private p;
    set margin(a: number);
    get leftMargin(): number;
    set leftMargin(a: number);
    private q;
    get rightMargin(): number;
    set rightMargin(a: number);
    private r;
    get topMargin(): number;
    set topMargin(a: number);
    private s;
    get bottomMargin(): number;
    set bottomMargin(a: number);
    private o;
    private av;
    get horizontalAlignment(): HorizontalAlignment;
    set horizontalAlignment(a: HorizontalAlignment);
    private a0;
    get verticalAlignment(): VerticalAlignment;
    set verticalAlignment(a: VerticalAlignment);
    propertyChanged: (sender: any, e: PropertyChangedEventArgs) => void;
    propertyUpdated: (sender: any, e: PropertyUpdatedEventArgs) => void;
    as(a: string, b: any, c: any): void;
    protected ar(a: any, b: string, c: any, d: any): void;
    k(): boolean;
    l(): boolean;
    static readonly extentPropertyDefault: number;
    get j(): boolean;
    private f;
    get g(): FontInfo;
    set g(a: FontInfo);
    h(a: DomRenderer): FontInfo;
}
/**
 * @hidden
 */
export declare class TitleSettings extends AxisLabelSettings {
    static $t: Type;
    constructor();
    private a5;
    get position(): AxisTitlePosition;
    set position(a: AxisTitlePosition);
    protected ar(a: any, b: string, c: any, d: any): void;
}
/**
 * @hidden
 */
export declare abstract class Axis extends Control implements INotifyPropertyChanged {
    static $t: Type;
    a4(): AxisView;
    a5: AxisView;
    hv(a: AxisView): void;
    abstract ag(): number[];
    hh(): void;
    private bt;
    get bu(): SRProvider;
    private a9;
    get ba(): IAxisVisualDataManager;
    ek(): number;
    f4(): any;
    f3(): any;
    protected get_cb(): boolean;
    get cb(): boolean;
    protected get_cj(): boolean;
    get cj(): boolean;
    protected get_b9(): boolean;
    get b9(): boolean;
    protected get_cm(): boolean;
    get cm(): boolean;
    protected get_cp(): boolean;
    get cp(): boolean;
    protected get_cn(): boolean;
    get cn(): boolean;
    d5(a: Point): number;
    protected get_ce(): boolean;
    get ce(): boolean;
    protected get_ck(): boolean;
    get ck(): boolean;
    protected get_cl(): boolean;
    get cl(): boolean;
    protected get_cc(): boolean;
    get cc(): boolean;
    protected get_cd(): boolean;
    get cd(): boolean;
    ak(): Axis;
    constructor();
    private a7;
    get a8(): IAxisAnnotationManager;
    get ca(): boolean;
    private hf;
    private hg;
    private hd;
    private he;
    provideRenderer(a: DomRenderer): void;
    au: (item: any) => string;
    hs(a: Rect, b: Rect): void;
    abstract av(): AxisLabelPanelBase;
    ac(): void;
    iu: Canvas;
    get bo(): IFastItemsSourceProvider;
    set bo(a: IFastItemsSourceProvider);
    private bn;
    get bi(): SeriesViewer;
    set bi(a: SeriesViewer);
    private bh;
    get bg(): XamDataChart;
    set bg(a: XamDataChart);
    readonly bs: (sender: any, e: RectChangedEventArgs) => void;
    private by;
    get c6(): boolean;
    set c6(a: boolean);
    private dm;
    get e8(): number;
    set e8(a: number);
    private dg;
    get dy(): number;
    set dy(a: number);
    private dt;
    get fe(): number;
    set fe(a: number);
    private dq;
    get fb(): number;
    set fb(a: number);
    private as;
    get at(): AxisExtentType;
    set at(a: AxisExtentType);
    private dl;
    get e7(): number;
    set e7(a: number);
    dx: number;
    private ds;
    get fd(): number;
    set fd(a: number);
    private dp;
    get fa(): number;
    set fa(a: number);
    private bk;
    private bj;
    get bm(): FontInfo;
    set bm(a: FontInfo);
    private f5;
    get gz(): string;
    set gz(a: string);
    private dn;
    get e9(): number;
    set e9(a: number);
    dz: number;
    private du;
    get ff(): number;
    set ff(a: number);
    private dr;
    get fc(): number;
    set fc(a: number);
    private fq;
    get fv(): number;
    set fv(a: number);
    private fp;
    get fu(): number;
    set fu(a: number);
    private fo;
    get ft(): number;
    set ft(a: number);
    fr: number;
    private kn;
    get kq(): VerticalAlignment;
    set kq(a: VerticalAlignment);
    private dw;
    get fh(): number;
    set fh(a: number);
    private dv;
    get fg(): number;
    set fg(a: number);
    ik(): void;
    private h8;
    private h9;
    iv: TextBlock;
    g8: string;
    j2: Brush;
    jy: Brush;
    fi: number;
    j6: DoubleCollection;
    j1: Brush;
    jz: Brush;
    jw: Brush;
    et: number;
    j4: DoubleCollection;
    j0: Brush;
    jx: Brush;
    ew: number;
    j5: DoubleCollection;
    j3: Brush;
    fk: number;
    j7: DoubleCollection;
    fj: number;
    d0: number;
    private io;
    cf: boolean;
    ch: boolean;
    ci: boolean;
    cu: boolean;
    private bw;
    private dh;
    get b4(): boolean;
    get b7(): boolean;
    ij(a: number): void;
    id(): void;
    eh(): number;
    ey(): number;
    cv: boolean;
    cw: boolean;
    cx: boolean;
    bz: boolean;
    c5: boolean;
    get c4(): boolean;
    set c4(a: boolean);
    static readonly js: DependencyProperty;
    fs: number;
    b1: boolean;
    az: AxisLabelSettings;
    d7(): number;
    ju(): HorizontalAlignment;
    ko(): VerticalAlignment;
    jv(): HorizontalAlignment;
    kp(): VerticalAlignment;
    d9(): number;
    eb(): number;
    ea(): number;
    d8(): number;
    ee(): number;
    eg(): number;
    ef(): number;
    ed(): number;
    a0(): AxisLabelsLocation;
    a1(): AxisLabelsLocation;
    aj: Axis;
    fx: any;
    rangeChanged: (sender: any, e: AxisRangeChangedEventArgs) => void;
    protected h6(a: AxisRangeChangedEventArgs): void;
    bf: TitleSettings;
    ec(): number;
    d6(): number;
    get an(): AxisAnnotationCollection;
    private al;
    get ao(): AxisAnnotationCollection;
    private am;
    private j9;
    get kh(): Rect;
    set kh(a: Rect);
    kg: Rect;
    ip(): void;
    c8(a: Rect, b: Rect, c: AxisView): boolean;
    co(): boolean;
    dd: List$1<any>;
    de: List$1<LabelPosition>;
    aw: AxisLabelPanelBase;
    protected is(a: Rect, b: Rect): void;
    private bx;
    get cq(): boolean;
    set cq(a: boolean);
    protected ke(): Rect;
    ka: Rect;
    protected it(a: Rect, b: Rect): void;
    h7(): void;
    a6: ContentInfo;
    fn: DomRenderer;
    ai: BindingFormatter;
    protected hz(a: any, b: string, c: any, d: any): void;
    hx(): void;
    hy(): void;
    private _coercionMethods;
    get coercionMethods(): any;
    set coercionMethods(a: any);
    private bv;
    protected get_expectFunctions(): boolean;
    protected set_expectFunctions(a: boolean): void;
    get expectFunctions(): boolean;
    set expectFunctions(a: boolean);
    cy: boolean;
    private ig;
    c7: boolean;
    protected hu(a: GeometryCollection, b: number, c: number, d: Rect): void;
    protected ht(a: GeometryCollection, b: number, c: Rect, d: PathRenderingInfo, e: boolean): void;
    protected ir(a: GeometryCollection, b: number, c: number, d: Rect): void;
    protected iq(a: GeometryCollection, b: number, c: Rect, d: PathRenderingInfo, e: boolean): void;
    private cg;
    protected ii(a: number, b: number, c: Rect, d: Rect, e: Rect, f: number, g: number): {
        p0: number;
        p1: number;
    };
    d1(a: number, b: number, c: number, d: PathRenderingInfo): number;
    hk(a: GeometryCollection): void;
    protected hj(): void;
    ia(): void;
    ib(a: boolean): void;
    renderRequested: (sender: any, e: RenderRequestedEventArgs) => void;
    bc: LabelFontHeuristics;
    static ev: number;
    e1(): number;
    e5(): number;
    e3(): number;
    e4(): number;
    e2(): number;
    ez(): number;
    d3(a: number, b: boolean, c: Rect, d: Rect, e: Rect): number;
    private es;
    private ej;
    cz(a: number, b: number, c: Rect, d: Rect, e: Rect): boolean;
    protected ei(a: number, b: Rect, c: Rect, d: Rect): number;
    e0(): number;
    protected get c0(): boolean;
    cr: boolean;
    hn(a: boolean): void;
    private dj;
    private b2;
    ie(): void;
    protected b6(): boolean;
    d2(a: number, b: ScalerParams): number;
    protected ih(): void;
    private dk;
    bb(): LabelFontHeuristics;
    bl(): FontInfo;
    private ho;
    cs: boolean;
    c1(): boolean;
    c2(a: boolean): boolean;
    c3(): boolean;
    hl(): void;
    protected ic(a: boolean): void;
    im(): void;
    propertyChanged: (sender: any, e: PropertyChangedEventArgs) => void;
    propertyUpdated: (sender: any, e: PropertyUpdatedEventArgs) => void;
    protected h5(a: string, b: any, c: any): void;
    df: List$1<Series>;
    ct(a: Series): boolean;
    b0(a: Series): boolean;
    f2: any;
    gi: string;
    ah: any[];
    fz(a: any, b: string): any;
    private da;
    protected gu(a: string): string;
    private c9;
    protected f0(a: any, b: string, c: string): any;
    f1(a: any): any;
    gf(a: number): string;
    ex(): number;
    el(a: number, b: ScalerParams): number;
    em(a: number, b: ScalerParams, c: CategoryMode): number;
    kd(a: Rect): Rect;
    kc(): Rect;
    kb(): Rect;
    protected kf(a: Rect, b: Rect): Rect;
    en(a: number, b: Rect, c: Rect): number;
    hq(a: IList$1<number>, b: number, c: number, d: ScalerParams): void;
    hp(a: IList$1<number[]>, b: IList$1<number>, c: number, d: number, e: ScalerParams): void;
    eo(a: number, b: ScalerParams): number;
    ep(a: number, b: ScalerParams, c: CategoryMode): number;
    eq(a: number, b: Rect, c: Rect): number;
    hr(a: IList$1<number>, b: number, c: number, d: ScalerParams): void;
    e6(a: number): number;
    abstract get a2(): AxisOrientation;
    km: Size;
    hw(a: Size): void;
    il(): void;
    ap: AxisComponentsForView;
    aq(): AxisComponentsForView;
    d4: number;
    private di;
    get eu(): number;
    set eu(a: number);
    b8(): boolean;
    er(): number;
    protected hi(): void;
    hm(a: AxisRangeChangedEventArgs): void;
    br: Pool$1<TextBlock>;
    bq: Pool$1<TextBlock>;
    bp: Pool$1<Rectangle>;
    get ki(): Path;
    get kj(): Path;
    get kl(): Path;
    get kk(): Path;
    be(): SyncSettings;
    ar(): AxisComponentsFromView;
    private ax;
    get ay(): AxisLabelSettings;
    h0(a: RenderingContext, b: RenderingContext): void;
    b5(): boolean;
    fy(): any;
    private _db;
    db(): IEnumerable$1<Series>;
    dc(): IEnumerable$1<Series>;
    h1(a: string): void;
    h4(a: any): void;
    h3(a: any): void;
    fm: CultureInfo;
    j8(a: number, b: Rect, c: Rect, d: Rect, e: Rect): Geometry;
    static $$p: string[];
}
/**
 * @hidden
 */
export declare class AxisCollection extends ObservableCollection$1<Axis> {
    static $t: Type;
    constructor();
    collectionResetting: (sender: any, e: EventArgs) => void;
    protected p(): void;
}
/**
 * @hidden
 */
export declare class AxisLabelManager extends Base {
    static $t: Type;
    e: List$1<any>;
    f: List$1<LabelPosition>;
    b: AxisLabelPanelBase;
    a: Axis;
    c: (arg1: number) => void;
    constructor();
    n(a: Rect, b: Rect): void;
    i(a: any, b: LabelPosition): void;
    t(): void;
    static j(a: FrameworkElement, b: AxisLabelSettings): void;
    private static k;
    private static l;
    static m(a: FrameworkElement, b: TitleSettings): void;
    h(a: FrameworkElement): void;
    r(a: number): void;
    o(a: number): void;
    u(a: number): FrameworkElement;
    s(a: number): void;
    get d(): boolean;
    q(): void;
    p(): void;
    g(): void;
}
/**
 * @hidden
 */
export declare abstract class AxisLabelPanelBase extends Panel {
    static $t: Type;
    ae(): AxisLabelPanelBaseView;
    ch(a: AxisLabelPanelBaseView): void;
    af: AxisLabelPanelBaseView;
    cx: Rect;
    b8(): void;
    cp(): void;
    co(): void;
    constructor();
    bw: number;
    ad: Axis;
    private ak;
    get az(): boolean;
    set az(a: boolean);
    private a3;
    get a9(): List$1<any>;
    set a9(a: List$1<any>);
    ba: List$1<LabelPosition>;
    c4: Rect;
    private cw;
    get c5(): Rect;
    set c5(a: Rect);
    private cv;
    get c1(): Rect;
    set c1(a: Rect);
    c2: Rect;
    private bc;
    get bg(): number;
    set bg(a: number);
    bx: () => boolean;
    bb: List$1<FrameworkElement>;
    a8: List$1<Rect>;
    ag: AxisLabelSettings;
    bn(): number;
    ao: boolean;
    c3: Rect;
    cl(): void;
    ar: boolean;
    av: boolean;
    aw: boolean;
    ax: boolean;
    bz: any;
    al: boolean;
    protected an(a: List$1<Rect>, b: List$1<boolean>): boolean;
    protected by(a: number, b: List$1<Rect>, c: List$1<boolean>): {
        ret: number;
        p1?: List$1<Rect>;
    };
    a5(): List$1<Rect>;
    b6(): void;
    b2(a: Size): void;
    get ap(): boolean;
    bl(): number;
    bq(): number;
    at(a: number, b: Rect): boolean;
    bk(a: any): number;
    bv(a: any): number;
    bm(a: any): number;
    bj(a: any): number;
    aq(): boolean;
    protected ct(a: Rect, b: Rect): void;
    protected cd(a: Rect, b: Rect): void;
    a7(): List$1<Rect>;
    a6(a: List$1<Rect>): List$1<Rect>;
    protected cy(a: number, b: Rect, c: Thickness): Rect;
    protected as(a: List$1<Rect>, b: List$1<number>, c: Thickness): boolean;
    protected a4(a: List$1<Rect>): List$1<number>;
    bp(a: number, b: Size): number;
    bo(a: number, b: Size): number;
    bt(): number;
    br(): number;
    bs(): number;
    bu(): number;
    c6(a: Size): Size;
    protected get am(): boolean;
    c0(): Rect;
    protected b5(a: Size): void;
    protected b4(a: Size): void;
    protected b9(): void;
    protected a2(): IEnumerable$1<number>;
    get ah(): AxisLabelsLocation;
    cs(a: GeometryCollection, b: number, c: number, d: number, e: Rect, f: PathRenderingInfo): void;
    cc(a: GeometryCollection, b: number, c: number, d: number, e: Rect, f: PathRenderingInfo): void;
    cm(a: FrameworkElement, b: number): void;
    protected get_au(): boolean;
    get au(): boolean;
    ac(a: Rect, b: number): Point[];
    cz(a: Rect, b: number): Rect;
    cn(a: FrameworkElement): void;
    cb(a: FrameworkElement, b: number): void;
    c8(a: Size): Size;
    static readonly cu: DependencyProperty;
    get bh(): number;
    set bh(a: number);
    bd: number;
    aj(a: TitleSettings): AxisTitlePosition;
    ai(): AxisLabelsLocation;
    ay(a: AxisLabelsLocation): boolean;
    private _a0;
    a0(): IEnumerable$1<any>;
    b1(a: number, b: TextBlock, c: number, d: number, e: number): string;
    b7(a: any): void;
    cg(a: FrameworkElement): void;
    private _a1;
    a1(): IEnumerable$1<any>;
    protected be: number;
    protected bf: number;
    ca(): void;
    cr(): void;
    ce(): void;
    bi(a: Rect): number;
    c7: Size;
    ci(): void;
    cq(): void;
    cf(): void;
    cj(a: RenderingContext): void;
    b3(): void;
    ck(): void;
}
/**
 * @hidden
 */
export declare abstract class CategoryAxisBase extends Axis implements ICategoryScaler {
    static $t: Type;
    a4(): AxisView;
    ag(): number[];
    protected get_cd(): boolean;
    hv(a: AxisView): void;
    kr: CategoryAxisBaseView;
    protected ei(a: number, b: Rect, c: Rect, d: Rect): number;
    constructor();
    c8(a: Rect, b: Rect, c: AxisView): boolean;
    l6(): void;
    l5(): void;
    k2: List$1<number>;
    protected get_cb(): boolean;
    mj(a: Point, b: boolean, c: number): Rect;
    mk(a: Point, b: boolean, c: number, d: boolean): Rect;
    kv: IFastItemsSource;
    private ku;
    get itemsSource(): IEnumerable;
    set itemsSource(a: IEnumerable);
    static readonly me: DependencyProperty;
    private lh;
    lj: number;
    get lk(): number;
    set lk(a: number);
    get categoryMode(): CategoryMode;
    set categoryMode(a: CategoryMode);
    private ks;
    k5: number;
    protected lf(a: Rect, b: Rect, c: Rect): number;
    lc: number;
    k4: number;
    ld: number;
    le: number;
    kz: boolean;
    get ll(): number;
    set ll(a: number);
    private li;
    eo(a: number, b: ScalerParams): number;
    getUnscaledValue3(a: number, b: Rect, c: Rect, d: CategoryMode): number;
    getCategorySize(a: Rect, b: Rect, c: Rect): number;
    k8(a: Rect, b: Rect, c: Rect): number;
    getGroupCenter(a: number, b: Rect, c: Rect, d: Rect): number;
    lg(a: number): number;
    private _k1;
    private k1;
    private kx;
    ky(a: SeriesViewer): boolean;
    private _k0;
    private k0;
    private kw;
    ma(a: boolean): void;
    protected lm(): number;
    protected hz(a: any, b: string, c: any, d: any): void;
    protected ly(): void;
    l0(a: any, b: FastItemsSourceEventArgs): void;
    protected l7(a: FastItemsSourceEventArgs): void;
    private mb;
    ct(a: Series): boolean;
    b0(a: Series): boolean;
    private l8;
    lx(): void;
    l9(): void;
    lz(a: NotifyCollectionChangedEventArgs): void;
    l4(a: number, b: any, c: any): void;
    l1(): void;
    l2(a: number, b: any): void;
    l3(a: number, b: any): void;
    k9(a: Rect, b: Rect, c: Rect, d: number): number;
    la(a: Rect, b: Rect, c: Rect, d: number, e: number): number;
    getSeriesOffset(a: Rect, b: Rect, c: Rect, d: number, e: number): number;
    get isVertical(): boolean;
    j$d(a: number, b: ScalerParams): number;
    j$c(a: number, b: ScalerParams): number;
    j$e(a: IList$1<number[]>, b: IList$1<number>, c: number, d: number, e: ScalerParams): void;
    j$f(a: IList$1<number>, b: number, c: number, d: ScalerParams): void;
    j$g(a: IList$1<number>, b: number, c: number, d: ScalerParams): void;
    get j$b(): boolean;
    j$a(): number[];
    static $$p: string[];
}
/**
 * @hidden
 */
export declare abstract class HorizontalAxisLabelPanelBase extends AxisLabelPanelBase {
    static $t: Type;
    ae(): AxisLabelPanelBaseView;
    ch(a: AxisLabelPanelBaseView): void;
    c9: HorizontalAxisLabelPanelBaseView;
    dl: number;
    di: number;
    dk: number;
    dj: number;
    b6(): void;
    db(): boolean;
    dc(): boolean;
    aq(): boolean;
    a5(): List$1<Rect>;
    dn(a: List$1<Rect>, b: List$1<boolean>, c: number): void;
    private dm;
    private dp;
    protected dq(a: List$1<Rect>, b: List$1<boolean>): void;
    protected dr(): void;
    protected get_au(): boolean;
    cm(a: FrameworkElement, b: number): void;
    protected dd(): boolean;
    protected da(): boolean;
    protected by(a: number, b: List$1<Rect>, c: List$1<boolean>): {
        ret: number;
        p1?: List$1<Rect>;
    };
    c0(): Rect;
    dh(): number;
    de(): number;
    dg(): number;
    df(): number;
    protected b9(): void;
    a6(a: List$1<Rect>): List$1<Rect>;
}
/**
 * @hidden
 */
export declare class HorizontalAxisLabelPanel extends HorizontalAxisLabelPanelBase {
    static $t: Type;
    ai(): AxisLabelsLocation;
    ay(a: AxisLabelsLocation): boolean;
}
/**
 * @hidden
 */
export declare abstract class NumericAxisBase extends Axis {
    static $t: Type;
    a4(): AxisView;
    ag(): number[];
    hv(a: AxisView): void;
    d2(a: number, b: ScalerParams): number;
    k1: NumericAxisBaseView;
    protected get_cj(): boolean;
    constructor();
    get ky(): AxisRangeBufferMode;
    set ky(a: AxisRangeBufferMode);
    private kw;
    get kz(): AxisRangeBufferMode;
    set kz(a: AxisRangeBufferMode);
    static readonly nw: DependencyProperty;
    mc: number;
    get l4(): number;
    set l4(a: number);
    private lw;
    ma: number;
    f4(): any;
    get l7(): number;
    set l7(a: number);
    private lz;
    mb: number;
    get l3(): number;
    set l3(a: number);
    private lv;
    f3(): any;
    l9: number;
    private ly;
    get l6(): number;
    set l6(a: number);
    l8: number;
    private lu;
    get l2(): number;
    set l2(a: number);
    ex(): number;
    private mh;
    get mk(): number;
    set mk(a: number);
    private mg;
    get mj(): number;
    set mj(a: number);
    private mi;
    get ml(): number;
    set ml(a: number);
    mo: number;
    private le;
    get li(): boolean;
    set li(a: boolean);
    ls: boolean;
    md: number;
    private lx;
    get l5(): number;
    set l5(a: number);
    me: number;
    lo: boolean;
    private lc;
    get lg(): boolean;
    set lg(a: boolean);
    lj: boolean;
    private ld;
    get lh(): boolean;
    set lh(a: boolean);
    get lp(): boolean;
    mm: number;
    mn: number;
    k4: NumericAxisRenderer;
    protected lq: boolean;
    protected lr: boolean;
    protected ic(a: boolean): void;
    protected it(a: Rect, b: Rect): void;
    h4(a: any): void;
    h3(a: any): void;
    ks: BindingFormatter;
    protected hz(a: any, b: string, c: any, d: any): void;
    protected ni(): void;
    ku: AxisRange;
    kv(): AxisRange;
    l1: number;
    l0: number;
    private lt;
    private k0;
    ng(a: NumericAxisBase, b: number, c: number, d: boolean, e: number, f: number, g: number): {
        p5: number;
        p6: number;
    };
    private kx;
    c3(): boolean;
    hl(): void;
    nj(a: AxisRangeChangedEventArgs): void;
    ct(a: Series): boolean;
    b0(a: Series): boolean;
    k3(a: AxisLabelManager): NumericAxisRenderer;
    k2(): NumericAxisRenderer;
    kt: (item: any) => string;
    mq: string;
    kr: any[];
    ln: boolean;
    k6(): NumericAxisRenderingParameters;
    nh(): void;
    k7(): NumericScaler;
    mp(): number;
    k5(a: Rect, b: Rect, c: Rect, d: Rect): NumericAxisRenderingParameters;
    mf(a: number): number;
    lk(): boolean;
    get lm(): boolean;
    get ll(): boolean;
    private nk;
    static readonly nz: DependencyProperty;
    get la(): TickmarkValues;
    set la(a: TickmarkValues);
    private k8;
    get k9(): TickmarkValues;
    set k9(a: TickmarkValues);
    private lb;
    get lf(): boolean;
    set lf(a: boolean);
    static $$p: string[];
}
/**
 * @hidden
 */
export declare abstract class NumericScaler extends DependencyObject {
    static $t: Type;
    static readonly ac: Rect;
    abstract t(a: NumericAxisBase, b: number, c: number, d: number, e: number): {
        p3: number;
        p4: number;
    };
    l: number;
    k: number;
    protected o: number;
    protected n: number;
    y(a: number): void;
    x(a: number): void;
    protected w(a: string, b: any, c: any): void;
    private z;
    protected m: number;
    abstract q(a: number, b: ScalerParams): number;
    abstract p(a: number, b: ScalerParams): number;
    j(a: IList$1<number>, b: number, c: number, d: ScalerParams): IList$1<number>;
    v(a: IList$1<number>, b: number, c: number, d: ScalerParams): void;
    u(a: IList$1<number[]>, b: IList$1<number>, c: number, d: number, e: ScalerParams): void;
    static $$p: string[];
}
/**
 * @hidden
 */
export declare class AxisRendererBase extends Base {
    static $t: Type;
    constructor(a: AxisLabelManager);
    u: () => void;
    o: (viewportRect: Rect, windowRect: Rect) => boolean;
    v: () => void;
    m: (p: AxisRenderingParametersBase, value: number) => number;
    l: (p: AxisRenderingParametersBase, geometry: GeometryCollection, startValue: number, endValue: number) => void;
    k: (p: AxisRenderingParametersBase, geometry: GeometryCollection, value: number) => void;
    q: (p: AxisRenderingParametersBase, value: number) => boolean;
    n: (p: AxisRenderingParametersBase, value: number) => boolean;
    j: (p: AxisRenderingParametersBase) => void;
    e: (p: AxisRenderingParametersBase) => void;
    p: (p: AxisRenderingParametersBase, position: number, isLastLabel: boolean) => boolean;
    h: (p: AxisRenderingParametersBase, value: number) => LabelPosition;
    t: (p: AxisRenderingParametersBase, value: number) => number;
    b: AxisLabelManager;
    g: (item: any, fromAbbreviator: boolean) => any;
    d: (viewportRect: Rect, windowRect: Rect, effectiveViewportRect: Rect, contentViewport: Rect) => AxisRenderingParametersBase;
    r: (p: AxisRenderingParametersBase, value: number, absoluteIndex: number, interval: number) => number;
    a: (p: AxisRenderingParametersBase, value: number, absolueIndex: number, interval: number) => number;
    f: (index: number, window: Rect, viewport: Rect, effectiveViewport: Rect) => number;
    i: (index: number) => number;
    c(a: boolean, b: Rect, c: Rect, d: Rect, e: Rect): AxisRenderingParametersBase;
    private aa;
    private ab;
    protected x(a: Rect, b: Rect): void;
    private z;
    private s;
    private y;
    w(a: AxisRenderingParametersBase, b: number, c: number, d: number): any;
}
/**
 * @hidden
 */
export declare class NumericAxisRenderer extends AxisRendererBase {
    static $t: Type;
    constructor(a: AxisLabelManager);
    w(a: AxisRenderingParametersBase, b: number, c: number, d: number): any;
    private ac;
    private ad;
    private ae;
}
/**
 * @hidden
 */
export declare class VerticalAxisLabelPanel extends AxisLabelPanelBase {
    static $t: Type;
    ae(): AxisLabelPanelBaseView;
    ch(a: AxisLabelPanelBaseView): void;
    c9: VerticalAxisLabelPanelView;
    di: number;
    df: number;
    dh: number;
    dg: number;
    b6(): void;
    bq(): number;
    db(): number;
    dd(): number;
    de(): number;
    dc(): number;
    a5(): List$1<Rect>;
    private dj;
    private dk;
    cm(a: FrameworkElement, b: number): void;
    protected da(): boolean;
    c0(): Rect;
    aj(a: TitleSettings): AxisTitlePosition;
    ai(): AxisLabelsLocation;
    ay(a: AxisLabelsLocation): boolean;
    protected b9(): void;
}
/**
 * @hidden
 */
export declare class ViewportUtils extends Base {
    static $t: Type;
    static e(a: number, b: Rect, c: Rect, d: Rect): number;
    static b(a: number, b: Rect, c: Rect, d: Rect): number;
    static i(a: number, b: Rect, c: Rect, d: Rect): number;
    static g(a: number, b: Rect, c: Rect, d: Rect): number;
    static d(a: number, b: Rect, c: Rect, d: Rect): number;
    static a(a: number, b: Rect, c: Rect, d: Rect): number;
    static h(a: number, b: Rect, c: Rect, d: Rect): number;
    static f(a: number, b: Rect, c: Rect): number;
    static c(a: number, b: Rect, c: Rect): number;
    static j(a: number, b: Rect, c: Rect): number;
}
/**
 * @hidden
 */
export interface IHasCategoryAxis {
    readonly categoryAxis: CategoryAxisBase;
    getOffsetValue(): number;
    getCategoryWidth(): number;
}
/**
 * @hidden
 */
export declare let IHasCategoryAxis_$type: Type;
/**
 * @hidden
 */
export interface IHasCategoryModePreference extends IHasCategoryAxis {
    preferredCategoryMode(a: CategoryAxisBase): CategoryMode;
}
/**
 * @hidden
 */
export declare let IHasCategoryModePreference_$type: Type;
/**
 * @hidden
 */
export declare class AutomaticSeriesManager extends Base {
    static $t: Type;
    private g;
    private c;
    e(a: AutomaticSeriesPurpose): boolean;
    constructor(a: SeriesViewer);
    private i;
    private n;
    private m;
    protected f: boolean;
    private j;
    private k;
    l(a: AutomaticSeriesPurpose): void;
    private h;
    private d;
    private a;
    get b(): AutomaticSeriesRequestCollection;
}
/**
 * @hidden
 */
export declare class AutomaticSeriesRequest extends Base {
    static $t: Type;
    a: AutomaticSeriesPurpose;
    d: Series;
    b: Series;
    c: Series;
    e: boolean;
    f: boolean;
}
/**
 * @hidden
 */
export declare class AutomaticSeriesRequestCollection extends ObservableCollection$1<AutomaticSeriesRequest> {
    static $t: Type;
    constructor();
}
/**
 * @hidden
 */
export declare class ChartSelection extends Base {
    static $t: Type;
    private _item;
    get item(): any;
    set item(a: any);
    private _series;
    get series(): Series;
    set series(a: Series);
    private b;
    get c(): SeriesMatcher;
    set c(a: SeriesMatcher);
    equals(a: any): boolean;
    getHashCode(): number;
    g(a: SeriesViewer): void;
}
/**
 * @hidden
 */
export declare class ChartSelectedItemCollection extends ObservableCollection$1<ChartSelection> {
    static $t: Type;
    constructor();
    collectionResetting: (sender: any, e: EventArgs) => void;
    protected p(): void;
}
/**
 * @hidden
 */
export declare class SeriesMatcherHelper extends Base {
    static $t: Type;
    static a(a: SeriesViewer, b: SeriesMatcher): Series[];
    private static b;
}
/**
 * @hidden
 */
export declare class SeriesLayer extends DependencyObject implements INotifyPropertyChanged {
    static $t: Type;
    private _source;
    get source(): Series;
    set source(a: Series);
    private _target;
    get target(): Series;
    set target(a: Series);
    private z;
    constructor();
    private ak;
    au(): void;
    at(): void;
    get t(): boolean;
    private a3;
    private a4;
    private a5;
    private a2;
    private ah;
    private an;
    private ag;
    private ao;
    n: IExecutionContext;
    private u;
    private ar;
    private as;
    private y;
    az(a: Series, b: DependencyProperty): void;
    a0(a: Series, b: DependencyProperty): void;
    private r;
    private af;
    private al;
    private p;
    private aa;
    private ab;
    private v;
    private w;
    private x;
    private av;
    propertyChanged: (sender: any, e: PropertyChangedEventArgs) => void;
    private ax;
    protected q: boolean;
    am(a: Series, b: Series): void;
    private ay;
    private a1;
    ap(a: Series): void;
    private aq;
    private aw;
    ai(a: Series, b: Series, c: DependencyProperty, d: any): any;
    private s;
    private ad;
    private ae;
    ac: number;
    get m(): SeriesLayerPropertyOverlayCollection;
    private l;
    private o;
    static $$p: string[];
}
/**
 * @hidden
 */
export declare class SeriesLayerCollection extends ObservableCollection$1<SeriesLayer> {
    static $t: Type;
    constructor();
    collectionResetting: (sender: any, e: EventArgs) => void;
    protected p(): void;
}
/**
 * @hidden
 */
export declare class SeriesLayerManager extends Base {
    static $t: Type;
    a: Series;
    private b;
    private i;
    private n;
    private m;
    h(a: Series, b: SeriesLayerCollection, c: NotifyCollectionChangedEventArgs): void;
    j(a: Series, b: SeriesLayerCollection, c: EventArgs): void;
    e(a: Series, b: SeriesLayerCollection, c: NotifyCollectionChangedEventArgs): void;
    f(a: Series, b: SeriesLayerCollection, c: EventArgs): void;
    c(a: Series, b: SeriesLayerCollection, c: NotifyCollectionChangedEventArgs): void;
    private g;
    private l;
    private k;
    d(a: Series, b: SeriesLayerCollection, c: EventArgs): void;
}
/**
 * @hidden
 */
export declare class SeriesLayerPropertyOverlay extends DependencyObject implements INotifyPropertyChanged {
    static $t: Type;
    o: boolean;
    k: SeriesLayerPropertyOverlay;
    propertyChanged: (sender: any, e: PropertyChangedEventArgs) => void;
    propertyUpdated: (sender: any, e: PropertyUpdatedEventArgs) => void;
    private ah;
    q: boolean;
    protected n: boolean;
    private ag;
    private m;
    w: any;
    s: any;
    t(a: any, b: any, c: Series): any;
    private aj;
    private v;
    private ai;
    private u;
    r: boolean;
    p: boolean;
    get aa(): string;
    ad: string;
    y: string;
    x: any;
    valueResolving: (sender: any, e: SeriesLayerPropertyOverlayValueResolvingEventArgs) => void;
    static $$p: string[];
}
/**
 * @hidden
 */
export declare class SeriesLayerPropertyOverlayCollection extends ObservableCollection$1<SeriesLayerPropertyOverlay> {
    static $t: Type;
    constructor();
    collectionResetting: (sender: any, e: EventArgs) => void;
    protected p(): void;
}
/**
 * @hidden
 */
export interface IDataChartToolbarProvider {
    container: any;
    getDesiredToolbarActions(a: SeriesViewer): ToolActionInfo[];
    onToolCommandExecuting(a: SeriesViewer, b: ToolCommand): ToolCommandExecutionState;
}
/**
 * @hidden
 */
export declare let IDataChartToolbarProvider_$type: Type;
/**
 * @hidden
 */
export interface ISeriesViewerScrollbarManager {
    executionContext: IExecutionContext;
    animator: DoubleAnimator;
    owner: SeriesViewer;
    onHorizontalScrollbarModeChanged(a: SeriesViewerScrollbarMode): void;
    onVerticalScrollbarModeChanged(a: SeriesViewerScrollbarMode): void;
    updateScrollbars(a: SeriesViewer, b: Rect, c: Rect, d: Rect, e: Rect): void;
    updateBarDimensions(a: SeriesViewer, b: number, c: number, d: number, e: boolean, f: number, g: number, h: number, i: number, j: number, k: boolean, l: number, m: number): void;
    updateBarAppearance(a: SeriesViewer, b: Brush, c: Brush, d: Brush, e: Brush, f: number, g: number, h: number, i: number): void;
    onCrosshairMoved(a: Point): void;
    shouldHandleInteraction(a: Point, b: boolean): boolean;
    onScrollbarDrag(a: Point, b: boolean): void;
    onScrollbarDragComplete(a: Point, b: boolean): void;
    onScrollbarDragCancel(): void;
    updateVerticalScrollbarPosition(a: SeriesViewerVerticalScrollbarPosition): void;
    updateHorizontalScrollbarPosition(a: SeriesViewerHorizontalScrollbarPosition): void;
}
/**
 * @hidden
 */
export declare let ISeriesViewerScrollbarManager_$type: Type;
/**
 * @hidden
 */
export interface ISeriesInteractionManager {
    a$m(a: Series, b: Point, c: number, d: Axis, e: ScalerParams, f: number, g: number, h: (arg1: Point) => number): number;
    a$p(a: Series, b: IList$1<number>, c: Point, d: Axis, e: ScalerParams, f: number, g: (arg1: Point) => number, h: boolean, i: boolean): number;
    a$o(a: Series, b: number, c: IList$1<number>, d: number, e: number, f: number, g: number, h: number, i: boolean): number;
    a$r(a: Series, b: Point, c: boolean, d: Axis, e: (arg1: Point) => number, f: IList$1<number>): number;
    a$f(a: Series, b: Point, c: boolean): boolean;
    a$b(a: Series, b: CategoryAxisBase, c: List$1<number[]>, d: number, e: number, f: Point, g: boolean): number[][];
    a$a(a: Series, b: CategoryAxisBase, c: List$1<number[]>, d: number, e: number, f: Point, g: boolean): number[];
    a$g(a: Series, b: Point, c: boolean, d: PathGeometry): boolean;
    a$h(a: Series, b: Point, c: PathGeometry): boolean;
    a$q(a: Series, b: Point, c: boolean, d: Axis, e: (arg1: Point) => number, f: IList$1<number>): number;
    a$n(a: Series, b: Point, c: Axis): number;
    a$i(a: Series, b: Point, c: boolean): boolean;
    a$au(a: Series, b: Point, c: boolean, d: boolean, e: number, f: Axis, g: Axis, h: (arg1: Point, arg2: boolean, arg3: boolean) => number, i: (arg1: Point, arg2: boolean) => number, j: (arg1: Point, arg2: boolean) => number): Point;
    a$ab(a: Series, b: any, c: Point, d: boolean, e: boolean, f: boolean, g: boolean, h: boolean, i: boolean): void;
    a$y(): void;
    a$at(a: Series, b: HighlightingInfo, c: HighlightingInfo, d: HighlightingInfo, e: number, f: number, g: number, h: number, i: number, j: number, k: Brush, l: boolean): Brush;
    a$l(a: Series, b: HighlightingInfo, c: HighlightingInfo, d: HighlightingInfo, e: number): number;
    a$k(a: Series, b: HighlightingInfo, c: HighlightingInfo, d: HighlightingInfo, e: number, f: number, g: number, h: number, i: number, j: number, k: number, l: number, m: boolean): number;
    a$ae(a: Series, b: Point, c: any, d: any, e: boolean): void;
    a$ar(a: Series, b: Point): void;
    a$ah(a: Series, b: Point, c: any, d: any, e: boolean): void;
    a$af(a: Series, b: Point, c: any, d: any, e: boolean): void;
    a$ac(a: Series, b: Point, c: any, d: any): void;
    a$ag(a: Series, b: Point, c: any, d: any): void;
    a$ad(a: Series, b: Point, c: any, d: any): void;
    a$ai(a: Series, b: Point, c: any, d: any): void;
    a$aj(a: Series, b: Point, c: any, d: any): void;
    a$t(a: Series): string;
    a$u(a: Series): string;
    readonly a$c: boolean;
    readonly a$s: any;
    a$as(a: Series, b: any): void;
    a$aq(a: Series, b: Point, c: (arg1: any) => void): void;
    a$aa(a: Series): void;
    a$ap(a: Series): void;
    readonly a$e: boolean;
    readonly a$j: Dictionary$2<string, SeriesView>;
    readonly a$d: boolean;
    a$z(a: Series, b: Rect, c: Rect, d: string, e: number): void;
    a$ak(a: Series, b: SeriesViewer): void;
    a$al(a: Series, b: string, c: SeriesViewer): void;
    a$x(a: Series, b: any, c: number): void;
    a$v(a: Series): void;
    a$an(a: Series, b: any, c: number): void;
    a$ao(a: Series): void;
    a$w(a: Series, b: any, c: number): void;
    a$am(a: Series, b: any, c: number): void;
}
/**
 * @hidden
 */
export declare let ISeriesInteractionManager_$type: Type;
/**
 * @hidden
 */
export interface ISeriesViewerInteractionManager {
    f$a(a: SeriesViewer): ChartHitTestMode;
    f$aj(a: SeriesViewer): void;
    f$t(a: SeriesViewer, b: Point): void;
    f$ah(a: SeriesViewer, b: Point): void;
    f$u(a: SeriesViewer, b: Point, c: boolean): void;
    f$s(a: SeriesViewer, b: Point): void;
    f$ao(a: SeriesViewer): void;
    f$ag(a: SeriesViewer, b: Point): void;
    f$ap(a: SeriesViewer, b: Point, c: number, d: number, e: number): void;
    f$af(a: SeriesViewer, b: number): void;
    f$al(a: SeriesViewer, b: Point, c: number, d: number, e: number): void;
    f$ac(a: SeriesViewer, b: Point): void;
    f$ae(a: SeriesViewer, b: number): void;
    f$v(a: SeriesViewer, b: Point): void;
    f$ab(a: SeriesViewer, b: Point): void;
    f$ak(a: SeriesViewer, b: Point, c: number, d: number, e: number): void;
    f$q(a: SeriesViewer, b: Point, c: boolean): void;
    f$an(a: SeriesViewer): void;
    f$am(a: SeriesViewer): void;
    f$at(a: SeriesViewer): void;
    f$n(a: SeriesViewer): void;
    f$k(a: SeriesViewer): void;
    f$p(a: SeriesViewer, b: Point, c: boolean): void;
    f$o(a: SeriesViewer, b: Point, c: boolean, d: boolean): void;
    f$ar(a: SeriesViewer): void;
    f$ai(a: SeriesViewer): void;
    f$g(a: SeriesViewer, b: Key): boolean;
    f$h(a: SeriesViewer, b: Point, c: number): boolean;
    f$r(a: SeriesViewer, b: Point): void;
    f$m(a: SeriesViewer): void;
    f$l(a: SeriesViewer): void;
    readonly f$e: IHighlightingManager;
    readonly f$f: IHighlightingManager;
    readonly f$d: IHighlightingManager;
    readonly f$b: ISeriesViewerScrollbarManager;
    f$as(a: SeriesViewer, b: Point): void;
    f$j(a: Series, b: any, c: number): void;
    f$aq(a: Series, b: any, c: number): void;
    f$c(a: SeriesViewer, b: SeriesCollection, c: RenderingContext, d: Point, e: boolean, f: DataContext, g: boolean): {
        ret: Series;
        p5: DataContext;
    };
    f$i(a: SeriesViewer, b: Point): boolean;
    f$z(a: SeriesViewer, b: SeriesCollection, c: RenderingContext, d: Point, e: boolean, f: boolean): void;
    f$y(a: SeriesViewer, b: Point): void;
    f$x(a: SeriesViewer, b: EventProxy, c: Point): void;
    f$aa(a: SeriesViewer, b: EventProxy, c: Point): void;
    f$w(a: SeriesViewer, b: Point, c: boolean): void;
    f$ad(a: SeriesViewer, b: boolean): void;
}
/**
 * @hidden
 */
export declare let ISeriesViewerInteractionManager_$type: Type;
/**
 * @hidden
 */
export interface IDataChartVisualDataManager {
    exportVisualData(a: XamDataChart): any;
}
/**
 * @hidden
 */
export declare let IDataChartVisualDataManager_$type: Type;
/**
 * @hidden
 */
export interface IAxisVisualDataManager {
    exportVisualData(a: Axis): any;
}
/**
 * @hidden
 */
export declare let IAxisVisualDataManager_$type: Type;
/**
 * @hidden
 */
export interface ISeriesVisualDataManager {
    exportVisualData(a: Series, b: Rect): any;
    exportMarkerVisualData(a: MarkerSeries, b: any): void;
    getMarkerVisualData(a: Series, b: Marker, c: DataTemplate): any;
    copyVisualData(a: any, b: any): void;
    exportTrendlineData(a: Series, b: any, c: Polyline): void;
    exportStackedVisualData(a: Series, b: Rect): any;
    createFragmentVisualData(a: Series, b: Rect, c: string, d: string): any;
    addSubSeriesVisualData(a: any, b: any): void;
    addSubSeriesLayerVisualData(a: any, b: any): void;
    exportRectangleData(a: any, b: Rectangle, c: string, d: string[]): void;
    exportMarkerVisualDataFromMarker(a: Series, b: any, c: ContentControl): void;
    exportPathData(a: any, b: Path, c: string, d: string[]): void;
    exportPolylineData(a: any, b: Polyline, c: string, d: string[]): void;
    exportPolygonData(a: any, b: Polygon, c: string, d: string[]): void;
    exportSeriesPixelsData(a: any, b: number[], c: number, d: number): void;
    addPointerTooltipData(a: any, b: any, c: number, d: number, e: List$1<string>): void;
    addPointerTooltipWithDataLegend(a: any, b: any, c: number, d: number, e: any): void;
    exportPointerTooltipData(a: Polygon, b: Polyline, c: Rectangle, d: Rect): any;
    exportCalloutData(a: number, b: number, c: number, d: number, e: any, f: Rectangle, g: TextBlock, h: FontInfo, i: Line, j: string, k: string[]): void;
    exportLayerVisualData(a: Series, b: any): void;
}
/**
 * @hidden
 */
export declare let ISeriesVisualDataManager_$type: Type;
/**
 * @hidden
 */
export declare class XamDataChart extends SeriesViewer {
    static $t: Type;
    static yf: number;
    static ye: number;
    private _xsr;
    private get XSRP();
    private wx;
    get wy(): IDataChartVisualDataManager;
    static staticInit(): void;
    static yr(a: Series): number;
    constructor();
    protected qh(a: any, b: string, c: any, d: any): void;
    qz(): void;
    ov(): void;
    protected ok(a: Rect, b: Rect): void;
    protected oq(): void;
    zy(): void;
    private zt;
    private aat;
    private z0;
    private w3;
    private w2;
    private w0;
    private wz;
    private aau;
    private aav;
    protected get_ex(): boolean;
    xi: boolean;
    hs(): number;
    ht(): number;
    protected rk(): void;
    yp: number;
    yq: number;
    private xy;
    get ya(): number;
    set ya(a: number);
    private xz;
    get yb(): number;
    set yb(a: number);
    fl(): boolean;
    fm(): boolean;
    xf: boolean;
    xs: boolean;
    xg: boolean;
    xj: boolean;
    ww: GridMode;
    xc: boolean;
    xn: boolean;
    xo: boolean;
    yh: number;
    yd: number;
    yc: number;
    get xa(): boolean;
    protected get_fu(): boolean;
    get xb(): boolean;
    xq: boolean;
    xm: boolean;
    xp: boolean;
    xr: boolean;
    wr: AutoMarginsAndAngleUpdateMode;
    xh: boolean;
    xl: boolean;
    xk: boolean;
    private x0;
    private x1;
    private yi;
    private yj;
    protected get_ft(): boolean;
    protected get_fs(): boolean;
    zx(): void;
    zw(): void;
    zv(a: AxisLabelPanelBase, b: Rect, c: Rect, d: Rect): void;
    private yo;
    private yg;
    private zs;
    aas: Brush;
    aaq: Brush;
    aar: Brush;
    get axes(): AxisCollection;
    private ws;
    private zp;
    private zq;
    axisRangeChanged: (sender: any, e: ChartAxisRangeChangedEventArgs) => void;
    private zr;
    private static zu;
    rt(a: SyncLink, b: SyncLink): void;
    private w6;
    getFontInfo(): FontInfo;
    zz(): void;
    getFontBrush(): Brush;
    protected nk(): void;
    u8(): Brush;
    f3(): boolean;
    protected ro(): void;
    ev(): boolean;
    private xe;
    protected c8(): SeriesViewerView;
    protected p5(a: SeriesViewerView): void;
    w5: XamDataChartView;
    q0(): void;
    private w9;
    static yu: string;
    private xv;
    get x7(): number;
    set x7(a: number);
    static yw: string;
    private xx;
    get x9(): number;
    set x9(a: number);
    static yv: string;
    private xw;
    get x8(): number;
    set x8(a: number);
    static yt: string;
    private xu;
    get x6(): number;
    set x6(a: number);
    wu: ComputedPlotAreaMarginMode;
    w1: SeriesPlotAreaMarginHorizontalMode;
    w4: SeriesPlotAreaMarginVerticalMode;
    private x3;
    get yl(): number;
    set yl(a: number);
    private x5;
    get yn(): number;
    set yn(a: number);
    private x4;
    get ym(): number;
    set ym(a: number);
    private x2;
    get yk(): number;
    set yk(a: number);
    protected v6(a: Rect): Rect;
    wc(): Rect;
    ys(): any;
    y7(): string;
    qe(): void;
    q2(): void;
    xt(a: Axis): List$1<Axis>;
    static $$p: string[];
}
/**
 * @hidden
 */
export declare class LabelPanelArranger extends Base {
    static $t: Type;
    static e(a: List$1<AxisLabelPanelBase>, b: Rect): Rect;
    private static a;
    static b(a: AxisLabelPanelBase): AxisLabelsLocation;
    private static c;
    static d(a: List$1<AxisLabelPanelBase>, b: LabelPanelsArrangeState, c: Rect, d: (arg1: AxisLabelPanelBase, arg2: Rect) => void): void;
}
/**
 * @hidden
 */
export declare class ChartContentManager extends DependencyObject {
    static $t: Type;
    private l;
    private r;
    private t;
    private get u();
    private set u(value);
    constructor(a: SeriesViewer);
    k(a: ChartContentType, b: DependencyObject, c: (arg1: boolean) => void): ContentInfo;
    ad(a: ChartContentType, b: DependencyObject): void;
    private m;
    private v;
    aa(a: DomRenderer): void;
    z(): void;
    ac(a: ChartContentType, b: DependencyObject, c: ContentInfo, d: boolean): void;
    private q;
    private j;
    y(): void;
    private w;
    private _s;
    private s;
    x(a: Size): void;
    o: boolean;
    n: boolean;
    p: boolean;
    ae(a: ChartContentType, b: DependencyObject, c: ContentInfo, d: Rect): void;
    ab(a: Axis, b: ContentInfo): void;
}
/**
 * @hidden
 */
export declare class ContentInfo extends Base {
    static $t: Type;
    h: DependencyObject;
    a: (arg1: boolean) => void;
    b: boolean;
    c: boolean;
    i: Rect;
    get d(): boolean;
    g(): void;
    f(): void;
    e: boolean;
}
/**
 * @hidden
 */
export declare abstract class Series extends Control implements INotifyPropertyChanged, IProvidesViewport, ILegendSeries, ILegendSeriesInternal, ILegendOwner, ILegendTemplateProvider, IDataLegendSeries {
    static $t: Type;
    cv: SeriesView;
    private static j0;
    kg: number;
    wi: Rect;
    gc(): boolean;
    protected get_dataLegendKey(): string;
    get dataLegendKey(): string;
    l3: string;
    mj: string;
    get group(): string;
    get parentKey(): string;
    get parentTitle(): string;
    ew: boolean;
    private jy;
    get jz(): DomRenderer;
    set jz(a: DomRenderer);
    provideRenderer(a: DomRenderer): void;
    ne(): string;
    constructor();
    j6(): number;
    cc: SeriesLayerManager;
    private ot;
    private ou;
    private op;
    private oq;
    private on;
    private oo;
    private or;
    private qq;
    private qw;
    private qv;
    private os;
    sl(a: MarkerOutlineMode): void;
    sk(a: MarkerFillMode): void;
    sm(a: number): void;
    private static readonly u3;
    protected ov(a: any, b: PropertyChangedEventArgs): void;
    private dq;
    get dr(): SRProvider;
    private bb;
    get bc(): ISeriesVisualDataManager;
    protected get hn(): Dictionary$2<string, SeriesView>;
    private a9;
    get ba(): ISeriesInteractionManager;
    get fi(): boolean;
    dc: DoubleAnimator;
    q1(a: SeriesView): void;
    qy(): void;
    qz(): void;
    ct(): SeriesView;
    protected cs(): SeriesView;
    sv: Canvas;
    hb(): boolean;
    kq(a: any, b: string): any;
    md(a: string): string;
    onLegendItemOver(a: any): void;
    onLegendItemPointerUp(a: any): void;
    onLegendItemPointerDown(a: any): void;
    onLegendItemEnter(a: any): void;
    onLegendItemLeave(a: any): void;
    private hh;
    protected nd(a: string): string;
    private hg;
    protected kr(a: any, b: string, c: string): any;
    ir(a: Point): number;
    j5(a: Point): number;
    protected get_fs(): boolean;
    get fs(): boolean;
    a0(): CategoryAxisBase;
    j3(a: Point): number;
    wu(): Thickness;
    ww(a: SeriesPlotAreaMarginHorizontalMode, b: SeriesPlotAreaMarginVerticalMode): Thickness;
    wv(a: SeriesPlotAreaMarginHorizontalMode, b: SeriesPlotAreaMarginVerticalMode): Thickness;
    ck(): SeriesPlotAreaMarginHorizontalMode;
    cl(): SeriesPlotAreaMarginVerticalMode;
    kn(a: Point): any;
    p4(a: Rect, b: List$1<ChartSelection>, c: SeriesSelectionBehavior): void;
    ak(a: Rect, b: SeriesSelectionBehavior): ChartSelection[];
    protected kw(a: Series, b: Point): any;
    protected di(a: Series, b: any, c: Point, d: boolean): HighlightingInfo;
    protected dj(a: Series, b: any, c: Point, d: boolean): HighlightingInfo;
    j2(): number;
    j7(): number;
    kc(): number;
    get container(): ILegendOwner;
    get hasSubItems(): boolean;
    protected eh(): boolean;
    forSubItems(a: (arg1: any) => void): void;
    protected p2(a: (arg1: any) => void): void;
    p3(a: (arg1: Series) => boolean): void;
    get eg(): boolean;
    p1(a: (arg1: Series) => boolean): void;
    nc(): string;
    vw(): Brush;
    vx(): Brush;
    resolveLegendIndex(): number;
    bp(): Series;
    protected get_es(): boolean;
    get es(): boolean;
    protected get_ep(): boolean;
    get ep(): boolean;
    protected get_eo(): boolean;
    get eo(): boolean;
    protected get_er(): boolean;
    get er(): boolean;
    protected get_eq(): boolean;
    get eq(): boolean;
    protected get_et(): boolean;
    get et(): boolean;
    protected get_isVertical(): boolean;
    get isVertical(): boolean;
    protected get_fb(): boolean;
    get fb(): boolean;
    protected get_ev(): boolean;
    get ev(): boolean;
    protected get_eu(): boolean;
    get eu(): boolean;
    protected get_ek(): boolean;
    get ek(): boolean;
    protected get_f5(): boolean;
    get f5(): boolean;
    protected get_fk(): boolean;
    get fk(): boolean;
    protected get_fj(): boolean;
    get fj(): boolean;
    protected get_f0(): boolean;
    get f0(): boolean;
    protected get_ez(): boolean;
    get ez(): boolean;
    protected get_ex(): boolean;
    get ex(): boolean;
    protected get_f6(): boolean;
    get f6(): boolean;
    protected get_fr(): boolean;
    get fr(): boolean;
    protected get_fq(): boolean;
    get fq(): boolean;
    protected get_fo(): boolean;
    get fo(): boolean;
    protected get_fn(): boolean;
    get fn(): boolean;
    protected get_f3(): boolean;
    get f3(): boolean;
    protected get_f1(): boolean;
    get f1(): boolean;
    protected get_fy(): boolean;
    get fy(): boolean;
    protected get_fp(): boolean;
    get fp(): boolean;
    protected get_fw(): boolean;
    get fw(): boolean;
    protected get_ft(): boolean;
    get ft(): boolean;
    protected get_isStacked(): boolean;
    get isStacked(): boolean;
    protected get_e6(): boolean;
    get e6(): boolean;
    protected get_fu(): boolean;
    get fu(): boolean;
    protected get_ey(): boolean;
    get ey(): boolean;
    protected get_fc(): boolean;
    get fc(): boolean;
    protected get_fx(): boolean;
    get fx(): boolean;
    protected get_isValueOverlay(): boolean;
    get isValueOverlay(): boolean;
    protected get_ff(): boolean;
    get ff(): boolean;
    protected get_isSummarizationSupported(): boolean;
    get isSummarizationSupported(): boolean;
    get isLayer(): boolean;
    bo(): Series;
    protected get_ei(): boolean;
    get ei(): boolean;
    protected get_e9(): boolean;
    get e9(): boolean;
    protected get_e8(): boolean;
    get e8(): boolean;
    protected get_e7(): boolean;
    get e7(): boolean;
    protected get_fa(): boolean;
    get fa(): boolean;
    protected get_e1(): boolean;
    get e1(): boolean;
    protected get_e2(): boolean;
    get e2(): boolean;
    ip(a: Point, b: number, c: Axis, d: ScalerParams, e: number): number;
    protected iq(a: Point, b: number, c: Axis, d: ScalerParams, e: number, f: number, g: (arg1: Point) => number): number;
    protected get_hd(): boolean;
    get hd(): boolean;
    protected i7(a: IList$1<number>, b: Point, c: Axis, d: ScalerParams, e: number, f: (arg1: Point) => number, g: boolean, h: boolean): number;
    iv(a: number, b: IList$1<number>, c: number, d: number, e: number, f: number, g: number, h: boolean): number;
    kb(a: Point, b: boolean, c: Axis, d: (arg1: Point) => number, e: IList$1<number>): number;
    iu(a: boolean): number;
    aj(a: Point): Point[][];
    al(a: Point): Point[][];
    protected gv(a: Point, b: boolean): boolean;
    an(a: CategoryAxisBase, b: List$1<number[]>, c: number, d: number, e: Point, f: boolean): number[][];
    am(a: CategoryAxisBase, b: List$1<number[]>, c: number, d: number, e: Point, f: boolean): number[];
    protected gx(a: Point, b: boolean, c: PathGeometry): boolean;
    protected gy(a: Point, b: PathGeometry): boolean;
    j9(a: Point, b: boolean, c: Axis, d: (arg1: Point) => number, e: IList$1<number>): number;
    it(a: Point, b: Axis): number;
    ka(a: Point, b: boolean): number;
    j8(a: Point, b: boolean): number;
    i5(a: Point, b: boolean, c: boolean): number;
    wc(a: Point, b: boolean, c: boolean): Point;
    wn(a: Point): Rect;
    ao(a: Point): Rect[];
    wo(a: Point): Rect;
    ap(a: Point): Rect[];
    ar(a: number, b: number): CollisionGeometry;
    wp(a: Point): Rect;
    wq(a: Point): Rect;
    protected gz(a: Point, b: boolean): boolean;
    protected we(a: Point, b: boolean, c: boolean, d: number, e: Axis, f: Axis, g: (arg1: Point, arg2: boolean, arg3: boolean) => number, h: (arg1: Point, arg2: boolean) => number, i: (arg1: Point, arg2: boolean) => number): Point;
    i1(a: Point, b: boolean, c: boolean): number;
    v8(a: Point, b: boolean, c: boolean): Point;
    i3(a: Point, b: boolean, c: boolean): number;
    wa(a: Point, b: boolean, c: boolean): Point;
    wd(a: Point, b: boolean, c: boolean): Point;
    i6(a: Point, b: boolean, c: boolean): number;
    v9(a: Point, b: boolean, c: boolean): Point;
    i2(a: Point, b: boolean, c: boolean): number;
    wb(a: Point, b: boolean, c: boolean): Point;
    i4(a: Point, b: boolean, c: boolean): number;
    j4(a: Point): number;
    iw(): number;
    static pm(a: Series, b: SeriesViewer, c: boolean): void;
    is(a: Point): number;
    ko(a: Point): any;
    ki: any;
    protected oz(a: Series, b: any): void;
    protected k0(a: Series): any;
    au(a: boolean): BindingFormatter;
    eb(a: List$1<SeriesPointOfInterest>, b: boolean, c: boolean, d: number, e: boolean): boolean;
    jd(a: Marker): number;
    jc(a: any): number;
    me(): string;
    i8(a: ValueLayerValueMode, b: Axis): number;
    aq(a: ValueLayerValueMode): number[];
    wf(a: ValueLayerValueMode): Point;
    wg(a: number[]): Point;
    propertyChanged: (sender: any, e: PropertyChangedEventArgs) => void;
    propertyUpdated: (sender: any, e: PropertyUpdatedEventArgs) => void;
    protected raisePropertyChanged(a: string, b: any, c: any): void;
    private k3;
    private ky;
    private static hf;
    tm(a: string): DependencyProperty;
    protected get_hasMarkers(): boolean;
    get hasMarkers(): boolean;
    protected get_el(): boolean;
    get el(): boolean;
    p7(): void;
    p8(): void;
    protected vn(a: number): Brush;
    protected vt(a: Brush): Brush;
    protected vq(a: number): Brush;
    protected vo(a: number): Brush;
    protected vp(a: number): Brush;
    vl(): Brush;
    vm(): Brush;
    sz(): DataTemplate;
    io(): number;
    wh(a: Point): Point;
    wr(a: Rect): Rect;
    v7(a: Point): Point;
    kx(a: any, b: Point): any;
    gd(a: any): boolean;
    ay(a: Axis): AxisRange;
    az(a: Rect): AxisRange;
    wt(): Size;
    ax(a: AxisRange, b: NumericAxisBase, c: Rect): AxisRange;
    protected py(): void;
    protected d7: boolean;
    rr(a: boolean): void;
    transitionOutCompleted: (sender: any, e: TransitionOutCompletedEventArgs) => void;
    renderRequested: (sender: any, e: RenderRequestedEventArgs) => void;
    private pi;
    private bt;
    protected get bu(): SeriesHighlightedValuesDisplayMode;
    protected set bu(a: SeriesHighlightedValuesDisplayMode);
    rs(a: boolean): void;
    private cd;
    get ce(): SeriesLayerPropertyOverlayCollection;
    protected get_em(): boolean;
    protected get em(): boolean;
    protected gb(): boolean;
    private re;
    private pg;
    private b4;
    private static hj;
    private static hk;
    static pn(): void;
    static nv(a: string): string;
    static nw(a: string): string;
    static o9(a: Dictionary$2<string, string>, b: Dictionary$2<string, string>): void;
    protected r0(a: any, b: SeriesLayerPropertyOverlayValueResolvingEventArgs): void;
    protected ry(a: any, b: SeriesLayerPropertyOverlayValueResolvingEventArgs): void;
    protected rx(a: any, b: SeriesLayerPropertyOverlayValueResolvingEventArgs): void;
    protected rz(a: any, b: SeriesLayerPropertyOverlayValueResolvingEventArgs): void;
    protected get_gt(): boolean;
    protected get gt(): boolean;
    private pk;
    protected hs(): List$1<SeriesLayerPropertyOverlay>;
    private p9;
    protected ht(): List$1<SeriesLayerPropertyOverlay>;
    get fv(): boolean;
    private dv;
    protected qx(): void;
    renderValid: (sender: any, e: RenderValidEventArgs) => void;
    g1: boolean;
    g4: boolean;
    protected o1(): void;
    gk: boolean;
    protected qo(): void;
    protected q0(): void;
    private ro;
    protected o6(): void;
    cu: SeriesView;
    rt(a: Rect, b: RenderSurface): void;
    rq(a: Rect, b: Rect, c: RenderSurface, d: string, e: number): void;
    getEffectiveViewport1(a: SeriesView): Rect;
    getMainContentViewport(): Rect;
    wj(a: SeriesView): Rect;
    wm(a: Rect): Rect;
    wl(a: SeriesView): Rect;
    getEffectiveViewport(): Rect;
    rk(): void;
    protected get_ed(): boolean;
    get ed(): boolean;
    protected get_ej(): boolean;
    get ej(): boolean;
    private rl;
    rm(a: string): void;
    getViewInfo(a: Rect, b: Rect): {
        p0: Rect;
        p1: Rect;
    };
    he(a: Rect, b: Rect, c: SeriesView): boolean;
    o5(a: boolean, b: SeriesView): void;
    protected d4(): boolean;
    d5(a: SeriesView): boolean;
    q2(a: Rect, b: Rect): void;
    protected sr(a: Rect, b: Rect): void;
    protected sq(a: Rect, b: Rect): void;
    a1: ContentInfo;
    private dy;
    get g0(): boolean;
    set g0(a: boolean);
    protected p0(a: Series): void;
    protected qm(): void;
    protected hv: Stack$1<string>;
    rf(a: string): void;
    qg(): void;
    ql(): void;
    protected get_fg(): boolean;
    get fg(): boolean;
    protected get_isUsableInLegend(): boolean;
    get isUsableInLegend(): boolean;
    protected qt(): void;
    qn(): void;
    protected q3(): void;
    q4(): void;
    protected gr: boolean;
    protected gs: boolean;
    protected ga(): boolean;
    protected q5(a: boolean): void;
    private dz;
    protected get g2(): boolean;
    protected set g2(a: boolean);
    private d0;
    protected get g5(): boolean;
    protected set g5(a: boolean);
    protected get g3(): boolean;
    protected get g6(): boolean;
    protected v(): void;
    protected w(a: Visibility, b: Visibility): void;
    protected qs(): void;
    protected qf(): void;
    as: BindingFormatter;
    at: BindingFormatter;
    private pw;
    private po;
    protected q9(a: any, b: string, c: any, d: any): void;
    private vr;
    private vs;
    private vu;
    protected sg(): void;
    so(a: Point): void;
    ps(a: any): void;
    px(): void;
    pv(): void;
    pr(a: any): void;
    pq(a: any): void;
    ee(a: any): boolean;
    pp(a: any): void;
    pl(): void;
    protected get_fe(): boolean;
    protected get fe(): boolean;
    d6: boolean;
    protected pf(a: Series): void;
    get c3(): SyncLink;
    set c3(a: SyncLink);
    private c2;
    get db(): SeriesViewer;
    set db(a: SeriesViewer);
    private da;
    get c9(): XamDataChart;
    set c9(a: XamDataChart);
    readonly hy: (sender: any, e: NotifyCollectionChangedEventArgs) => void;
    readonly bh: (sender: any, e: PropertyUpdatedEventArgs) => void;
    readonly dp: (sender: any, e: RectChangedEventArgs) => void;
    get itemsSource(): IEnumerable;
    set itemsSource(a: IEnumerable);
    static readonly tz: DependencyProperty;
    highlightedItemsSource: IEnumerable;
    dn: IFastItemsSource;
    jv: (sender: any, e: FastItemsSourceEventArgs) => void;
    protected pb(a: FastItemsSourceEventAction, b: number, c: number, d: string): void;
    get legend(): IChartLegend;
    set legend(a: IChartLegend);
    static readonly t5: DependencyProperty;
    get su(): Control;
    set su(a: Control);
    private ss;
    kz(): any;
    protected st(): Control;
    get a5(): IChartLegend;
    set a5(a: IChartLegend);
    private a4;
    legendItemVisibility: Visibility;
    get legendItemBadgeTemplate(): DataTemplate;
    set legendItemBadgeTemplate(a: DataTemplate);
    static readonly t2: DependencyProperty;
    sw: DataTemplate;
    private sy;
    vc: Brush;
    vb: Brush;
    c1: StandardLegendItems;
    c0: StandardLegendItems;
    legendItemBadgeShape: LegendItemBadgeShape;
    bd: LegendItemBadgeMode;
    get legendItemTemplate(): DataTemplate;
    set legendItemTemplate(a: DataTemplate);
    static readonly t3: DependencyProperty;
    get sx(): DataTemplate;
    set sx(a: DataTemplate);
    static readonly tj: DependencyProperty;
    get index(): number;
    set index(a: number);
    static readonly tu: DependencyProperty;
    sp(): void;
    pj(a: string): void;
    protected fh(a: string, b: string, c: Brush, d: Brush): boolean;
    protected sh(): void;
    dd: (time: number) => number;
    de: (time: number) => number;
    df: (time: number) => number;
    ea: boolean;
    kd: number;
    jq: number;
    d3(): boolean;
    r7(): void;
    private dx;
    private h2;
    get id(): number;
    set id(a: number);
    protected jk(): number;
    jj: number;
    private h6;
    protected get ij(): number;
    protected set ij(a: number);
    ju: number;
    private h3;
    protected get ig(): number;
    protected set ig(a: number);
    rw(): void;
    jr: number;
    private h4;
    protected get ih(): number;
    protected set ih(a: number);
    js: number;
    private h5;
    protected get ii(): number;
    protected set ii(a: number);
    jt: number;
    title: any;
    mh: string;
    wx: Visibility;
    vf: Brush;
    u9: Brush;
    vg: Brush;
    vi: Brush;
    vz: Brush;
    vk: Brush;
    ve: Brush;
    vj: Brush;
    va: Brush;
    vh: Brush;
    safeActualBrush: Brush;
    vv: Brush;
    vd: Brush;
    v5: PenLineJoin;
    bv: SeriesHighlightedValuesDisplayMode;
    gg: boolean;
    jh: number;
    jp: number;
    ie: number;
    il: number;
    v3: PenLineCap;
    v2: DoubleCollection;
    toolTip: any;
    private bw;
    get bx(): SeriesHighlightingMode;
    set bx(a: SeriesHighlightingMode);
    private cn;
    get cp(): SeriesSelectionMode;
    set cp(a: SeriesSelectionMode);
    private cm;
    get co(): SeriesSelectionMode;
    set co(a: SeriesSelectionMode);
    protected get_ge(): boolean;
    get ge(): boolean;
    pu(): void;
    protected by(): SeriesHighlightingMode;
    protected cr(): SeriesSelectionMode;
    protected cq(): SeriesSelectionMode;
    protected fz(a: SeriesHighlightingMode): boolean;
    private h0;
    get ia(): number;
    set ia(a: number);
    je: number;
    private h1;
    get ib(): number;
    set ib(a: number);
    jf: number;
    en: boolean;
    e0: boolean;
    fd: boolean;
    g9: boolean;
    protected d2: boolean;
    private dw;
    protected pe(): void;
    private ef;
    protected pt(): void;
    private rg;
    hu: List$1<UIElement>;
    gu(a: Series): boolean;
    private pa;
    protected kt(a: number): any;
    protected ks(a: number, b: boolean): any;
    protected ku(a: number): any;
    protected get_isColoredItemwise(): boolean;
    get isColoredItemwise(): boolean;
    gl: boolean;
    gj: boolean;
    gi: boolean;
    e4: boolean;
    protected get_e5(): boolean;
    get e5(): boolean;
    jm: number;
    v1: Color;
    hc: boolean;
    jn: number;
    jo: number;
    ik: number;
    h9: number;
    sd(): void;
    jg: number;
    ic: number;
    sf(): void;
    se(): void;
    protected jl(): number;
    private du;
    get e3(): boolean;
    set e3(a: boolean);
    gp: boolean;
    private cw;
    get cx(): SeriesVisibleRangeMode;
    set cx(a: SeriesVisibleRangeMode);
    cy(): SeriesVisibleRangeMode;
    cz: SeriesVisibleRangeMode;
    private cg;
    get ch(): SeriesOutlineMode;
    set ch(a: SeriesOutlineMode);
    cj(): SeriesOutlineMode;
    ci: SeriesOutlineMode;
    a3(a: any): DataContext;
    ke: number;
    kf: number;
    c5: TransitionInSpeedType;
    c8: TransitionOutSpeedType;
    protected c4(): TransitionInSpeedType;
    protected c7(): TransitionOutSpeedType;
    kl: any;
    rp(): void;
    protected d9: boolean;
    rv(): void;
    q7(): void;
    q6(): void;
    q8(): void;
    rn(): void;
    o2(): void;
    qb(): void;
    private static _hq;
    static hq(a: (arg1: number) => number, b: number, c: number): IEnumerable$1<number>;
    static hp(a: (arg1: number) => number, b: number): IEnumerable$1<number>;
    v4: PenLineCap;
    private bq;
    br(): SeriesComponentsForView;
    lu: string;
    ag: any[];
    lx: string;
    ah: any[];
    r2(a: Canvas): void;
    i9(): number;
    ja(): number;
    jb(): number;
    private d1;
    protected get_g7(): boolean;
    protected set_g7(a: boolean): void;
    protected get g7(): boolean;
    protected set g7(a: boolean);
    get gh(): boolean;
    f8: boolean;
    o3(): void;
    dg(a: any, b: Point, c: boolean): HighlightingInfo;
    dh(a: any, b: Point, c: boolean): HighlightingInfo;
    qu(a: Point, b: any, c: any, d: boolean): void;
    r6(a: Point): void;
    private ox;
    private o4;
    ow(a: IChartLegend, b: IChartLegend): void;
    private oy;
    rj(a: IFastItemsSourceProvider): void;
    ri(a: IFastItemsSourceProvider): void;
    protected a6(): IChartLegend;
    protected gn(): boolean;
    protected go(): boolean;
    gf(a: boolean): boolean;
    protected pc(a: Axis): void;
    protected rh(a: Axis): void;
    bs(): SeriesComponentsFromView;
    sj(a: Canvas): void;
    r5(a: Point, b: (arg1: any) => void): void;
    protected get_ha(): boolean;
    get ha(): boolean;
    ra(a: RenderingContext, b: RenderingContext): void;
    rc(a: Rect): void;
    p6(a: NotifyCollectionChangedEventArgs): void;
    qj(a: number, b: any, c: any): void;
    qe(): void;
    qh(a: number, b: any): void;
    qi(a: number, b: any): void;
    sc(): void;
    k2: any;
    jx: (arg1: any) => any;
    gw(a: Point, b: boolean): boolean;
    protected _coercionMethods: any;
    protected get_coercionMethods(): any;
    protected set_coercionMethods(a: any): void;
    get coercionMethods(): any;
    set coercionMethods(a: any);
    private dt;
    protected get_expectFunctions(): boolean;
    protected set_expectFunctions(a: boolean): void;
    get expectFunctions(): boolean;
    set expectFunctions(a: boolean);
    a2(a: Point, b: boolean): DataContext;
    private b0;
    get b3(): SeriesHitTestMode;
    set b3(a: SeriesHitTestMode);
    protected b2(): SeriesHitTestMode;
    private bz;
    get b1(): SeriesHitTestMode;
    set b1(a: SeriesHitTestMode);
    protected dk(a: string): IFastItemColumn$1<number>;
    protected dl(a: string): IFastItemColumn$1<number>;
    protected dm(a: string): IFastItemColumn$1<any>;
    protected get ws(): Rect;
    protected get_fm(): boolean;
    get fm(): boolean;
    protected get_fl(): boolean;
    get fl(): boolean;
    r4(a: boolean): void;
    r3(a: Brush, b: Brush): void;
    ds: (arg1: SeriesViewer) => void;
    protected o8(a: any, b: any): void;
    km(): any;
    protected pz(a: any): void;
    private v6;
    qc(a: Point): void;
    protected qr(a: Point): void;
    qd(): void;
    qk(): void;
    aw(a: Axis): Axis;
    ai(): Axis[];
    iy(): number;
    static iz(a: IFastItemColumn$1<number>, b: ISortingAxis): number;
    static i0(a: IList$1<number>, b: ISortingAxis): number;
    qp(): void;
    private h7;
    get im(): number;
    set im(a: number);
    private h8;
    get ji(): number;
    set ji(a: number);
    protected sn(): void;
    kp(a: any): any;
    get lk(): string;
    get k6(): string;
    get k9(): string;
    get li(): string;
    get ls(): string;
    get lr(): string;
    get lm(): string;
    protected si(): void;
    av(): ActualLegendItemBadgeShape;
    protected be(a: LegendItemBadgeShape): LegendItemBadgeShape;
    private bf;
    private hl;
    private hr;
    protected bj(): Series;
    protected bl(): Series;
    b5: SeriesLayer;
    get cb(): SeriesLayerCollection;
    private b8;
    get ca(): SeriesLayerCollection;
    private b7;
    get actualLayers(): SeriesLayerCollection;
    private b6;
    private ho;
    protected get ec(): boolean;
    bn: Series;
    bk: Series;
    protected r1(a: Series, b: Series): void;
    private hm;
    r9(a: string): void;
    sb(a: string): void;
    f4(a: string): boolean;
    private hi;
    r8(a: string): void;
    sa(a: string, b: boolean): void;
    gm(a: string): boolean;
    f2(): boolean;
    kv(): any;
    bm(a: number, b: SeriesLayer): Series;
    protected qa(a: Series): void;
    private o0;
    private pd;
    protected ru(a: Series): void;
    f9(a: DependencyProperty): boolean;
    gq(a: DependencyProperty): boolean;
    private o7;
    private kj;
    ph(a: SeriesLayer): void;
    getDataLegendBadge(): DataTemplate;
    private a8;
    getDataLegendBadgeContext(): any;
    getDataLegendBadgeContextAtPosition(a: number, b: number): any;
    getDataLegendBadgeShapeAndMarker(): string;
    ma(): string;
    mb(a: Series, b: DataTemplate): string;
    getDataLegendSeriesTitle(): string;
    ix(a: any, b: string): number;
    getDataLegendResolvedWorldPositionX(a: number): number;
    getDataLegendResolvedWorldPositionY(a: number): number;
    getDataLegendSeriesContextAt(a: number, b: number): any;
    mc(): string;
    getDataLegendAxisLabelFromCursorPosition(a: number, b: number): any;
    private hz;
    v0(a: Brush): Brush;
    cf(): SeriesMatcher;
    private f7;
    static $$p: string[];
}
/**
 * @hidden
 */
export declare abstract class MarkerSeries extends Series {
    static $t: Type;
    w6: MarkerSeriesView;
    constructor();
    protected ht(): List$1<SeriesLayerPropertyOverlay>;
    wv(a: SeriesPlotAreaMarginHorizontalMode, b: SeriesPlotAreaMarginVerticalMode): Thickness;
    q1(a: SeriesView): void;
    protected get_hasMarkers(): boolean;
    protected get_el(): boolean;
    vl(): Brush;
    vm(): Brush;
    sz(): DataTemplate;
    ma(): string;
    xa: MarkerType;
    private w7;
    get w8(): MarkerType;
    set w8(a: MarkerType);
    private w9;
    private xf;
    private xe;
    pu(): void;
    xd: boolean;
    get xc(): boolean;
    private w2;
    get w3(): MarkerOutlineMode;
    set w3(a: MarkerOutlineMode);
    w5(): MarkerOutlineMode;
    sl(a: MarkerOutlineMode): void;
    w4: MarkerOutlineMode;
    private wy;
    get wz(): MarkerFillMode;
    set wz(a: MarkerFillMode);
    w1(): MarkerFillMode;
    sk(a: MarkerFillMode): void;
    sm(a: number): void;
    w0: MarkerFillMode;
    x2: DataTemplate;
    xj: number;
    io(): number;
    x0: DataTemplate;
    x1: DataTemplate;
    private static xz;
    static get x3(): DataTemplate;
    get yj(): Brush;
    set yj(a: Brush);
    static readonly x8: DependencyProperty;
    yh: Brush;
    yk: Brush;
    yi: Brush;
    yl: Style;
    xi: boolean;
    xg(): boolean;
    protected qs(): void;
    protected q9(a: any, b: string, c: any, d: any): void;
    static xo(a: MarkerType): string;
    static xb(a: Series, b: MarkerType): MarkerType;
    protected vo(a: number): Brush;
    protected vp(a: number): Brush;
    protected sh(): void;
    protected pz(a: any): void;
    protected xh(a: Point, b: boolean): boolean;
    a2(a: Point, b: boolean): DataContext;
    static $$p: string[];
}
/**
 * @hidden
 */
export declare class SyncLink extends FrameworkElement implements INotifyPropertyChanged, IFastItemsSourceProvider {
    static $t: Type;
    constructor();
    ak: string;
    protected aq(a: any, b: string, c: any, d: any): void;
    releaseFastItemsSource(a: IEnumerable): IFastItemsSource;
    static aj: (arg1: IEnumerable) => IFastItemsSource;
    private static af;
    getFastItemsSource(a: IEnumerable): IFastItemsSource;
    ag(a: IEnumerable): IFastItemsSource;
    private ah;
    av: Rect;
    private aw;
    private ax;
    private ab;
    private ac;
    get ai(): IList$1<SeriesViewer>;
    private ad;
    al(a: SeriesViewer): void;
    as(a: SeriesViewer): void;
    private ao;
    private am;
    an(a: SeriesViewer, b: Point): void;
    ap(a: SeriesViewer, b: Rect): void;
    at(a: SeriesViewer, b: Rect): void;
    au(a: SeriesViewer, b: Rect, c: boolean): void;
    propertyChanged: (sender: any, e: PropertyChangedEventArgs) => void;
    propertyUpdated: (sender: any, e: PropertyUpdatedEventArgs) => void;
    protected ar(a: string, b: any, c: any): void;
}
/**
 * @hidden
 */
export declare class SyncLinkManager extends Base {
    static $t: Type;
    private static b;
    static instance(): SyncLinkManager;
    private d;
    get e(): number;
    constructor();
    getLink(a: string): SyncLink;
    releaseLink(a: SyncLink): void;
}
/**
 * @hidden
 */
export declare class SyncManager extends Base {
    static $t: Type;
    static e(a: SeriesViewer): void;
    static c(a: SeriesViewer): void;
    static b(a: SeriesViewer, b: string, c: string): void;
    static d(a: DependencyObject, b: SyncSettings): void;
    static a(a: DependencyObject): SyncSettings;
}
/**
 * @hidden
 */
export declare class ChartCollection extends ObservableCollection$1<SeriesViewer> {
    static $t: Type;
    constructor();
    collectionResetting: (sender: any, e: EventArgs) => void;
    protected p(): void;
}
/**
 * @hidden
 */
export declare class SeriesCollection extends ObservableCollection$1<Series> {
    static $t: Type;
    constructor();
    collectionResetting: (sender: any, e: EventArgs) => void;
    protected p(): void;
}
/**
 * @hidden
 */
export declare class PlotAreaMouseEventArgs extends EventArgs {
    static $t: Type;
    constructor(a: SeriesViewer, b: Point, c: Point);
    private _chartPosition;
    get chartPosition(): Point;
    set chartPosition(a: Point);
    private _plotAreaPosition;
    get plotAreaPosition(): Point;
    set plotAreaPosition(a: Point);
    private _isDuringManipulation;
    get isDuringManipulation(): boolean;
    set isDuringManipulation(a: boolean);
    private _viewer;
    get viewer(): SeriesViewer;
    set viewer(a: SeriesViewer);
}
/**
 * @hidden
 */
export declare class PlotAreaMouseButtonEventArgs extends EventArgs {
    static $t: Type;
    constructor(a: SeriesViewer, b: Point, c: Point);
    private _chartPosition;
    get chartPosition(): Point;
    set chartPosition(a: Point);
    private _plotAreaPosition;
    get plotAreaPosition(): Point;
    set plotAreaPosition(a: Point);
    private _manipulationOccurred;
    get manipulationOccurred(): boolean;
    set manipulationOccurred(a: boolean);
    private _viewer;
    get viewer(): SeriesViewer;
    set viewer(a: SeriesViewer);
}
/**
 * @hidden
 */
export declare class ChartCursorEventArgs extends EventArgs {
    static $t: Type;
    constructor(a: SeriesViewer, b: Series, c: any);
    toString(): string;
    private _item;
    get item(): any;
    set item(a: any);
    private _series;
    get series(): Series;
    set series(a: Series);
    private _seriesViewer;
    get seriesViewer(): SeriesViewer;
    set seriesViewer(a: SeriesViewer);
    get chart(): XamDataChart;
}
/**
 * @hidden
 */
export declare class SeriesViewerSelectedSeriesItemsChangedEventArgs extends EventArgs {
    static $t: Type;
    private _oldItems;
    get oldItems(): ChartSelectedItemCollection;
    set oldItems(a: ChartSelectedItemCollection);
    private _newItems;
    get newItems(): ChartSelectedItemCollection;
    set newItems(a: ChartSelectedItemCollection);
    private _currentItems;
    get currentItems(): ChartSelectedItemCollection;
    set currentItems(a: ChartSelectedItemCollection);
    constructor(a: ChartSelectedItemCollection, b: ChartSelectedItemCollection, c: ChartSelectedItemCollection);
}
/**
 * @hidden
 */
export declare class DataChartMouseButtonEventArgs extends EventArgs {
    static $t: Type;
    private j;
    constructor(a: SeriesViewer, b: Series, c: any, d: MouseButtonEventArgs, e: Point);
    toString(): string;
    protected i: MouseButtonEventArgs;
    get handled(): boolean;
    set handled(a: boolean);
    private d;
    get cancelSelection(): boolean;
    set cancelSelection(a: boolean);
    getPosition(a: UIElement): Point;
    get originalSource(): any;
    private _item;
    get item(): any;
    set item(a: any);
    private _series;
    get series(): Series;
    set series(a: Series);
    private _plotAreaPosition;
    get plotAreaPosition(): Point;
    set plotAreaPosition(a: Point);
    get chartPosition(): Point;
    private _chart;
    get chart(): SeriesViewer;
    set chart(a: SeriesViewer);
}
/**
 * @hidden
 */
export declare class ChartMouseEventArgs extends EventArgs {
    static $t: Type;
    constructor(a: SeriesViewer, b: Series, c: any, d: MouseEventArgs, e: Point);
    toString(): string;
    private f;
    getPosition(a: UIElement): Point;
    get originalSource(): any;
    private _item;
    get item(): any;
    set item(a: any);
    private _series;
    get series(): Series;
    set series(a: Series);
    private _plotAreaPosition;
    get plotAreaPosition(): Point;
    set plotAreaPosition(a: Point);
    private g;
    get chartPosition(): Point;
    private _chart;
    get chart(): SeriesViewer;
    set chart(a: SeriesViewer);
}
/**
 * @hidden
 */
export declare class AxisComponentsForView extends Base {
    static $t: Type;
    a: AxisLabelPanelBase;
}
/**
 * @hidden
 */
export declare class AxisLabelPanelBaseView extends Base {
    static $t: Type;
    protected a: AxisLabelPanelBase;
    aw: Path;
    constructor(a: AxisLabelPanelBase);
    aa(a: FrameworkElement, b: Rect, c: number, d: number, e: number, f: number): void;
    z(a: Rectangle, b: TextBlock, c: LabelPosition, d: Rect, e: number, f: number, g: number, h: number): void;
    ae(a: FrameworkElement): void;
    ah(a: any): void;
    ai(a: any, b: Size): void;
    aj(a: FrameworkElement, b: number): void;
    ar(a: Rectangle, b: TextBlock, c: LabelPosition, d: Rect, e: number, f: number, g: number, h: number, i: number): void;
    ad(a: Rectangle): void;
    x(a: TextBlock, b: number, c: number, d: number): string;
    af(): void;
    g(): IEnumerable$1<any>;
    l(a: any): number;
    n(a: any): number;
    an(): void;
    m(a: any): number;
    w(a: any): number;
    ax(a: any): Size;
    ac(): void;
    ak(): void;
    protected e: RenderingContext;
    f(): RenderingContext;
    al(a: RenderingContext): void;
    y(): void;
    protected am(): void;
    private av;
    protected ap(a: TextBlock): void;
    ao(): void;
    d(): FontInfo;
    at(): Brush;
    private c;
    ag(): void;
    private h;
    private as;
    private i;
    j(): number;
    k(): number;
    protected aq(): void;
    ab(a: Size): void;
    protected ay(): Thickness;
    v(): number;
    s(): number;
    t(): number;
    u(): number;
    au(): GeometryCollection;
    b(): PathRenderingInfo;
    r(): number;
    p(): number;
    q(): number;
    o(): number;
}
/**
 * @hidden
 */
export declare class AxisView extends Base implements ISchedulableRender {
    static $t: Type;
    protected a: Axis;
    constructor(a: Axis);
    al(): void;
    an(a: any): void;
    bd: Path;
    be: Path;
    bg: Path;
    bf: Path;
    a3(): TextBlock;
    aw(a: TextBlock): void;
    ay(a: TextBlock): void;
    ax(a: TextBlock): void;
    bi(): Rectangle;
    t(a: Rectangle): void;
    v(a: Rectangle): void;
    u(a: Rectangle): void;
    ao(): void;
    p(): boolean;
    get index(): number;
    ai(): void;
    ag(): void;
    ac(): void;
    a1(a: Visibility): void;
    at(): void;
    ab(a: AxisLabelSettings): void;
    private b;
    c(): AxisComponentsFromView;
    ae(a: GeometryCollection): void;
    a4(): GeometryCollection;
    e(): PathRenderingInfo;
    a7(): GeometryCollection;
    a5(): GeometryCollection;
    f(): PathRenderingInfo;
    a6(): GeometryCollection;
    g(): PathRenderingInfo;
    protected get d(): AxisLabelPanelBase;
    az(a: Axis, b: Rect, c: Rect): void;
    ad(): void;
    av(a: number): void;
    a0(a: List$1<any>, b: List$1<LabelPosition>): void;
    au(a: number): void;
    aa(): void;
    private h;
    s(a: number): string;
    z(): void;
    aq(): void;
    l(): boolean;
    protected o(): boolean;
    m(): boolean;
    protected r(dataItem_: any): string;
    q(dataItem_: any): any;
    protected k: RenderingContext;
    j: RenderingContext;
    ak(a: RenderingContext, b: RenderingContext): void;
    private _isDirty;
    get isDirty(): boolean;
    set isDirty(a: boolean);
    protected aj(): void;
    undirty(a: boolean): void;
    private bh;
    protected ar(a: boolean): void;
    postRender(): void;
    private bb;
    protected as(): void;
    ah(): void;
    af(a: SeriesViewer): void;
    y(a: SeriesViewer): void;
    i(): FontInfo;
    n(): boolean;
    ap(): void;
    x(): void;
    a2(): void;
    w(a: AxisLabelSettings, b: string): void;
    preRender(): void;
    isValid(): boolean;
    a8(a: TextBlock): Point;
    a9(): Point;
    bc(): Rect;
    ba(a: TextBlock): Point;
    bj(a: TextBlock): Thickness;
    am(): void;
}
/**
 * @hidden
 */
export declare class CategoryAxisBaseView extends AxisView {
    static $t: Type;
    protected bk: CategoryAxisBase;
    constructor(a: CategoryAxisBase);
    s(a: number): string;
    bl(a: List$1<any>): number;
}
/**
 * @hidden
 */
export declare class HorizontalAxisLabelPanelBaseView extends AxisLabelPanelBaseView {
    static $t: Type;
    protected az: HorizontalAxisLabelPanelBase;
    constructor(a: HorizontalAxisLabelPanelBase);
    a1(): void;
    a0(): boolean;
    a2(a: List$1<Rect>): void;
}
/**
 * @hidden
 */
export declare class NumericAxisBaseView extends AxisView {
    static $t: Type;
    protected bk: NumericAxisBase;
    constructor(a: NumericAxisBase);
    bl(): void;
    protected o(): boolean;
    m(): boolean;
    protected r(dataItem_: any): string;
    s(a: number): string;
}
/**
 * @hidden
 */
export declare class VerticalAxisLabelPanelView extends AxisLabelPanelBaseView {
    static $t: Type;
    protected az: VerticalAxisLabelPanel;
    constructor(a: VerticalAxisLabelPanel);
    a0(): void;
    d(): FontInfo;
    protected ay(): Thickness;
    at(): Brush;
    a1(a: List$1<Rect>, b: number): void;
}
/**
 * @hidden
 */
export declare class XamDataChartView extends SeriesViewerView {
    static $t: Type;
    constructor(a: XamDataChart);
    protected fn: XamDataChart;
    fr(a: any): void;
    protected ds(): void;
    d4(): void;
    fw: Brush;
    fs: Brush;
    ft: Brush;
    fv: Brush;
    fu: Brush;
    fp: number;
    fq: number;
    protected d1(): void;
    fo: FontInfo;
}
/**
 * @hidden
 */
export declare class SeriesView extends Base implements ISchedulableRender, IProvidesViewport {
    static $t: Type;
    protected e: Series;
    s: boolean;
    constructor(a: Series);
    getDefaultTooltipTemplate(): string;
    ar(): void;
    j(): IExecutionContext;
    private h;
    protected get i(): IExecutionContext;
    ah(a: number, b: Series): void;
    am(a: Series): void;
    d: DataContext;
    au(): void;
    getEffectiveViewport(): Rect;
    a1(): void;
    ak(): void;
    getMainContentViewport(): Rect;
    get w(): DomRenderer;
    private _isDirty;
    get isDirty(): boolean;
    set isDirty(a: boolean);
    protected get_index(): number;
    get index(): number;
    protected as(): void;
    undirty(a: boolean): void;
    private bz;
    aw(): void;
    private bp;
    bt(): Brush;
    bq(a: Brush): Brush;
    v: number;
    private u;
    protected a6(a: boolean): void;
    private bu;
    protected bf(a: any, b: number, c: boolean): void;
    protected bi(a: any, b: number, c: boolean): void;
    protected aa(a: number, b: boolean): any;
    protected ab(a: number): any;
    protected ac(a: number): any;
    protected bg(a: any, b: number): void;
    protected bj(a: any, b: number): void;
    protected bh(a: any, b: number): void;
    protected bk(a: any, b: number): void;
    protected bc(a: boolean): void;
    protected bd(): void;
    protected be(): void;
    private bo;
    protected bs(a: number): Brush;
    protected br(): Brush;
    protected a8(a: RenderingContext, b: boolean): void;
    protected a7(a: RenderingContext, b: boolean): void;
    az(): void;
    ao(): void;
    ap(): void;
    private f;
    g(): SeriesComponentsFromView;
    bb(a: Canvas): void;
    t(): boolean;
    ay(): void;
    ax(): void;
    a9(): void;
    ai(): void;
    ba(): void;
    aj(): void;
    c(a: any): DataContext;
    protected k: RenderingContext;
    protected l: RenderingContext;
    at(a: RenderingContext, b: RenderingContext): void;
    private bv;
    get bx(): Rect;
    set bx(a: Rect);
    bw: Rect;
    protected get_by(): Rect;
    get by(): Rect;
    private m;
    get q(): boolean;
    set q(a: boolean);
    al(a: SeriesViewer): void;
    a: CanvasRenderScheduler;
    ag(a: SeriesViewer): void;
    postRender(): void;
    protected a2(): void;
    b(a: number): DataContext;
    a4(a: RenderSurface): void;
    an(a: any): void;
    bl(): void;
    av(): void;
    a0(): void;
    getViewInfo(a: Rect, b: Rect): {
        p0: Rect;
        p1: Rect;
    };
    o(): boolean;
    protected r: boolean;
    bm(): void;
    a5(): void;
    protected af(): void;
    aq(): void;
    preRender(): void;
    isValid(): boolean;
    n: boolean;
    p: boolean;
    a3(a: RenderSurface): void;
    ad: string;
    bn(type_: StandardLegendItems): DataTemplate;
}
/**
 * @hidden
 */
export declare abstract class MarkerSeriesView extends SeriesView {
    static $t: Type;
    protected b4: MarkerSeries;
    private b9;
    private cb;
    private ca;
    constructor(a: MarkerSeries);
    au(): void;
    cl(): void;
    cv(): Size;
    cs(a: boolean): void;
    protected b8: List$1<Marker>;
    b3(): Marker;
    abstract cj(a: (arg1: Marker) => void): void;
    ck(a: (arg1: Marker) => void): void;
    co(a: Marker): void;
    cq(a: Marker): void;
    cp(a: Marker): void;
    b5(): boolean;
    ci(): void;
    cc(): void;
    cu(a: Marker): Rect;
    cf(a: string): void;
    cg(): void;
    cd(): void;
    ch(): void;
    ce(): void;
    cr(): void;
    b7: boolean;
    protected bj(a: any, b: number): void;
    private b0;
    protected bk(a: any, b: number): void;
    b(a: number): DataContext;
    private ct;
    protected a7(a: RenderingContext, b: boolean): void;
    cm(a: HashPool$2<any, Marker>): void;
    cn(a: Pool$1<Marker>): void;
    b1(a: Point): Marker;
    private b2;
    private b6;
}
/**
 * @hidden
 */
export declare class ChartAxisRangeChangedEventArgs extends EventArgs {
    static $t: Type;
    constructor(a: SeriesViewer, b: Axis, c: number, d: number, e: number, f: number);
    private _chart;
    get chart(): SeriesViewer;
    set chart(a: SeriesViewer);
    private _axis;
    get axis(): Axis;
    set axis(a: Axis);
    private _oldMinimumValue;
    get oldMinimumValue(): number;
    set oldMinimumValue(a: number);
    private _minimumValue;
    get minimumValue(): number;
    set minimumValue(a: number);
    private _oldMaximumValue;
    get oldMaximumValue(): number;
    set oldMaximumValue(a: number);
    private _maximumValue;
    get maximumValue(): number;
    set maximumValue(a: number);
}
