import { IgrCalculatedColumn } from './igr-calculated-column';
import { FinancialCalculationDataSource as FinancialCalculationDataSource_internal } from "./FinancialCalculationDataSource";
/**
 * Represents the data contract between a financial series and the
 * decoupled calculation responsibilities which implement its mathmatical logic.
 * The FinancialCalculationDataSource contract represents the subset
 * of data which needs to be provided in order to test or run a calculation,
 * and its intentionally a subset of the information available to the series,
 * in order to make calculation strategies more easily testable and usable in isolation to
 * the financial series container.
*/
export declare class IgrFinancialCalculationDataSource {
    protected createImplementation(): FinancialCalculationDataSource_internal;
    protected _implementation: any;
    get i(): FinancialCalculationDataSource_internal;
    private onImplementationCreated;
    constructor();
    protected _provideImplementation(i: any): void;
    get openColumn(): number[];
    get highColumn(): number[];
    get lowColumn(): number[];
    get closeColumn(): number[];
    get volumeColumn(): number[];
    get indicatorColumn(): any;
    /**
 * An enumerable list of typical prices provided by the series to use
 * in calculations.
*/
    get typicalColumn(): IgrCalculatedColumn;
    set typicalColumn(v: IgrCalculatedColumn);
    /**
     * And enumerable list of true range values provided by the series to use
     * in calculations.
    */
    get trueRange(): IgrCalculatedColumn;
    set trueRange(v: IgrCalculatedColumn);
    /**
     * An enumerable list of true low values provided by the series to use
     * in calculations.
    */
    get trueLow(): IgrCalculatedColumn;
    set trueLow(v: IgrCalculatedColumn);
    /**
     * The period to use when calculating, if applicable.
    */
    get period(): number;
    set period(v: number);
    /**
     * The short period to use when calculating, if applicable.
    */
    get shortPeriod(): number;
    set shortPeriod(v: number);
    /**
     * The long period to use when calculating, if applicable.
    */
    get longPeriod(): number;
    set longPeriod(v: number);
    /**
     * The count of the values in the series.
    */
    get count(): number;
    set count(v: number);
    /**
     * The starting index from which to calculate
    */
    get calculateFrom(): number;
    set calculateFrom(v: number);
    /**
     * The number of items from the starting index from which to calculate
    */
    get calculateCount(): number;
    set calculateCount(v: number);
    /**
     * If the calculation supports some sort of scaling factor,
     * this value will be used.
    */
    get multiplier(): number;
    set multiplier(v: number);
    /**
     * If the calculation determines the range of indicator values,
     * it will set the minimum and maximux properties.
     * This will contain the previous minimum value when the indicator
     * calculation is called again, in case this makes the update of the
     * value speedier.
    */
    get minimumValue(): number;
    set minimumValue(v: number);
    /**
     * If the calculation determines the range of indicator values,
     * it will set the minimum and maximux properties.
     * This will contain the previous minimum value when the indicator
     * calculation is called again, in case this makes the update of the
     * value speedier.
    */
    get maximumValue(): number;
    set maximumValue(v: number);
    /**
     * The calculation strategy should set this to true if it
     * specifes the minimum and maximum value properties.
    */
    get specifiesRange(): boolean;
    set specifiesRange(v: boolean);
    findByName(name: string): any;
}
