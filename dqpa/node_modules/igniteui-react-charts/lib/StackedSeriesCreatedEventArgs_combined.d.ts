import { EventArgs, Base, Type, Point, IList$1, IEnumerable, IEnumerator$1, IEnumerator, INotifyPropertyChanged, PropertyChangedEventArgs } from "igniteui-react-core";
import { Brush } from "igniteui-react-core";
import { DataTemplate } from "igniteui-react-core";
import { Visibility } from "igniteui-react-core";
import { DoubleCollection } from "igniteui-react-core";
import { PenLineCap } from "igniteui-react-core";
import { Style } from "igniteui-react-core";
import { MarkerType } from "./MarkerType";
import { HorizontalAnchoredCategorySeries } from "./HorizontalAnchoredCategorySeries";
import { CategoryLineRasterizer } from "./CategoryLineRasterizer";
import { Series } from "./Series";
import { List$1 } from "igniteui-react-core";
import { AnchoredCategorySeries } from "./AnchoredCategorySeries";
import { CategoryAxisBase } from "./CategoryAxisBase";
import { CategorySeries } from "./CategorySeries";
import { CategoryFramePreparer } from "./CategoryFramePreparer";
import { NumericAxisBase } from "./NumericAxisBase";
import { ISupportsMarkers } from "./ISupportsMarkers";
import { CategoryFrame } from "./CategoryFrame";
import { IDetectsCollisions } from "./IDetectsCollisions";
import { Rect } from "igniteui-react-core";
import { CategorySeriesView } from "./CategorySeriesView";
import { SeriesView } from "./SeriesView";
import { Axis } from "./Axis";
import { SeriesViewer } from "./SeriesViewer";
import { PointCollection } from "igniteui-react-core";
import { ObservableCollection$1 } from "igniteui-react-core";
import { IFastItemColumn$1 } from "igniteui-react-core";
import { AxisRange } from "./AxisRange";
import { IChartLegend } from "igniteui-react-core";
import { AnchoredCategorySeriesView } from "./AnchoredCategorySeriesView";
import { CategoryBucketCalculator } from "./CategoryBucketCalculator";
import { RenderSurface } from "./RenderSurface";
import { CategoryTransitionInMode } from "./CategoryTransitionInMode";
import { Path } from "igniteui-react-core";
import { CategoryMode } from "./CategoryMode";
import { DependencyObject } from "igniteui-react-core";
import { NumericYAxis } from "./NumericYAxis";
import { Pool$1 } from "igniteui-react-core";
import { Rectangle } from "igniteui-react-core";
import { IScaler } from "./IScaler";
import { IIsCategoryBased } from "./IIsCategoryBased";
import { NumericXAxis } from "./NumericXAxis";
import { CategoryYAxis } from "./CategoryYAxis";
import { AnchoredCategoryBucketCalculator } from "./AnchoredCategoryBucketCalculator";
import { SplineSeriesBase } from "./SplineSeriesBase";
import { CollisionAvoider } from "./CollisionAvoider";
import { ICategoryScaler } from "./ICategoryScaler";
import { IBucketizer } from "./IBucketizer";
import { FastItemsSourceEventAction } from "igniteui-react-core";
import { ValueCollisionMode } from "./ValueCollisionMode";
import { ChartSelection } from "./ChartSelection";
import { SeriesSelectionBehavior } from "./SeriesSelectionBehavior";
import { SeriesPlotAreaMarginHorizontalMode } from "./SeriesPlotAreaMarginHorizontalMode";
import { SeriesPlotAreaMarginVerticalMode } from "./SeriesPlotAreaMarginVerticalMode";
import { IBarSeries } from "./IBarSeries";
import { Color } from "igniteui-react-core";
import { LegendItemBadgeShape } from "igniteui-react-core";
import { LegendItemBadgeMode } from "igniteui-react-core";
import { MarkerFillMode } from "./MarkerFillMode";
import { MarkerOutlineMode } from "./MarkerOutlineMode";
import { SeriesOutlineMode } from "./SeriesOutlineMode";
import { SeriesHighlightedValuesDisplayMode } from "igniteui-react-core";
import { TransitionInSpeedType } from "./TransitionInSpeedType";
import { DomRenderer } from "igniteui-react-core";
import { PropertyUpdatedEventArgs } from "igniteui-react-core";
import { SeriesPointOfInterest } from "./SeriesPointOfInterest";
import { IProvidesViewport } from "./IProvidesViewport";
import { ISupportsErrorBars } from "./ISupportsErrorBars";
import { ValuesHolder } from "./ValuesHolder";
import { PreparationParams } from "./PreparationParams";
import { RenderingContext } from "igniteui-react-core";
import { SplineSeriesBaseView } from "./SplineSeriesBaseView";
import { Canvas } from "igniteui-react-core";
import { Panel } from "igniteui-react-core";
/**
 * @hidden
 */
export declare class StackedSeriesCreatedEventArgs extends EventArgs {
    static $t: Type;
    constructor(a: StackedFragmentSeries);
    c: StackedFragmentSeries;
    get brush(): Brush;
    set brush(a: Brush);
    get legendItemTemplate(): DataTemplate;
    set legendItemTemplate(a: DataTemplate);
    get legendItemBadgeTemplate(): DataTemplate;
    set legendItemBadgeTemplate(a: DataTemplate);
    get legendItemVisibility(): Visibility;
    set legendItemVisibility(a: Visibility);
    get outline(): Brush;
    set outline(a: Brush);
    get dashArray(): DoubleCollection;
    set dashArray(a: DoubleCollection);
    get dashCap(): PenLineCap;
    set dashCap(a: PenLineCap);
    get index(): number;
    get thickness(): number;
    set thickness(a: number);
    get title(): any;
    set title(a: any);
    get transitionDuration(): number;
    set transitionDuration(a: number);
    get transitionEasingFunction(): (time: number) => number;
    set transitionEasingFunction(a: (time: number) => number);
    get markerBrush(): Brush;
    set markerBrush(a: Brush);
    get markerOutline(): Brush;
    set markerOutline(a: Brush);
    get markerStyle(): Style;
    set markerStyle(a: Style);
    get markerTemplate(): DataTemplate;
    set markerTemplate(a: DataTemplate);
    get markerType(): MarkerType;
    set markerType(a: MarkerType);
    get markerThickness(): number;
    set markerThickness(a: number);
    get lineCap(): PenLineCap;
    set lineCap(a: PenLineCap);
}
/**
 * @hidden
 */
export declare abstract class FragmentBase extends HorizontalAnchoredCategorySeries {
    static $t: Type;
    private ___neverPassByValue;
    constructor();
    acx: CategoryLineRasterizer;
    private _logicalSeriesLink;
    get logicalSeriesLink(): StackedFragmentSeries;
    set logicalSeriesLink(a: StackedFragmentSeries);
    private acz;
    get parentSeries(): StackedSeriesBase;
    set parentSeries(a: StackedSeriesBase);
    protected get_e5(): boolean;
    protected get_fb(): boolean;
    nc(): string;
    j2(): number;
    protected qa(a: Series): void;
    j7(): number;
    resolveLegendIndex(): number;
    bp(): Series;
    ys(): CategoryAxisBase;
    acw(): CategoryFramePreparer;
    y9(): NumericAxisBase;
    ac2(a: ISupportsMarkers, b: CategoryFrame, c: number[], d: IDetectsCollisions, e: number, f: number, g: number, h: number): boolean;
    aah(a: CategoryFrame, b: CategorySeriesView): void;
    wc(a: Point, b: boolean, c: boolean): Point;
    ai(): Axis[];
    private ac3;
    ac5(a: PointCollection, b: List$1<number[]>, c: CategorySeriesView): void;
    he(a: Rect, b: Rect, c: SeriesView): boolean;
    aa9(a: CategorySeriesView): number;
    ay(a: Axis): AxisRange;
    ac4(): number;
    ac6(a: IChartLegend): void;
    protected q9(a: any, b: string, c: any, d: any): void;
    rt(a: Rect, b: RenderSurface): void;
    get useHighMarkerFidelity(): boolean;
}
/**
 * @hidden
 */
export declare class AreaFragment extends FragmentBase {
    static $t: Type;
    protected bj(): Series;
    constructor();
    protected cs(): SeriesView;
    ac7: AreaFragmentView;
    q1(a: SeriesView): void;
    protected get_ev(): boolean;
    protected get_eu(): boolean;
    protected y4(): CategoryTransitionInMode;
    protected ac9(a: Point, b: boolean): boolean;
    gw(a: Point, b: boolean): boolean;
    private ac8;
    preferredCategoryMode(a: CategoryAxisBase): CategoryMode;
    o5(a: boolean, b: SeriesView): void;
    aak(a: CategoryFrame, b: CategorySeriesView): void;
    sd(): void;
    get useHighMarkerFidelity(): boolean;
}
/**
 * @hidden
 */
export declare class ColumnFragment extends FragmentBase {
    static $t: Type;
    protected bj(): Series;
    protected get_ez(): boolean;
    protected get_fl(): boolean;
    protected jk(): number;
    protected y4(): CategoryTransitionInMode;
    constructor();
    protected cs(): SeriesView;
    ac8: ColumnFragmentView;
    q1(a: SeriesView): void;
    adb: number;
    adc: number;
    get fragmentXAxis(): CategoryAxisBase;
    get fragmentYAxis(): NumericAxisBase;
    preferredCategoryMode(a: CategoryAxisBase): CategoryMode;
    ys(): CategoryAxisBase;
    y9(): NumericAxisBase;
    protected get_ed(): boolean;
    fetchXAxis(): Axis;
    fetchYAxis(): Axis;
    o5(a: boolean, b: SeriesView): void;
    ay(a: Axis): AxisRange;
    he(a: Rect, b: Rect, c: SeriesView): boolean;
    hb(): boolean;
    zv(a: SeriesView): number;
    zw(a: SeriesView): number;
    zx(a: SeriesView): number;
    wn(a: Point): Rect;
    gw(a: Point, b: boolean): boolean;
    protected gz(a: Point, b: boolean): boolean;
    protected adh(a: Rect, b: number): Rect;
    kx(a: any, b: Point): any;
    kn(a: Point): any;
    j5(a: Point): number;
    j3(a: Point): number;
    ac2(a: ISupportsMarkers, b: CategoryFrame, c: number[], d: IDetectsCollisions, e: number, f: number, g: number, h: number): boolean;
    private ada;
    rq(a: Rect, b: Rect, c: RenderSurface, d: string, e: number): void;
    aah(a: CategoryFrame, b: CategorySeriesView): void;
    aak(a: CategoryFrame, b: CategorySeriesView): void;
    protected q9(a: any, b: string, c: any, d: any): void;
    get useHighMarkerFidelity(): boolean;
    static $$p: string[];
}
/**
 * @hidden
 */
export declare class BarFragment extends ColumnFragment {
    static $t: Type;
    constructor();
    protected get_ex(): boolean;
    protected get_fl(): boolean;
    protected get_ez(): boolean;
    protected y4(): CategoryTransitionInMode;
    get barFragmentXAxis(): NumericXAxis;
    get barFragmentYAxis(): CategoryYAxis;
    ys(): CategoryAxisBase;
    protected get_isVertical(): boolean;
    ir(a: Point): number;
    y9(): NumericAxisBase;
    protected adh(a: Rect, b: number): Rect;
    wn(a: Point): Rect;
    gw(a: Point, b: boolean): boolean;
    ac2(a: ISupportsMarkers, b: CategoryFrame, c: number[], d: IDetectsCollisions, e: number, f: number, g: number, h: number): boolean;
    kn(a: Point): any;
    j5(a: Point): number;
    aa9(a: CategorySeriesView): number;
    protected q9(a: any, b: string, c: any, d: any): void;
    get useHighMarkerFidelity(): boolean;
}
/**
 * @hidden
 */
export declare class AreaFragmentBucketCalculator extends AnchoredCategoryBucketCalculator {
    static $t: Type;
    constructor(a: AnchoredCategorySeriesView);
    getBucketWithoutUnknowns(a: number): number[];
    getBucket(a: number): number[];
}
/**
 * @hidden
 */
export declare class LineFragmentBucketCalculator extends AnchoredCategoryBucketCalculator {
    static $t: Type;
    constructor(a: AnchoredCategorySeriesView);
    getBucketWithoutUnknowns(a: number): number[];
    getBucket(a: number): number[];
}
/**
 * @hidden
 */
export declare class SplineFragmentBucketCalculator extends AnchoredCategoryBucketCalculator {
    static $t: Type;
    constructor(a: AnchoredCategorySeriesView);
    getBucket(a: number): number[];
}
/**
 * @hidden
 */
export declare class StackedBucketCalculator extends CategoryBucketCalculator {
    static $t: Type;
    constructor(a: CategorySeriesView);
    getBucket(a: number): number[];
    getBucket1(a: AnchoredCategorySeries, b: number, c: number, d: Rect, e: Rect, f: CategoryFrame): number[];
}
/**
 * @hidden
 */
export declare class StackedBarBucketCalculator extends StackedBucketCalculator {
    static $t: Type;
    constructor(a: CategorySeriesView);
    g(a: number): void;
    getBucket(a: number): number[];
    getBucket1(a: AnchoredCategorySeries, b: number, c: number, d: Rect, e: Rect, f: CategoryFrame): number[];
}
/**
 * @hidden
 */
export declare class StackedColumnBucketCalculator extends StackedBucketCalculator {
    static $t: Type;
    constructor(a: CategorySeriesView);
    getBucket(a: number): number[];
    getBucket1(a: AnchoredCategorySeries, b: number, c: number, d: Rect, e: Rect, f: CategoryFrame): number[];
}
/**
 * @hidden
 */
export declare class FragmentBaseValueList extends Base implements IList$1<number> {
    static $t: Type;
    private a;
    constructor(a: FragmentBase);
    indexOf(a: number): number;
    insert(a: number, b: number): void;
    removeAt(a: number): void;
    item(a: number, b?: number): number;
    add(a: number): void;
    clear(): void;
    contains(a: number): boolean;
    copyTo(a: number[], b: number): void;
    get count(): number;
    get isReadOnly(): boolean;
    remove(a: number): boolean;
    getEnumerator(): IEnumerator$1<number>;
    getEnumeratorObject(): IEnumerator;
}
/**
 * @hidden
 */
export declare class LineFragment extends FragmentBase {
    static $t: Type;
    protected bj(): Series;
    protected get_fk(): boolean;
    protected zo(): boolean;
    constructor();
    protected cs(): SeriesView;
    ac7: LineFragmentView;
    q1(a: SeriesView): void;
    protected ac9(a: Point, b: boolean): boolean;
    protected get_ev(): boolean;
    gw(a: Point, b: boolean): boolean;
    private ac8;
    preferredCategoryMode(a: CategoryAxisBase): CategoryMode;
    o5(a: boolean, b: SeriesView): void;
    aak(a: CategoryFrame, b: CategorySeriesView): void;
    get useHighMarkerFidelity(): boolean;
}
/**
 * @hidden
 */
export declare abstract class SplineFragmentBase extends SplineSeriesBase {
    static $t: Type;
    private _logicalSeriesLink;
    get logicalSeriesLink(): StackedFragmentSeries;
    set logicalSeriesLink(a: StackedFragmentSeries);
    adg: CategoryLineRasterizer;
    constructor();
    private adi;
    get parentSeries(): StackedSeriesBase;
    set parentSeries(a: StackedSeriesBase);
    protected qa(a: Series): void;
    protected get_e5(): boolean;
    preferredCategoryMode(a: CategoryAxisBase): CategoryMode;
    protected get_fb(): boolean;
    nc(): string;
    wc(a: Point, b: boolean, c: boolean): Point;
    ai(): Axis[];
    private adk;
    j2(): number;
    resolveLegendIndex(): number;
    j7(): number;
    bp(): Series;
    ac2(a: CategoryFrame, b: number[], c: CollisionAvoider, d: number, e: number, f: CategorySeriesView, g: number): boolean;
    he(a: Rect, b: Rect, c: SeriesView): boolean;
    ay(a: Axis): AxisRange;
    adl(a: CategoryFrame, b: Rect, c: Rect, d: CategoryAxisBase, e: NumericYAxis, f: CategorySeriesView): void;
    aah(a: CategoryFrame, b: CategorySeriesView): void;
    acw(a: CategorySeriesView): number[][];
    acx(a: CategorySeriesView): number[][];
    adb(a: CategorySeriesView): void;
    protected q9(a: any, b: string, c: any, d: any): void;
    get useHighMarkerFidelity(): boolean;
}
/**
 * @hidden
 */
export declare class SplineAreaFragment extends SplineFragmentBase {
    static $t: Type;
    protected bj(): Series;
    constructor();
    protected cs(): SeriesView;
    q1(a: SeriesView): void;
    private adm;
    ac(): void;
    protected get_ev(): boolean;
    protected get_eu(): boolean;
    protected get_f0(): boolean;
    protected y4(): CategoryTransitionInMode;
    protected ado(a: Point, b: boolean): boolean;
    gw(a: Point, b: boolean): boolean;
    private adn;
    adq: PointCollection;
    o5(a: boolean, b: SeriesView): void;
    aak(a: CategoryFrame, b: CategorySeriesView): void;
    rt(a: Rect, b: RenderSurface): void;
    adp(a: PointCollection, b: List$1<number[]>, c: CategorySeriesView): void;
    aa9(a: CategorySeriesView): number;
    sd(): void;
    get useHighMarkerFidelity(): boolean;
}
/**
 * @hidden
 */
export declare class SplineFragment extends SplineFragmentBase {
    static $t: Type;
    protected bj(): Series;
    protected get_f0(): boolean;
    protected zo(): boolean;
    constructor();
    protected cs(): SeriesView;
    adm: SplineFragmentView;
    q1(a: SeriesView): void;
    protected ado(a: Point, b: boolean): boolean;
    protected get_ev(): boolean;
    gw(a: Point, b: boolean): boolean;
    private adn;
    o5(a: boolean, b: SeriesView): void;
    aak(a: CategoryFrame, b: CategorySeriesView): void;
    get useHighMarkerFidelity(): boolean;
}
/**
 * @hidden
 */
export declare class SplineFragmentBaseValueList extends Base implements IList$1<number> {
    static $t: Type;
    private a;
    constructor(a: SplineFragmentBase);
    indexOf(a: number): number;
    insert(a: number, b: number): void;
    removeAt(a: number): void;
    item(a: number, b?: number): number;
    add(a: number): void;
    clear(): void;
    contains(a: number): boolean;
    copyTo(a: number[], b: number): void;
    get count(): number;
    get isReadOnly(): boolean;
    remove(a: number): boolean;
    getEnumerator(): IEnumerator$1<number>;
    getEnumeratorObject(): IEnumerator;
}
/**
 * @hidden
 */
export declare abstract class StackedSeriesBase extends CategorySeries implements IIsCategoryBased {
    static $t: Type;
    constructor();
    qg(): void;
    protected get_fe(): boolean;
    getHostReferenceValue(): number;
    protected cs(): SeriesView;
    aa2: StackedSeriesView;
    q1(a: SeriesView): void;
    q2(a: Rect, b: Rect): void;
    private _series;
    get series(): StackedSeriesCollection;
    set series(a: StackedSeriesCollection);
    kc(): number;
    p3(a: (arg1: Series) => boolean): void;
    aa3: boolean;
    aa5: boolean;
    protected get_isStacked(): boolean;
    seriesCreated: (sender: any, e: StackedSeriesCreatedEventArgs) => void;
    abt: Visibility;
    abc: number;
    abb: number;
    aas: number[];
    aat: number[];
    private aa0;
    get aa1(): StackedSeriesManager;
    set aa1(a: StackedSeriesManager);
    aax: StackedSeriesCollection;
    get aaw(): StackedSeriesCollection;
    private abi;
    private abo;
    private abn;
    r6(a: Point): void;
    y0(a: CategorySeriesView): CategoryFramePreparer;
    aah(a: CategoryFrame, b: CategorySeriesView): void;
    rs(a: boolean): void;
    protected get_gt(): boolean;
    o5(a: boolean, b: SeriesView): void;
    abj(): void;
    abp(): void;
    protected get_aa4(): boolean;
    get aa4(): boolean;
    gd(a: any): boolean;
    ay(a: Axis): AxisRange;
    xg(): boolean;
    protected pb(a: FastItemsSourceEventAction, b: number, c: number, d: string): void;
    aav(): CategorySeriesView;
    aa8(): number;
    aa9(): number;
    abe(a: StackedFragmentSeries): number;
    abd(a: Point): number;
    aa6(a: AnchoredCategorySeries, b: Rect, c: Rect, d: SeriesView): boolean;
    private aa7;
    abk(): void;
    aak(a: CategoryFrame, b: CategorySeriesView): void;
    abm(a: AnchoredCategorySeries, b: CategoryFrame, c: CategorySeriesView, d: (orderedStartIndex: number, orderedEndIndex: number) => any[]): void;
    az(a: Rect): AxisRange;
    rv(): void;
    protected abl(): void;
    protected q9(a: any, b: string, c: any, d: any): void;
    get currentCategoryMode(): CategoryMode;
    get scaler(): ICategoryScaler;
    get yScaler(): IScaler;
    get bucketizer(): IBucketizer;
    get currentMode2Index(): number;
    provideCollisionDetector(): IDetectsCollisions;
    protected gn(): boolean;
    protected get_e5(): boolean;
    rt(a: Rect, b: RenderSurface): void;
    aau: CategoryFrame;
    rq(a: Rect, b: Rect, c: RenderSurface, d: string, e: number): void;
    aad(a: ValueCollisionMode, b: List$1<ChartSelection>, c: number, d: number, e: number, f: number, g: SeriesSelectionBehavior): void;
    aba(a: number, b: number): number;
    z7(a: List$1<ChartSelection>, b: number, c: SeriesSelectionBehavior): void;
    km(): any;
    get mayContainUnknowns(): boolean;
    get useHighMarkerFidelity(): boolean;
    static $$p: string[];
}
/**
 * @hidden
 */
export declare abstract class HorizontalStackedSeriesBase extends StackedSeriesBase {
    static $t: Type;
    xAxis: CategoryAxisBase;
    protected get_ek(): boolean;
    protected get_f5(): boolean;
    o2(): void;
    ck(): SeriesPlotAreaMarginHorizontalMode;
    cl(): SeriesPlotAreaMarginVerticalMode;
    yAxis: NumericYAxis;
    getOffsetValue(): number;
    getCategoryWidth(): number;
    fetchXAxis(): Axis;
    fetchYAxis(): Axis;
    ai(): Axis[];
    zp(): boolean;
    sd(): void;
    protected q9(a: any, b: string, c: any, d: any): void;
    abx(a: any): boolean;
    abw(a: any): boolean;
    get useHighMarkerFidelity(): boolean;
    static $$p: string[];
}
/**
 * @hidden
 */
export declare class StackedAreaSeries extends HorizontalStackedSeriesBase {
    static $t: Type;
    protected bj(): Series;
    protected get_eu(): boolean;
    constructor();
    ac(): void;
    protected cs(): SeriesView;
    ab2: StackedAreaSeriesView;
    q1(a: SeriesView): void;
    ay(a: Axis): AxisRange;
    preferredCategoryMode(a: CategoryAxisBase): CategoryMode;
    ak(a: Rect, b: SeriesSelectionBehavior): ChartSelection[];
    p4(a: Rect, b: List$1<ChartSelection>, c: SeriesSelectionBehavior): void;
    get useHighMarkerFidelity(): boolean;
}
/**
 * @hidden
 */
export declare abstract class VerticalStackedSeriesBase extends StackedSeriesBase {
    static $t: Type;
    xAxis: NumericXAxis;
    yAxis: CategoryYAxis;
    ys(): CategoryAxisBase;
    y9(): NumericAxisBase;
    o2(): void;
    ck(): SeriesPlotAreaMarginHorizontalMode;
    cl(): SeriesPlotAreaMarginVerticalMode;
    az(a: Rect): AxisRange;
    getOffsetValue(): number;
    getCategoryWidth(): number;
    protected get_isVertical(): boolean;
    fetchXAxis(): Axis;
    fetchYAxis(): Axis;
    zp(): boolean;
    protected q9(a: any, b: string, c: any, d: any): void;
    abx(a: any): boolean;
    abw(a: any): boolean;
    get useHighMarkerFidelity(): boolean;
    static $$p: string[];
}
/**
 * @hidden
 */
export declare class StackedBarSeries extends VerticalStackedSeriesBase implements IBarSeries {
    static $t: Type;
    protected bj(): Series;
    protected get_ex(): boolean;
    protected get_fl(): boolean;
    protected jk(): number;
    constructor();
    ac(): void;
    protected cs(): SeriesView;
    ab2: StackedBarSeriesView;
    q1(a: SeriesView): void;
    ab3: number;
    ab4: number;
    aav(): CategorySeriesView;
    preferredCategoryMode(a: CategoryAxisBase): CategoryMode;
    zy(): number;
    aa8(): number;
    aa9(): number;
    ay(a: Axis): AxisRange;
    gd(a: any): boolean;
    he(a: Rect, b: Rect, c: SeriesView): boolean;
    protected pb(a: FastItemsSourceEventAction, b: number, c: number, d: string): void;
    j3(a: Point): number;
    kn(a: Point): any;
    abp(): void;
    abd(a: Point): number;
    aa6(a: AnchoredCategorySeries, b: Rect, c: Rect, d: SeriesView): boolean;
    iw(): number;
    abm(a: AnchoredCategorySeries, b: CategoryFrame, c: CategorySeriesView, d: (orderedStartIndex: number, orderedEndIndex: number) => any[]): void;
    ak(a: Rect, b: SeriesSelectionBehavior): ChartSelection[];
    p4(a: Rect, b: List$1<ChartSelection>, c: SeriesSelectionBehavior): void;
    protected q9(a: any, b: string, c: any, d: any): void;
    getPreferredCategoryMode(): CategoryMode;
    get useHighMarkerFidelity(): boolean;
    static $$p: string[];
}
/**
 * @hidden
 */
export declare class StackedColumnSeries extends HorizontalStackedSeriesBase {
    static $t: Type;
    protected bj(): Series;
    protected get_ez(): boolean;
    protected get_fl(): boolean;
    protected jk(): number;
    constructor();
    protected cs(): SeriesView;
    ab2: StackedColumnSeriesView;
    q1(a: SeriesView): void;
    ab3: number;
    ab4: number;
    aav(): CategorySeriesView;
    preferredCategoryMode(a: CategoryAxisBase): CategoryMode;
    ay(a: Axis): AxisRange;
    iw(): number;
    abm(a: AnchoredCategorySeries, b: CategoryFrame, c: CategorySeriesView, d: (orderedStartIndex: number, orderedEndIndex: number) => any[]): void;
    ak(a: Rect, b: SeriesSelectionBehavior): ChartSelection[];
    p4(a: Rect, b: List$1<ChartSelection>, c: SeriesSelectionBehavior): void;
    protected q9(a: any, b: string, c: any, d: any): void;
    get useHighMarkerFidelity(): boolean;
    static $$p: string[];
}
/**
 * @hidden
 */
export declare class StackedSplineAreaSeries extends HorizontalStackedSeriesBase {
    static $t: Type;
    protected bj(): Series;
    ab3: boolean;
    protected jk(): number;
    protected get_eu(): boolean;
    protected get_f0(): boolean;
    constructor();
    ac(): void;
    protected cs(): SeriesView;
    ab2: StackedSplineAreaSeriesView;
    q1(a: SeriesView): void;
    ay(a: Axis): AxisRange;
    preferredCategoryMode(a: CategoryAxisBase): CategoryMode;
    protected q9(a: any, b: string, c: any, d: any): void;
    ak(a: Rect, b: SeriesSelectionBehavior): ChartSelection[];
    p4(a: Rect, b: List$1<ChartSelection>, c: SeriesSelectionBehavior): void;
    get useHighMarkerFidelity(): boolean;
    static $$p: string[];
}
/**
 * @hidden
 */
export declare class StackedSplineSeries extends HorizontalStackedSeriesBase {
    static $t: Type;
    protected bj(): Series;
    ab3: boolean;
    protected get_f0(): boolean;
    protected jk(): number;
    constructor();
    ac(): void;
    protected cs(): SeriesView;
    ab2: StackedSplineSeriesView;
    q1(a: SeriesView): void;
    ay(a: Axis): AxisRange;
    preferredCategoryMode(a: CategoryAxisBase): CategoryMode;
    ak(a: Rect, b: SeriesSelectionBehavior): ChartSelection[];
    p4(a: Rect, b: List$1<ChartSelection>, c: SeriesSelectionBehavior): void;
    get useHighMarkerFidelity(): boolean;
    static $$p: string[];
}
/**
 * @hidden
 */
export declare class StackedFragmentSeries extends DependencyObject implements INotifyPropertyChanged {
    static $t: Type;
    constructor();
    itemsSource: IEnumerable;
    highlightedItemsSource: IEnumerable;
    kz: Brush;
    ku: Brush;
    k8: DoubleCollection;
    k7: DoubleCollection;
    lb: PenLineCap;
    k9: PenLineCap;
    au: boolean;
    al: boolean;
    b1: number;
    bi: number;
    k6: Color;
    k5: Color;
    a4: boolean;
    ar: boolean;
    b2: number;
    bj: number;
    b3: number;
    bk: number;
    lc: PenLineCap;
    la: PenLineCap;
    av: boolean;
    am: boolean;
    hq: DataTemplate;
    hn: DataTemplate;
    hr: DataTemplate;
    ho: DataTemplate;
    lu: Visibility;
    ls: Visibility;
    r: LegendItemBadgeShape;
    p: LegendItemBadgeMode;
    q: LegendItemBadgeShape;
    o: LegendItemBadgeMode;
    k0: Brush;
    kv: Brush;
    k1: Brush;
    kw: Brush;
    lr: Style;
    lq: Style;
    hs: DataTemplate;
    hp: DataTemplate;
    x: MarkerType;
    w: MarkerType;
    t: MarkerFillMode;
    s: MarkerFillMode;
    v: MarkerOutlineMode;
    u: MarkerOutlineMode;
    e0: string;
    by: number;
    bf: number;
    k2: Brush;
    kx: Brush;
    k3: Brush;
    ky: Brush;
    bm: number;
    bb: number;
    bw: number;
    bd: number;
    ab: SeriesOutlineMode;
    aa: SeriesOutlineMode;
    bv: number;
    bc: number;
    z: SeriesHighlightedValuesDisplayMode;
    bz: number;
    bg: number;
    an: boolean;
    aw: boolean;
    b0: number;
    bh: number;
    b4: number;
    bl: number;
    bx: number;
    be: number;
    cj: any;
    ck: any;
    cf: any;
    ai: (time: number) => number;
    cd: number;
    ce: number;
    aj: (time: number) => number;
    n: CategoryTransitionInMode;
    ax: boolean;
    ae: TransitionInSpeedType;
    ao: boolean;
    b7: number;
    m: CategoryTransitionInMode;
    ad: TransitionInSpeedType;
    ah: (time: number) => number;
    ag: (time: number) => number;
    b6: number;
    a3: boolean;
    aq: boolean;
    a2: boolean;
    ap: boolean;
    ft: string;
    fp: string;
    fr: string;
    d0: string;
    d2: string;
    cg(a: number, b: number): any;
    eb(): string;
    d9: string;
    ed: string;
    cp: string;
    cr: string;
    lv: Visibility;
    lt: Visibility;
    private _parentSeries;
    get parentSeries(): StackedSeriesBase;
    set parentSeries(a: StackedSeriesBase);
    cc: number;
    af: SeriesViewer;
    ak: IFastItemColumn$1<number>;
    private _visualSeriesLink;
    get visualSeriesLink(): AnchoredCategorySeries;
    set visualSeriesLink(a: AnchoredCategorySeries);
    a7: List$1<number>;
    a8: List$1<number>;
    a6: List$1<number[]>;
    az: boolean;
    b8(a: Point): number;
    ch(a: Point): any;
    cb(a: Point, b: boolean): number;
    ca(a: Point, b: boolean): number;
    bt(a: Point, b: boolean, c: boolean): number;
    li(a: Point, b: boolean, c: boolean): Point;
    lm(a: Point): Rect;
    j(a: Point): Rect[];
    ln(a: Point): Rect;
    k(a: Point): Rect[];
    lo(a: Point): Rect;
    lp(a: Point): Rect;
    bp(a: Point, b: boolean, c: boolean): number;
    le(a: Point, b: boolean, c: boolean): Point;
    br(a: Point, b: boolean, c: boolean): number;
    lg(a: Point, b: boolean, c: boolean): Point;
    lj(a: Point, b: boolean, c: boolean): Point;
    bu(a: Point, b: boolean, c: boolean): number;
    lf(a: Point, b: boolean, c: boolean): Point;
    bq(a: Point, b: boolean, c: boolean): number;
    lh(a: Point, b: boolean, c: boolean): Point;
    bs(a: Point, b: boolean, c: boolean): number;
    b9(a: Point): number;
    bo(): number;
    bn(a: Point): number;
    ci(a: Point): any;
    as(a: List$1<SeriesPointOfInterest>, b: boolean, c: boolean, d: number, e: boolean): boolean;
    lk(a: Point): Point;
    ld(a: Point): Point;
    a0(a: any): boolean;
    ll(): Rect;
    fx(): void;
    f2(a: Point): void;
    a1(a: Point, b: boolean): boolean;
    fw(a: Point): void;
    b5: DomRenderer;
    provideRenderer(a: DomRenderer): void;
    k4: Brush;
    hm(): void;
    gu(): void;
    gw(): void;
    f4(): void;
    f5(): void;
    gb(): void;
    ga(): void;
    g0(): void;
    gq(): void;
    f6(): void;
    gc(): void;
    g3(): void;
    g4(): void;
    hi(): void;
    g5(): void;
    g6(): void;
    gd(): void;
    gj(): void;
    gk(): void;
    gl(): void;
    gi(): void;
    gh(): void;
    go(): void;
    gr(): void;
    gt(): void;
    gx(): void;
    gy(): void;
    gz(): void;
    gg(): void;
    f9(): void;
    f3(): void;
    ge(): void;
    g1(): void;
    g2(): void;
    gm(): void;
    g7(): void;
    gn(): void;
    gv(): void;
    g9(): void;
    hb(): void;
    ha(): void;
    hd(): void;
    he(): void;
    hf(): void;
    gf(): void;
    hc(): void;
    hh(): void;
    g8(): void;
    gp(): void;
    gs(): void;
    hg(): void;
    hk(): void;
    hj(): void;
    f7(): void;
    f8(): void;
    hl(): void;
    propertyChanged: (sender: any, e: PropertyChangedEventArgs) => void;
    propertyUpdated: (sender: any, e: PropertyUpdatedEventArgs) => void;
    protected f0(a: string, b: any, c: any): void;
    private a5;
    private at;
    private ay;
    protected fy(a: any, b: string, c: any, d: any): void;
    f1(): void;
    static $$p: string[];
}
/**
 * @hidden
 */
export declare class StackedSeriesCollection extends ObservableCollection$1<StackedFragmentSeries> {
    static $t: Type;
    constructor();
    collectionResetting: (sender: any, e: EventArgs) => void;
    protected p(): void;
}
/**
 * @hidden
 */
export declare class StackedSeriesFramePreparer extends CategoryFramePreparer {
    static $t: Type;
    constructor(a: number, b: IIsCategoryBased);
    constructor(a: number, b: IIsCategoryBased, c: ISupportsMarkers, d: IProvidesViewport, e: ISupportsErrorBars, f: IBucketizer);
    constructor(a: number, ..._rest: any[]);
    protected j(a: PreparationParams): ValuesHolder;
    protected t(a: PreparationParams, b: ValuesHolder, c: number, d: boolean, e: boolean): number;
    protected l(a: CategoryFrame, b: number[], c: IDetectsCollisions, d: number, e: number, f: number): boolean;
}
/**
 * @hidden
 */
export declare class AreaFragmentView extends AnchoredCategorySeriesView {
    static $t: Type;
    df: AreaFragment;
    au(): void;
    constructor(a: AreaFragment);
    dl: Path;
    dn: Path;
    dm: Path;
    dp: Path;
    dh: Path;
    dj: Path;
    di: Path;
    dk: Path;
    dg(): void;
    cx(): CategoryBucketCalculator;
    protected bd(): void;
    protected be(): void;
    protected a8(a: RenderingContext, b: boolean): void;
    protected get_index(): number;
    an(a: any): void;
}
/**
 * @hidden
 */
export declare class ColumnFragmentView extends AnchoredCategorySeriesView {
    static $t: Type;
    df: ColumnFragment;
    au(): void;
    constructor(a: ColumnFragment);
    protected dj: List$1<Rectangle>;
    dg: Pool$1<Rectangle>;
    dh: List$1<number>;
    di: List$1<number>;
    private dq;
    private dk;
    private dm;
    private dl;
    protected bg(a: any, b: number): void;
    dn(a: Rectangle, b: number, c: number): void;
    protected bh(a: any, b: number): void;
    protected ac(a: number): any;
    private dp;
    protected ab(a: number): any;
    protected a8(a: RenderingContext, b: boolean): void;
    protected get_index(): number;
    an(a: any): void;
    getDefaultTooltipTemplate(): string;
}
/**
 * @hidden
 */
export declare class LineFragmentView extends AnchoredCategorySeriesView {
    static $t: Type;
    df: LineFragment;
    constructor(a: LineFragment);
    dl: Path;
    dk: Path;
    dm: Path;
    di: Path;
    dh: Path;
    dj: Path;
    dg(): void;
    cx(): CategoryBucketCalculator;
    protected bd(): void;
    protected be(): void;
    protected a8(a: RenderingContext, b: boolean): void;
    protected get_index(): number;
    an(a: any): void;
}
/**
 * @hidden
 */
export declare class SplineAreaFragmentView extends SplineSeriesBaseView {
    static $t: Type;
    private dh;
    au(): void;
    constructor(a: SplineAreaFragment);
    dn: Path;
    dq: Path;
    dp: Path;
    dr: Path;
    dj: Path;
    dl: Path;
    dk: Path;
    dm: Path;
    di(): void;
    protected bd(): void;
    protected be(): void;
    protected a8(a: RenderingContext, b: boolean): void;
    protected get_index(): number;
    an(a: any): void;
}
/**
 * @hidden
 */
export declare class SplineFragmentView extends SplineSeriesBaseView {
    static $t: Type;
    dh: SplineFragment;
    constructor(a: SplineFragment);
    cx(): CategoryBucketCalculator;
    dn: Path;
    dm: Path;
    dp: Path;
    dk: Path;
    dj: Path;
    dl: Path;
    di(): void;
    protected bd(): void;
    protected be(): void;
    protected a8(a: RenderingContext, b: boolean): void;
    protected get_index(): number;
    an(a: any): void;
}
/**
 * @hidden
 */
export declare class StackedSeriesView extends CategorySeriesView {
    static $t: Type;
    c5: StackedSeriesBase;
    private readonly c6;
    get c7(): Canvas;
    private readonly c8;
    get c9(): Panel;
    constructor(a: StackedSeriesBase);
    cx(): CategoryBucketCalculator;
    ar(): void;
    at(a: RenderingContext, b: RenderingContext): void;
    protected af(): void;
}
/**
 * @hidden
 */
export declare class StackedBarSeriesView extends StackedSeriesView {
    static $t: Type;
    da: StackedBarSeries;
    constructor(a: StackedBarSeries);
    cx(): CategoryBucketCalculator;
    au(): void;
}
/**
 * @hidden
 */
export declare class StackedColumnSeriesView extends StackedSeriesView {
    static $t: Type;
    constructor(a: StackedColumnSeries);
    cx(): CategoryBucketCalculator;
    au(): void;
}
/**
 * @hidden
 */
export declare class StackedAreaSeriesView extends StackedSeriesView {
    static $t: Type;
    constructor(a: StackedAreaSeries);
    au(): void;
}
/**
 * @hidden
 */
export declare class StackedSplineAreaSeriesView extends StackedSeriesView {
    static $t: Type;
    constructor(a: StackedSplineAreaSeries);
    au(): void;
    da(): number;
}
/**
 * @hidden
 */
export declare class StackedSplineSeriesView extends StackedSeriesView {
    static $t: Type;
    constructor(a: StackedSplineSeries);
    au(): void;
    da(): number;
}
/**
 * @hidden
 */
export declare class StackedSeriesManager extends Base {
    static $t: Type;
    constructor(a: StackedSeriesBase);
    b: StackedSeriesBase;
    f: ObservableCollection$1<AnchoredCategorySeries>;
    c: StackedSeriesCollection;
    e: ObservableCollection$1<AnchoredCategorySeries>;
    d: ObservableCollection$1<AnchoredCategorySeries>;
    l: Canvas;
    m: Panel;
    a(a: StackedFragmentSeries): AnchoredCategorySeries;
    k(): void;
    private j;
    i(a: boolean): void;
    private h;
    g(): void;
}
