{"ast":null,"code":"import getOrCreateMeasurementElement from './getOrCreateMeasurementElement';\nvar MEASUREMENT_ELEMENT_ID = '__visx_splitpath_svg_path_measurement_id';\nvar TRUE = function TRUE() {\n  return true;\n};\nexport default function getSplitLineSegments(_ref) {\n  var path = _ref.path,\n    pointsInSegments = _ref.pointsInSegments,\n    _ref$segmentation = _ref.segmentation,\n    segmentation = _ref$segmentation === void 0 ? 'x' : _ref$segmentation,\n    _ref$sampleRate = _ref.sampleRate,\n    sampleRate = _ref$sampleRate === void 0 ? 1 : _ref$sampleRate;\n  try {\n    var pathElement = getOrCreateMeasurementElement(MEASUREMENT_ELEMENT_ID);\n    pathElement.setAttribute('d', path);\n    var totalLength = pathElement.getTotalLength();\n    var numSegments = pointsInSegments.length;\n    var lineSegments = pointsInSegments.map(function () {\n      return [];\n    });\n    if (segmentation === 'x' || segmentation === 'y') {\n      var segmentStarts = pointsInSegments.map(function (points) {\n        var _points$find;\n        return (_points$find = points.find(function (p) {\n          return typeof p[segmentation] === 'number';\n        })) == null ? void 0 : _points$find[segmentation];\n      });\n      var first = pathElement.getPointAtLength(0);\n      var last = pathElement.getPointAtLength(totalLength);\n      var isIncreasing = last[segmentation] > first[segmentation];\n      var isBeyondSegmentStart = isIncreasing ? segmentStarts.map(function (start) {\n        return typeof start === 'undefined' ? TRUE : function (xOrY) {\n          return xOrY >= start;\n        };\n      }) : segmentStarts.map(function (start) {\n        return typeof start === 'undefined' ? TRUE : function (xOrY) {\n          return xOrY <= start;\n        };\n      });\n      var currentSegment = 0;\n      for (var distance = 0; distance <= totalLength; distance += sampleRate) {\n        var sample = pathElement.getPointAtLength(distance);\n        var position = sample[segmentation];\n        // find the current segment to which this sample belongs\n        while (currentSegment < numSegments - 1 && isBeyondSegmentStart[currentSegment + 1](position)) {\n          currentSegment += 1;\n        }\n        // add sample to segment\n        lineSegments[currentSegment].push(sample);\n      }\n    } else {\n      // segmentation === \"length\"\n      var numPointsInSegment = pointsInSegments.map(function (points) {\n        return points.length;\n      });\n      var numPoints = numPointsInSegment.reduce(function (sum, curr) {\n        return sum + curr;\n      }, 0);\n      var lengthBetweenPoints = totalLength / Math.max(1, numPoints - 1);\n      var _segmentStarts = numPointsInSegment.slice(0, numSegments - 1);\n      _segmentStarts.unshift(0);\n      for (var i = 2; i < numSegments; i += 1) {\n        _segmentStarts[i] += _segmentStarts[i - 1];\n      }\n      for (var _i = 0; _i < numSegments; _i += 1) {\n        _segmentStarts[_i] *= lengthBetweenPoints;\n      }\n      var _currentSegment = 0;\n      for (var _distance = 0; _distance <= totalLength; _distance += sampleRate) {\n        var _sample = pathElement.getPointAtLength(_distance);\n        // find the current segment to which this sample belongs\n        while (_currentSegment < numSegments - 1 && _distance >= _segmentStarts[_currentSegment + 1]) {\n          _currentSegment += 1;\n        }\n        // add sample to segment\n        lineSegments[_currentSegment].push(_sample);\n      }\n    }\n    return lineSegments;\n  } catch (e) {\n    return [];\n  }\n}","map":{"version":3,"names":["getOrCreateMeasurementElement","MEASUREMENT_ELEMENT_ID","TRUE","getSplitLineSegments","_ref","path","pointsInSegments","_ref$segmentation","segmentation","_ref$sampleRate","sampleRate","pathElement","setAttribute","totalLength","getTotalLength","numSegments","length","lineSegments","map","segmentStarts","points","_points$find","find","p","first","getPointAtLength","last","isIncreasing","isBeyondSegmentStart","start","xOrY","currentSegment","distance","sample","position","push","numPointsInSegment","numPoints","reduce","sum","curr","lengthBetweenPoints","Math","max","_segmentStarts","slice","unshift","i","_i","_currentSegment","_distance","_sample","e"],"sources":["C:/Users/Yolanda Ayuso/Desktop/frontDespliegueDef/DQPA_v1.2Front/dqpa/node_modules/@visx/shape/esm/util/getSplitLineSegments.js"],"sourcesContent":["import getOrCreateMeasurementElement from './getOrCreateMeasurementElement';\nvar MEASUREMENT_ELEMENT_ID = '__visx_splitpath_svg_path_measurement_id';\nvar TRUE = function TRUE() {\n  return true;\n};\nexport default function getSplitLineSegments(_ref) {\n  var path = _ref.path,\n    pointsInSegments = _ref.pointsInSegments,\n    _ref$segmentation = _ref.segmentation,\n    segmentation = _ref$segmentation === void 0 ? 'x' : _ref$segmentation,\n    _ref$sampleRate = _ref.sampleRate,\n    sampleRate = _ref$sampleRate === void 0 ? 1 : _ref$sampleRate;\n  try {\n    var pathElement = getOrCreateMeasurementElement(MEASUREMENT_ELEMENT_ID);\n    pathElement.setAttribute('d', path);\n    var totalLength = pathElement.getTotalLength();\n    var numSegments = pointsInSegments.length;\n    var lineSegments = pointsInSegments.map(function () {\n      return [];\n    });\n    if (segmentation === 'x' || segmentation === 'y') {\n      var segmentStarts = pointsInSegments.map(function (points) {\n        var _points$find;\n        return (_points$find = points.find(function (p) {\n          return typeof p[segmentation] === 'number';\n        })) == null ? void 0 : _points$find[segmentation];\n      });\n      var first = pathElement.getPointAtLength(0);\n      var last = pathElement.getPointAtLength(totalLength);\n      var isIncreasing = last[segmentation] > first[segmentation];\n      var isBeyondSegmentStart = isIncreasing ? segmentStarts.map(function (start) {\n        return typeof start === 'undefined' ? TRUE : function (xOrY) {\n          return xOrY >= start;\n        };\n      }) : segmentStarts.map(function (start) {\n        return typeof start === 'undefined' ? TRUE : function (xOrY) {\n          return xOrY <= start;\n        };\n      });\n      var currentSegment = 0;\n      for (var distance = 0; distance <= totalLength; distance += sampleRate) {\n        var sample = pathElement.getPointAtLength(distance);\n        var position = sample[segmentation];\n        // find the current segment to which this sample belongs\n        while (currentSegment < numSegments - 1 && isBeyondSegmentStart[currentSegment + 1](position)) {\n          currentSegment += 1;\n        }\n        // add sample to segment\n        lineSegments[currentSegment].push(sample);\n      }\n    } else {\n      // segmentation === \"length\"\n      var numPointsInSegment = pointsInSegments.map(function (points) {\n        return points.length;\n      });\n      var numPoints = numPointsInSegment.reduce(function (sum, curr) {\n        return sum + curr;\n      }, 0);\n      var lengthBetweenPoints = totalLength / Math.max(1, numPoints - 1);\n      var _segmentStarts = numPointsInSegment.slice(0, numSegments - 1);\n      _segmentStarts.unshift(0);\n      for (var i = 2; i < numSegments; i += 1) {\n        _segmentStarts[i] += _segmentStarts[i - 1];\n      }\n      for (var _i = 0; _i < numSegments; _i += 1) {\n        _segmentStarts[_i] *= lengthBetweenPoints;\n      }\n      var _currentSegment = 0;\n      for (var _distance = 0; _distance <= totalLength; _distance += sampleRate) {\n        var _sample = pathElement.getPointAtLength(_distance);\n        // find the current segment to which this sample belongs\n        while (_currentSegment < numSegments - 1 && _distance >= _segmentStarts[_currentSegment + 1]) {\n          _currentSegment += 1;\n        }\n        // add sample to segment\n        lineSegments[_currentSegment].push(_sample);\n      }\n    }\n    return lineSegments;\n  } catch (e) {\n    return [];\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}