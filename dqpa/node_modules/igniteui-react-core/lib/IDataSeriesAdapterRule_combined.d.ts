import { Type, Base, INotifyPropertyChanged, PropertyChangedEventArgs } from "./type";
import { DataSeriesCollection } from "./DataSeriesCollection";
import { IDataSourceLocalDataProvider } from "./IDataSourceLocalDataProvider";
import { HashSet$1 } from "./HashSet$1";
import { DataSeriesType } from "./DataSeriesType";
import { DataSeriesAdapterProviderInfo } from "./DataSeriesAdapterProviderInfo";
import { DataSeries } from "./DataSeries";
import { IDataSourceDataProviderUpdateNotifier } from "./IDataSourceDataProviderUpdateNotifier";
import { ObservableCollection$1 } from "./ObservableCollection$1";
import { IExternalDataSeriesAdapter } from "./IExternalDataSeriesAdapter";
import { SortDescriptionCollection } from "./SortDescriptionCollection";
import { FilterExpressionCollection } from "./FilterExpressionCollection";
import { SummaryDescriptionCollection } from "./SummaryDescriptionCollection";
import { Tuple$2 } from "./Tuple$2";
/**
 * @hidden
 */
export interface IDataSeriesAdapterRule {
    getPrimaryAxisLabelsString(a: DataSeriesAdapterRunContext): string;
    getPrimaryAxisLabelsStrings(a: DataSeriesAdapterRunContext): string[];
    getAdditionalValuePropertyStrings(a: DataSeriesAdapterRunContext): string[];
    evaluate(a: DataSeriesAdapterRunContext): void;
    readonly priority: number;
}
/**
 * @hidden
 */
export declare let IDataSeriesAdapterRule_$type: Type;
/**
 * @hidden
 */
export declare class DataSeriesAdapterRunContext extends Base {
    static $t: Type;
    private g;
    private _analyzer;
    get analyzer(): DataSeriesDataProviderAnalyzer;
    set analyzer(a: DataSeriesDataProviderAnalyzer);
    constructor(a: any);
    private h;
    getSubProvider(a: any, b: string): IDataSourceLocalDataProvider;
    popSubProvider(): void;
    ab(a: string, b: string): string;
    recurseRules(a: any, b: string, c: boolean): void;
    private p;
    private q;
    private s;
    private r;
    private b;
    private a;
    private o;
    private l;
    get adjustPrioritiesBasedOnFitness(): boolean;
    get includedProperties(): string[];
    get excludedProperties(): string[];
    getCurrentDataSource(): IDataSourceLocalDataProvider;
    getCurrentHighlightingDataSource(): IDataSourceLocalDataProvider;
    pushDataSource(a: IDataSourceLocalDataProvider): void;
    pushHighlightingDataSource(a: IDataSourceLocalDataProvider): void;
    hasValidType(a: DataSeries): boolean;
    popDataSource(): any;
    popHighlightingDataSource(): any;
    getCurrentPathSegment(): string;
    getCurrentPath(): string;
    getParentTitle(): string;
    pushPath(a: string): void;
    popPath(): any;
    pushParentTitle(a: string): void;
    popParentTitle(): any;
    private ag;
    addDataSeries(a: DataSeries, b: IDataSeriesAdapterRule): void;
    removeDataSeries(a: DataSeries): void;
    insertDataSeries(a: number, b: DataSeries, c: IDataSeriesAdapterRule): void;
    clearDataSeries(): void;
    getDataSeriesCount(): number;
    getDataSeriesAt(a: number): DataSeries;
}
/**
 * @hidden
 */
export declare class DataSeriesDataProviderAnalyzer extends Base {
    static $t: Type;
    constructor(a: DataSeriesAdapterRunContext);
    u: DataSeriesAdapterRunContext;
    private b;
    private a;
    private x;
    private w;
    private at;
    private av;
    private as;
    private au;
    get includedProperties(): string[];
    set includedProperties(a: string[]);
    get excludedProperties(): string[];
    set excludedProperties(a: string[]);
    getParentTitle(): string;
    shouldIncludeProperty(a: string, b: string): boolean;
    private z;
    private ad;
    expandCamelCasedWords(a: string): string;
    hasStringProperties(): boolean;
    getAllStringProperties(): string[];
    getAllExcludedStringProperties(): string[];
    isCollection(a: any): boolean;
    getAllPropertiesWithName(a: string): string[];
    getAllNumericProperties(): string[];
    getAllObjectProperties(): string[];
    getAllCollectionProperties(): string[];
    getFirstNumericProperty(): string;
    hasNumericProperties(): boolean;
    private ag;
    private v;
    private s;
    private r;
    private aq;
    private y;
    getAllPropertiesWithIntent(a: string): string[];
    getAllPropertiesWithValuelessIntent(a: string): string[];
    getPropertyIntentValue(a: string, b: string): string;
    getAllPropertiesWithValuedIntent(a: string): string[];
    private m;
    getAllDateTimeProperties(): string[];
    getAllExcludedDateTimeProperties(): string[];
    getFirstDateTimeProperty(): string;
    getFirstStringProperty(): string;
    hasDateTimeProperties(): boolean;
    private ak;
    private al;
    isMonotonic(a: IDataSourceLocalDataProvider, b: string, c: number): boolean;
    isEvenlySpaced(a: IDataSourceLocalDataProvider, b: string, c: number): boolean;
    private a6;
    getFirstDistinctStringProperty(a: number): string;
    getFirstDistinctNumericProperty(a: number): string;
    getFirstDistinctMonotonicNumericProperty(a: number): string;
    getFirstDistinctMonotonicNumericPropertyWithEvenSpacing(a: number): string;
    getAllDistinctMonotonicNumericProperties(a: number): string[];
    getAllExcludedDistinctMonotonicNumericProperties(a: number): string[];
    getFirstDistinctDateTimeProperty(a: number): string;
    getFirstStringPropertyPreferringDistinct(a: number): string;
    getTitleString(a: any, b: string[]): string;
    getTitleStringWithSeparator(a: any, b: string[], c: string): string;
    private az;
    getNonNullPropertyValue(a: string): any;
    private am;
    private af;
    coerceToDouble(value_: any): number;
    private aj;
    numericColumnHasDiverseValues(a: string): boolean;
    numericColumnHasNoRange(a: IDataSourceLocalDataProvider, b: string, c: number): boolean;
    shouldUseLogarithmicScale(a: IDataSourceLocalDataProvider, b: string): boolean;
}
/**
 * @hidden
 */
export declare class DataSeriesAdapterUpdateNotifier extends Base implements IDataSourceDataProviderUpdateNotifier {
    static $t: Type;
    private a;
    private b;
    constructor(a: DataSeriesAdapterImplementation, b: IDataSourceLocalDataProvider);
    notifyClearItems(): void;
    notifyInsertItem(a: number, b: any): void;
    notifyRemoveItem(a: number, b: any): void;
    notifySetItem(a: number, b: any, c: any): void;
}
/**
 * @hidden
 */
export declare class DataSeriesAdapterRuleCollection extends ObservableCollection$1<IDataSeriesAdapterRule> {
    static $t: Type;
    constructor();
}
/**
 * @hidden
 */
export declare class DataSeriesAdapterRemovingDuplicatesEventArgs extends Base {
    static $t: Type;
    b: DataSeriesAdapterRunContext;
    d: string;
    e: string;
    a: DataSeries[];
    c: boolean;
}
/**
 * @hidden
 */
export declare class DataSeriesAdapterRunEventArgs extends Base {
    static $t: Type;
    a: DataSeriesAdapterRunContext;
    b: boolean;
}
/**
 * @hidden
 */
export declare class DataSeriesAdapterImplementation extends Base implements INotifyPropertyChanged {
    static $t: Type;
    constructor();
    private at;
    private ab;
    private z;
    private aa;
    aj: (arg1: string) => string;
    aq(a: string, b: string): string;
    private a9;
    private bh;
    al: any;
    get g(): IExternalDataSeriesAdapter;
    private ai;
    private ah;
    private ak;
    propertyChanged: (sender: any, e: PropertyChangedEventArgs) => void;
    get itemsSource(): any;
    set itemsSource(a: any);
    private c;
    get supportedSeriesTypes(): DataSeriesType[];
    set supportedSeriesTypes(a: DataSeriesType[]);
    private b;
    get includedProperties(): string[];
    set includedProperties(a: string[]);
    private a;
    get excludedProperties(): string[];
    set excludedProperties(a: string[]);
    private t;
    private s;
    private r;
    private m;
    private n;
    private x;
    get sortDescriptions(): SortDescriptionCollection;
    get postSortDescriptions(): SortDescriptionCollection;
    get groupDescriptions(): SortDescriptionCollection;
    get filterExpressions(): FilterExpressionCollection;
    get highlightFilterExpressions(): FilterExpressionCollection;
    get summaryDescriptions(): SummaryDescriptionCollection;
    private _rules;
    get rules(): DataSeriesAdapterRuleCollection;
    set rules(a: DataSeriesAdapterRuleCollection);
    private _dataSeries;
    get dataSeries(): DataSeriesCollection;
    set dataSeries(a: DataSeriesCollection);
    protected a4(a: string, b: any, c: any): void;
    protected ba(a: string, b: any, c: any): void;
    private ac;
    refresh(): void;
    az(a: HashSet$1<Tuple$2<string, string>>, b: HashSet$1<Tuple$2<string, string>>): void;
    private bg;
    private av;
    private bl;
    private bf;
    private bk;
    removingUnsupported: (sender: any, args: DataSeriesAdapterRunEventArgs) => void;
    removingDuplicates: (sender: any, args: DataSeriesAdapterRemovingDuplicatesEventArgs) => void;
    private be;
    private bj;
    private bi;
    private get ae();
    private _adjustPrioritiesBasedOnFitness;
    get adjustPrioritiesBasedOnFitness(): boolean;
    set adjustPrioritiesBasedOnFitness(a: boolean);
    private ag;
    private af;
    h(a: any, b: boolean): DataSeriesAdapterProviderInfo;
    private ay;
    private ar;
    private q;
    private ax;
    private aw;
    bc(a: DataSeriesAdapterRunContext, b: any, c: string, d: boolean): void;
    private au;
    private bb;
    a5(a: IDataSourceLocalDataProvider): void;
    a6(a: IDataSourceLocalDataProvider, b: number, c: any): void;
    a7(a: IDataSourceLocalDataProvider, b: number, c: any): void;
    a8(a: IDataSourceLocalDataProvider, b: number, c: any, d: any): void;
    notifyClearItems(a: any): void;
    notifyInsertItem(a: any, b: number, c: any): void;
    notifyRemoveItem(a: any, b: number, c: any): void;
    notifySetItem(a: any, b: number, c: any, d: any): void;
}
