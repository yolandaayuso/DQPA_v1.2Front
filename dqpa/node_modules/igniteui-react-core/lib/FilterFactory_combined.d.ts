import { Base, Type } from "./type";
import { IFilterExpression } from "./IFilterExpression";
import { DataSourceSchemaPropertyType } from "./DataSourceSchemaPropertyType";
import { FilterExpressionOperatorType } from "./FilterExpressionOperatorType";
import { FilterExpressionFunctionType } from "./FilterExpressionFunctionType";
import { IDataSourceDataProvider } from "./IDataSourceDataProvider";
import { IDataSourceSchema } from "./IDataSourceSchema";
import { IFilterExpressionEnvironment } from "./IFilterExpressionEnvironment";
import { IOperationFilterExpression } from "./IOperationFilterExpression";
import { IFunctionFilterExpression } from "./IFunctionFilterExpression";
import { FilterExpressionCollection } from "./FilterExpressionCollection";
import { IPropertyReferenceFilterExpression } from "./IPropertyReferenceFilterExpression";
import { ILiteralFilterExpression } from "./ILiteralFilterExpression";
import { FilterExpressionWrapperType } from "./FilterExpressionWrapperType";
/**
 * @hidden
 */
export declare class FilterFactory extends Base {
    static $t: Type;
    private av;
    get todayOverride(): Date;
    set todayOverride(a: Date);
    private static at;
    static get instance(): FilterFactory;
    static build(a: (b: FilterFactory) => FilterExpression): FilterExpression;
    property(a: string): FilterExpression;
    literal(a: any): FilterExpression;
    group(a: IFilterExpression): FilterExpression;
    and(a: IFilterExpression, b: IFilterExpression): FilterExpression;
    or(a: IFilterExpression, b: IFilterExpression): FilterExpression;
    not(a: IFilterExpression): FilterExpression;
    add(a: IFilterExpression, b: IFilterExpression): FilterExpression;
    divide(a: IFilterExpression, b: IFilterExpression): FilterExpression;
    equal(a: IFilterExpression, b: IFilterExpression): FilterExpression;
    greaterThan(a: IFilterExpression, b: IFilterExpression): FilterExpression;
    greaterThanOrEqual(a: IFilterExpression, b: IFilterExpression): FilterExpression;
    lessThan(a: IFilterExpression, b: IFilterExpression): FilterExpression;
    lessThanOrEqual(a: IFilterExpression, b: IFilterExpression): FilterExpression;
    modulus(a: IFilterExpression, b: IFilterExpression): FilterExpression;
    multiply(a: IFilterExpression, b: IFilterExpression): FilterExpression;
    notEqual(a: IFilterExpression, b: IFilterExpression): FilterExpression;
    subtract(a: IFilterExpression, b: IFilterExpression): FilterExpression;
    ceiling(a: IFilterExpression): FilterExpression;
    concat(a: IFilterExpression, b: IFilterExpression): FilterExpression;
    concat1(a: IFilterExpression, b: string): FilterExpression;
    contains(a: IFilterExpression, b: IFilterExpression | string): FilterExpression;
    day(a: IFilterExpression): FilterExpression;
    endsWith(a: IFilterExpression, b: IFilterExpression | string): FilterExpression;
    floor(a: IFilterExpression): FilterExpression;
    hour(a: IFilterExpression): FilterExpression;
    indexOf(a: IFilterExpression, b: IFilterExpression | string): FilterExpression;
    length(a: IFilterExpression): FilterExpression;
    minute(a: IFilterExpression): FilterExpression;
    month(a: IFilterExpression): FilterExpression;
    replace(a: IFilterExpression, b: IFilterExpression | string, c: IFilterExpression | string): FilterExpression;
    round(a: IFilterExpression): FilterExpression;
    second(a: IFilterExpression): FilterExpression;
    startsWith(a: IFilterExpression, b: IFilterExpression | string): FilterExpression;
    substring(a: IFilterExpression, b: IFilterExpression | number, c?: IFilterExpression | number): FilterExpression;
    toLower(a: IFilterExpression): FilterExpression;
    toUpper(a: IFilterExpression): FilterExpression;
    trim(a: IFilterExpression): FilterExpression;
    year(a: IFilterExpression): FilterExpression;
    date(a: IFilterExpression): FilterExpression;
    time(a: IFilterExpression): FilterExpression;
    now(): FilterExpression;
    isOf(a: IFilterExpression, b: DataSourceSchemaPropertyType): FilterExpression;
    cast(a: IFilterExpression, b: DataSourceSchemaPropertyType): FilterExpression;
    env(a: IFilterExpression): FilterExpression;
}
/**
 * @hidden
 */
export declare abstract class FilterExpression extends Base implements IFilterExpression {
    static $t: Type;
    private bj;
    private _precedence;
    protected get_precedence(): number;
    get precedence(): number;
    private bk;
    markAutoGenerated(): void;
    get isAutoGenerated(): boolean;
    static isFilterExpression(a: any): boolean;
    static isSchemaType(a: any): boolean;
    static operation(a: IFilterExpression | string, b: FilterExpressionOperatorType, c: IFilterExpression | any): OperationFilterExpression;
    static func(a: FilterExpressionFunctionType, ...b: IFilterExpression[]): FunctionFilterExpression;
    protected bq(): void;
    protected abstract bo(): boolean;
    static property(a: string): PropertyReferenceFilterExpression;
    static nullLiteral(): LiteralFilterExpression;
    static literal(a: any): LiteralFilterExpression;
    static unquotedLiteral(a: string): LiteralFilterExpression;
    match(a: any, b: IDataSourceDataProvider, c: IDataSourceSchema): boolean;
    matchWithEnvironment(a: any, b: IDataSourceDataProvider, c: IDataSourceSchema, d: IFilterExpressionEnvironment): boolean;
    bp(a: any, b: IDataSourceDataProvider, c: IDataSourceSchema): boolean;
    private bl;
    evaluate(a: any, b: IDataSourceDataProvider, c: IDataSourceSchema): any;
    abstract evaluateWithEnvironment(a: any, b: IDataSourceDataProvider, c: IDataSourceSchema, d: IFilterExpressionEnvironment): any;
    protected get_isPropertyReference(): boolean;
    get isPropertyReference(): boolean;
    protected get_isOperation(): boolean;
    get isOperation(): boolean;
    protected get_isFunction(): boolean;
    get isFunction(): boolean;
    protected get_isLiteral(): boolean;
    get isLiteral(): boolean;
    protected get_isNull(): boolean;
    get isNull(): boolean;
    protected get_isWrapper(): boolean;
    get isWrapper(): boolean;
    group(): FilterExpression;
    and(a: IFilterExpression): FilterExpression;
    or(a: IFilterExpression): FilterExpression;
    not(): FilterExpression;
    add(a: IFilterExpression | any): FilterExpression;
    plus(a: IFilterExpression | any): FilterExpression;
    divide(a: IFilterExpression | any): FilterExpression;
    divideBy(a: IFilterExpression | any): FilterExpression;
    isEqualTo(a: IFilterExpression | any): FilterExpression;
    isGreaterThan(a: IFilterExpression | any): FilterExpression;
    isGreaterThanOrEqualTo(a: IFilterExpression | any): FilterExpression;
    isLessThan(a: IFilterExpression | any): FilterExpression;
    isLessThanOrEqualTo(a: IFilterExpression | any): FilterExpression;
    modulo(a: IFilterExpression | any): FilterExpression;
    multiply(a: IFilterExpression | any): FilterExpression;
    times(a: IFilterExpression | any): FilterExpression;
    isNotEqualTo(a: IFilterExpression | any): FilterExpression;
    subtract(a: IFilterExpression | any): FilterExpression;
    minus(a: IFilterExpression | any): FilterExpression;
    ceiling(): FilterExpression;
    concat(a: IFilterExpression | string): FilterExpression;
    contains(a: IFilterExpression | string): FilterExpression;
    day(): FilterExpression;
    endsWith(a: IFilterExpression | string): FilterExpression;
    floor(): FilterExpression;
    hour(): FilterExpression;
    indexOf(a: IFilterExpression | string): FilterExpression;
    length(): FilterExpression;
    minute(): FilterExpression;
    month(): FilterExpression;
    isToday(): FilterExpression;
    isTomorrow(): FilterExpression;
    isYesterday(): FilterExpression;
    isThisWeek(): FilterExpression;
    isNextWeek(): FilterExpression;
    isLastWeek(): FilterExpression;
    isThisMonth(): FilterExpression;
    isNextMonth(): FilterExpression;
    isLastMonth(): FilterExpression;
    isThisYear(): FilterExpression;
    isNextYear(): FilterExpression;
    isLastYear(): FilterExpression;
    isYearToDate(): FilterExpression;
    isThisQuarter(): FilterExpression;
    isNextQuarter(): FilterExpression;
    isLastQuarter(): FilterExpression;
    isQ1(): FilterExpression;
    isQ2(): FilterExpression;
    isQ3(): FilterExpression;
    isQ4(): FilterExpression;
    replace(a: IFilterExpression | string, b: IFilterExpression | string): FilterExpression;
    round(): FilterExpression;
    second(): FilterExpression;
    startsWith(a: IFilterExpression | string): FilterExpression;
    substring(a: IFilterExpression | number, b?: IFilterExpression | number): FilterExpression;
    toLower(): FilterExpression;
    toUpper(): FilterExpression;
    trim(): FilterExpression;
    year(): FilterExpression;
    date(): FilterExpression;
    time(): FilterExpression;
    now(): FilterExpression;
    isOf(a: IFilterExpression | string): FilterExpression;
    cast(a: IFilterExpression | DataSourceSchemaPropertyType | string): FilterExpression;
    env(a: string): FilterExpression;
}
/**
 * @hidden
 */
export declare class OperationFilterExpression extends FilterExpression implements IOperationFilterExpression {
    static $t: Type;
    constructor(a: any, b: FilterExpressionOperatorType, c: any);
    private bs;
    private bu;
    private bt;
    private bv;
    private br;
    protected get_isOperation(): boolean;
    protected bo(): boolean;
    get isComparisonOperation(): boolean;
    get propertyName(): string;
    set propertyName(a: string);
    get hasPropertyName(): boolean;
    get value(): any;
    set value(a: any);
    get hasValue(): boolean;
    get left(): IFilterExpression;
    set left(a: IFilterExpression);
    get hasLeft(): boolean;
    get right(): IFilterExpression;
    set right(a: IFilterExpression);
    get hasRight(): boolean;
    get operator(): FilterExpressionOperatorType;
    set operator(a: FilterExpressionOperatorType);
    get hasOperator(): boolean;
    protected get b1(): boolean;
    protected get_precedence(): number;
    evaluateWithEnvironment(a: any, b: IDataSourceDataProvider, c: IDataSourceSchema, d: IFilterExpressionEnvironment): any;
    private b5;
    static b3(a: any): number;
    private b6;
    private b4;
}
/**
 * @hidden
 */
export declare class FunctionFilterExpression extends FilterExpression implements IFunctionFilterExpression {
    static $t: Type;
    constructor(a: FilterExpressionFunctionType, ...b: IFilterExpression[]);
    private bs;
    private br;
    protected get_isFunction(): boolean;
    protected bo(): boolean;
    get functionType(): FilterExpressionFunctionType;
    set functionType(a: FilterExpressionFunctionType);
    protected get bt(): boolean;
    get functionArguments(): FilterExpressionCollection;
    get hasFunctionArguments(): boolean;
    evaluateWithEnvironment(a: any, b: IDataSourceDataProvider, c: IDataSourceSchema, d: IFilterExpressionEnvironment): any;
    protected get_precedence(): number;
    private bu;
    private bw;
    private bv;
}
/**
 * @hidden
 */
export declare class PropertyReferenceFilterExpression extends FilterExpression implements IPropertyReferenceFilterExpression {
    static $t: Type;
    constructor(a: string);
    protected get_isPropertyReference(): boolean;
    protected get_precedence(): number;
    protected bo(): boolean;
    private br;
    get propertyReference(): string;
    set propertyReference(a: string);
    evaluateWithEnvironment(a: any, b: IDataSourceDataProvider, c: IDataSourceSchema, d: IFilterExpressionEnvironment): any;
}
/**
 * @hidden
 */
export declare class LiteralFilterExpression extends FilterExpression implements ILiteralFilterExpression {
    static $t: Type;
    constructor(a: any, b: boolean);
    protected get_precedence(): number;
    private bs;
    private br;
    protected get_isLiteral(): boolean;
    protected get_isNull(): boolean;
    get literalValue(): any;
    set literalValue(a: any);
    get leaveUnquoted(): boolean;
    set leaveUnquoted(a: boolean);
    protected bo(): boolean;
    evaluateWithEnvironment(a: any, b: IDataSourceDataProvider, c: IDataSourceSchema, d: IFilterExpressionEnvironment): any;
}
/**
 * @hidden
 */
export declare abstract class WrapperExpression extends FilterExpression {
    static $t: Type;
    private br;
    private bx;
    abstract getWrapperType(): FilterExpressionWrapperType;
    private _innerExpression;
    get innerExpression(): IFilterExpression;
    set innerExpression(a: IFilterExpression);
    get expression(): FilterExpression;
    set expression(a: FilterExpression);
    get propertyName(): string;
    set propertyName(a: string);
    protected get_isWrapper(): boolean;
    protected get_precedence(): number;
    protected get bu(): FilterFactory;
    constructor(a: number, b: string);
    constructor(a: number, b: FilterExpression);
    constructor(a: number, ..._rest: any[]);
    protected bo(): boolean;
    evaluateWithEnvironment(a: any, b: IDataSourceDataProvider, c: IDataSourceSchema, d: IFilterExpressionEnvironment): any;
    protected abstract bv(): IFilterExpression;
}
/**
 * @hidden
 */
export declare class TodayExpression extends WrapperExpression {
    static $t: Type;
    constructor(a: number, b: string);
    constructor(a: number, b: FilterExpression);
    constructor(a: number, ..._rest: any[]);
    getWrapperType(): FilterExpressionWrapperType;
    protected bv(): IFilterExpression;
}
/**
 * @hidden
 */
export declare class TomorrowExpression extends WrapperExpression {
    static $t: Type;
    constructor(a: number, b: string);
    constructor(a: number, b: FilterExpression);
    constructor(a: number, ..._rest: any[]);
    getWrapperType(): FilterExpressionWrapperType;
    protected bv(): IFilterExpression;
}
/**
 * @hidden
 */
export declare class YesterdayExpression extends WrapperExpression {
    static $t: Type;
    constructor(a: number, b: string);
    constructor(a: number, b: FilterExpression);
    constructor(a: number, ..._rest: any[]);
    getWrapperType(): FilterExpressionWrapperType;
    protected bv(): IFilterExpression;
}
/**
 * @hidden
 */
export declare abstract class OffsettableWeekExpression extends WrapperExpression {
    static $t: Type;
    constructor(a: number, b: string);
    constructor(a: number, b: FilterExpression);
    constructor(a: number, ..._rest: any[]);
    protected bz: number;
    protected bv(): IFilterExpression;
}
/**
 * @hidden
 */
export declare class ThisWeekExpression extends OffsettableWeekExpression {
    static $t: Type;
    constructor(a: number, b: string);
    constructor(a: number, b: FilterExpression);
    constructor(a: number, ..._rest: any[]);
    getWrapperType(): FilterExpressionWrapperType;
}
/**
 * @hidden
 */
export declare class NextWeekExpression extends OffsettableWeekExpression {
    static $t: Type;
    constructor(a: number, b: string);
    constructor(a: number, b: FilterExpression);
    constructor(a: number, ..._rest: any[]);
    getWrapperType(): FilterExpressionWrapperType;
}
/**
 * @hidden
 */
export declare class LastWeekExpression extends OffsettableWeekExpression {
    static $t: Type;
    constructor(a: number, b: string);
    constructor(a: number, b: FilterExpression);
    constructor(a: number, ..._rest: any[]);
    getWrapperType(): FilterExpressionWrapperType;
}
/**
 * @hidden
 */
export declare class ThisMonthExpression extends WrapperExpression {
    static $t: Type;
    constructor(a: number, b: string);
    constructor(a: number, b: FilterExpression);
    constructor(a: number, ..._rest: any[]);
    getWrapperType(): FilterExpressionWrapperType;
    protected bv(): IFilterExpression;
}
/**
 * @hidden
 */
export declare class NextMonthExpression extends WrapperExpression {
    static $t: Type;
    constructor(a: number, b: string);
    constructor(a: number, b: FilterExpression);
    constructor(a: number, ..._rest: any[]);
    getWrapperType(): FilterExpressionWrapperType;
    protected bv(): IFilterExpression;
}
/**
 * @hidden
 */
export declare class LastMonthExpression extends WrapperExpression {
    static $t: Type;
    constructor(a: number, b: string);
    constructor(a: number, b: FilterExpression);
    constructor(a: number, ..._rest: any[]);
    getWrapperType(): FilterExpressionWrapperType;
    protected bv(): IFilterExpression;
}
/**
 * @hidden
 */
export declare class ThisYearExpression extends WrapperExpression {
    static $t: Type;
    constructor(a: number, b: string);
    constructor(a: number, b: FilterExpression);
    constructor(a: number, ..._rest: any[]);
    getWrapperType(): FilterExpressionWrapperType;
    protected bv(): IFilterExpression;
}
/**
 * @hidden
 */
export declare class NextYearExpression extends WrapperExpression {
    static $t: Type;
    constructor(a: number, b: string);
    constructor(a: number, b: FilterExpression);
    constructor(a: number, ..._rest: any[]);
    getWrapperType(): FilterExpressionWrapperType;
    protected bv(): IFilterExpression;
}
/**
 * @hidden
 */
export declare class LastYearExpression extends WrapperExpression {
    static $t: Type;
    constructor(a: number, b: string);
    constructor(a: number, b: FilterExpression);
    constructor(a: number, ..._rest: any[]);
    getWrapperType(): FilterExpressionWrapperType;
    protected bv(): IFilterExpression;
}
/**
 * @hidden
 */
export declare class YearToDateExpression extends WrapperExpression {
    static $t: Type;
    constructor(a: number, b: string);
    constructor(a: number, b: FilterExpression);
    constructor(a: number, ..._rest: any[]);
    getWrapperType(): FilterExpressionWrapperType;
    protected bv(): IFilterExpression;
}
/**
 * @hidden
 */
export declare class ThisQuarterExpression extends WrapperExpression {
    static $t: Type;
    constructor(a: number, b: string);
    constructor(a: number, b: FilterExpression);
    constructor(a: number, ..._rest: any[]);
    getWrapperType(): FilterExpressionWrapperType;
    protected bv(): IFilterExpression;
}
/**
 * @hidden
 */
export declare class NextQuarterExpression extends WrapperExpression {
    static $t: Type;
    constructor(a: number, b: string);
    constructor(a: number, b: FilterExpression);
    constructor(a: number, ..._rest: any[]);
    getWrapperType(): FilterExpressionWrapperType;
    protected bv(): IFilterExpression;
}
/**
 * @hidden
 */
export declare class LastQuarterExpression extends WrapperExpression {
    static $t: Type;
    constructor(a: number, b: string);
    constructor(a: number, b: FilterExpression);
    constructor(a: number, ..._rest: any[]);
    getWrapperType(): FilterExpressionWrapperType;
    protected bv(): IFilterExpression;
}
/**
 * @hidden
 */
export declare class Q1Expression extends WrapperExpression {
    static $t: Type;
    constructor(a: number, b: string);
    constructor(a: number, b: FilterExpression);
    constructor(a: number, ..._rest: any[]);
    getWrapperType(): FilterExpressionWrapperType;
    protected bv(): IFilterExpression;
}
/**
 * @hidden
 */
export declare class Q2Expression extends WrapperExpression {
    static $t: Type;
    constructor(a: number, b: string);
    constructor(a: number, b: FilterExpression);
    constructor(a: number, ..._rest: any[]);
    getWrapperType(): FilterExpressionWrapperType;
    protected bv(): IFilterExpression;
}
/**
 * @hidden
 */
export declare class Q3Expression extends WrapperExpression {
    static $t: Type;
    constructor(a: number, b: string);
    constructor(a: number, b: FilterExpression);
    constructor(a: number, ..._rest: any[]);
    getWrapperType(): FilterExpressionWrapperType;
    protected bv(): IFilterExpression;
}
/**
 * @hidden
 */
export declare class Q4Expression extends WrapperExpression {
    static $t: Type;
    constructor(a: number, b: string);
    constructor(a: number, b: FilterExpression);
    constructor(a: number, ..._rest: any[]);
    getWrapperType(): FilterExpressionWrapperType;
    protected bv(): IFilterExpression;
}
