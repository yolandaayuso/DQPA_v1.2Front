import { Base, Point, Type } from "./type";
import { Rect } from "./Rect";
import { ModifierKeys } from "./ModifierKeys";
import { NormalizedEvent, DomWrapper } from "./dom";
import { Key } from "./Key";
/**
 * @hidden
 */
export declare abstract class EventProxy extends Base {
    static $t: Type;
    onMouseWheel: (point: Point, delta: number) => boolean;
    onMouseWheelHorizontal: (point: Point, delta: number) => boolean;
    onPinchStarted: (point: Point, scale: number) => void;
    onPinchDelta: (point: Point, scale: number) => void;
    onGestureCompleted: (point: Point, scale: number) => void;
    onZoomStarted: (point: Point, scaleX: number, scaleY: number, isoScale: number) => void;
    onZoomDelta: (point: Point, scaleX: number, scaleY: number, isoScale: number) => void;
    onZoomCompleted: (point: Point, scaleX: number, scaleY: number, isoScale: number) => void;
    onFlingStarted: (point: Point, velocityX: number, velocityY: number) => boolean;
    onContactStarted: (point: Point, isFinger: boolean) => void;
    onManipulationCancelled: (point: Point) => void;
    onDragStarted: (point: Point) => void;
    onContactMoved: (point: Point, isFinger: boolean) => void;
    onDragDelta: (point: Point) => void;
    onContactCompleted: (point: Point, isFinger: boolean) => void;
    onDragCompleted: (point: Point) => void;
    onMouseLeave: (point: Point) => void;
    onMouseOver: (point: Point, onMouseMove: boolean, isFinger: boolean) => void;
    onMouseEnter: (point: Point) => void;
    onMouseDown: (point: Point) => void;
    onMouseUp: (point: Point) => void;
    onDoubleTap: (point: Point) => void;
    onHold: (point: Point) => void;
    onKeyDown: (key: Key) => boolean;
    onKeyUp: (key: Key) => boolean;
    abstract bk(a: DomWrapper): Rect;
    bl: Rect;
    bi: ModifierKeys;
    al: boolean;
    am: boolean;
    ao: (arg1: Point) => boolean;
    aq: (arg1: Point, arg2: boolean, arg3: boolean) => boolean;
    protected ad(a: Point, b: boolean, c: boolean): boolean;
    ar: (arg1: NormalizedEvent) => boolean;
    abstract d(): EventProxy;
    abstract av(): void;
    protected get_an(): boolean;
    get an(): boolean;
    as: any;
    protected get_ac(): boolean;
    get ac(): boolean;
    au(): void;
    protected aj(a: Point, b: number): boolean;
    protected ak(a: Point, b: number): boolean;
    protected bd(a: Point, b: number): void;
    protected bg(a: Point, b: number, c: number, d: number): void;
    protected ag(a: Point, b: number, c: number): boolean;
    protected bc(a: Point, b: number): void;
    protected bf(a: Point, b: number, c: number, d: number): void;
    protected be(a: Point, b: number, c: number, d: number): void;
    protected a4(a: Point, b: number): void;
    protected a6(a: Point): void;
    protected az(a: Point, b: boolean): void;
    protected a3(a: Point): void;
    protected ay(a: Point, b: boolean): void;
    protected a2(a: Point): void;
    protected ax(a: Point, b: boolean, c: boolean): void;
    protected a1(a: Point): void;
    protected a9(a: Point): void;
    protected ba(a: Point, b: boolean, c: boolean): void;
    protected a8(a: Point): void;
    protected a7(a: Point): void;
    protected bb(a: Point): void;
    protected ah(a: Key): boolean;
    protected ai(a: Key): boolean;
    protected a0(a: Point): void;
    protected a5(a: Point): void;
    abstract bj(): Point;
    private aa;
    get ae(): boolean;
    set ae(a: boolean);
    ab: boolean;
    af: boolean;
    ap: (arg1: Point) => boolean;
    protected aw(): void;
    abstract at(a: any, b: string): void;
    abstract bh(a: any, b: string): void;
}
