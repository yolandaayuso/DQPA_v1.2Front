/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { __extends } from "tslib";
import { Base, Point_$type, typeCast, markType } from "./type";
import { Brush } from "./Brush";
import { MathUtil } from "./MathUtil";
import { LinearGradientBrush } from "./LinearGradientBrush";
import { StringBuilder } from "./StringBuilder";
import { CultureInfo } from "./culture";
import { isNaN_, isInfinity } from "./number";
import { numberToString } from "./numberExtended";
/**
 * @hidden
 */
var CSSColorUtil = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(CSSColorUtil, _super);
    function CSSColorUtil() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CSSColorUtil.g = function (a) {
        return Brush.create(a);
    };
    CSSColorUtil.a = function (a) {
        var b = a[0];
        var c = a[1];
        if (isNaN_(b.x) || isNaN_(b.y)) {
            b = { $type: Point_$type, x: 0.5, y: 1 };
        }
        if (isNaN_(c.x) || isNaN_(c.y)) {
            c = { $type: Point_$type, x: 0.5, y: 0 };
        }
        var d = Math.atan2(c.y - b.y, c.x - b.x);
        d -= Math.PI;
        d = MathUtil.f(d);
        d = CSSColorUtil.b(d);
        return d;
    };
    CSSColorUtil.c = function (a) {
        if (a == null) {
            return null;
        }
        if (typeCast(LinearGradientBrush.$, a) !== null) {
            return CSSColorUtil.e(a);
        }
        else {
            return CSSColorUtil.f(a);
        }
    };
    CSSColorUtil.b = function (a) {
        if (isNaN_(a) || isInfinity(a)) {
            return a;
        }
        while (a > 360) {
            a -= 360;
        }
        while (a < 0) {
            a += 360;
        }
        return a;
    };
    CSSColorUtil.e = function (a) {
        var b = CSSColorUtil.a([{ $type: Point_$type, x: a.startX, y: a.startY }, { $type: Point_$type, x: a.endX, y: a.endY }]);
        var c = new StringBuilder(0);
        c.l("linear-gradient(");
        c.l(numberToString(b, CultureInfo.invariantCulture));
        c.l("deg");
        if (a.gradientStops != null && a.gradientStops.length > 0) {
            var f = a.gradientStops;
            for (var e = 0; e < f.length; e++) {
                var d = f[e];
                c.l(", ");
                c.l(CSSColorUtil.d(d.color));
                if (!isNaN_(d.offset)) {
                    c.l(" ");
                    c.l(numberToString((d.offset * 100), CultureInfo.invariantCulture) + "%");
                }
            }
        }
        c.l(")");
        return c.toString();
    };
    CSSColorUtil.f = function (a) {
        return CSSColorUtil.d(a.color);
    };
    CSSColorUtil.d = function (a) {
        return "rgba(" + a.o.toString() + ", " + a.n.toString() + ", " + a.m.toString() + ", " + (a.l / 255).toString() + ")";
    };
    CSSColorUtil.$t = markType(CSSColorUtil, 'CSSColorUtil');
    return CSSColorUtil;
}(Base));
export { CSSColorUtil };
