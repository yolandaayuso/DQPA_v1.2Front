/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { __extends } from "tslib";
import { Base, markType, Point_$type } from "./type";
import { PathFigureCollection } from "./PathFigureCollection";
import { List$1 } from "./List$1";
import { PathMarkupToken } from "./PathMarkupToken";
import { PathFigure } from "./PathFigure";
import { LineSegment } from "./LineSegment";
import { BezierSegment } from "./BezierSegment";
import { ArcSegment } from "./ArcSegment";
import { Size } from "./Size";
import { InvalidOperationException } from "./InvalidOperationException";
import { stringEmpty } from "./string";
/**
 * @hidden
 */
var Geometry = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(Geometry, _super);
    function Geometry() {
        return _super.call(this) || this;
    }
    Geometry.a = function (a) {
        if (a != null) {
            var b = new PathMarkupParser();
            return b.k(a);
        }
        return null;
    };
    Geometry.$t = markType(Geometry, 'Geometry');
    return Geometry;
}(Base));
export { Geometry };
/**
 * @hidden
 */
var PathGeometry = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(PathGeometry, _super);
    function PathGeometry() {
        var _this = _super.call(this) || this;
        _this.c = null;
        _this.c = new PathFigureCollection();
        return _this;
    }
    PathGeometry.prototype.get_b = function () {
        return 4;
    };
    Object.defineProperty(PathGeometry.prototype, "b", {
        get: function () {
            return this.get_b();
        },
        enumerable: false,
        configurable: true
    });
    PathGeometry.$t = markType(PathGeometry, 'PathGeometry', Geometry.$);
    return PathGeometry;
}(Geometry));
export { PathGeometry };
/**
 * @hidden
 */
var PathMarkupParser = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(PathMarkupParser, _super);
    function PathMarkupParser() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.e = '\0';
        _this.h = 0;
        _this.l = { $type: Point_$type, x: 0, y: 0 };
        _this.f = null;
        _this.i = null;
        return _this;
    }
    PathMarkupParser.prototype.k = function (a) {
        this.f = new List$1(PathMarkupToken.$, 0);
        this.h = 0;
        var _loop_1 = function () {
            switch (this_1.e) {
                case 'M':
                case 'm':
                    this_1.f.add(new PathMarkupToken(0, this_1.e.charCodeAt(0) < 'm'.charCodeAt(0)));
                    break;
                case 'L':
                case 'l':
                    this_1.f.add(new PathMarkupToken(1, this_1.e.charCodeAt(0) < 'l'.charCodeAt(0)));
                    break;
                case 'H':
                case 'h':
                    this_1.f.add(new PathMarkupToken(2, this_1.e.charCodeAt(0) < 'h'.charCodeAt(0)));
                    break;
                case 'V':
                case 'v':
                    this_1.f.add(new PathMarkupToken(3, this_1.e.charCodeAt(0) < 'v'.charCodeAt(0)));
                    break;
                case 'C':
                case 'c':
                    this_1.f.add(new PathMarkupToken(4, this_1.e.charCodeAt(0) < 'c'.charCodeAt(0)));
                    break;
                case 'Q':
                case 'q':
                    this_1.f.add(new PathMarkupToken(5, this_1.e.charCodeAt(0) < 'q'.charCodeAt(0)));
                    break;
                case 'S':
                case 's':
                    this_1.f.add(new PathMarkupToken(6, this_1.e.charCodeAt(0) < 's'.charCodeAt(0)));
                    break;
                case 'T':
                case 't':
                    this_1.f.add(new PathMarkupToken(7, this_1.e.charCodeAt(0) < 't'.charCodeAt(0)));
                    break;
                case 'A':
                case 'a':
                    this_1.f.add(new PathMarkupToken(8, this_1.e.charCodeAt(0) < 'a'.charCodeAt(0)));
                    break;
                case 'Z':
                case 'z':
                    this_1.f.add(new PathMarkupToken(9, this_1.e.charCodeAt(0) < 'z'.charCodeAt(0)));
                    break;
            }
            if (this_1.a(this_1.e)) {
                var b = true;
                var c = false;
                var d = false;
                var e_1 = stringEmpty();
                var f = false;
                this_1.h = this_1.h - 1;
                while (this_1.h < a.length) {
                    var g = a.charAt(this_1.h);
                    if (d) {
                        if (!this_1.a(g)) {
                            f = true;
                            break;
                        }
                        else {
                            e_1 += g;
                            this_1.h++;
                            if (this_1.h >= a.length) {
                                f = true;
                                break;
                            }
                        }
                    }
                    else if (c) {
                        if (g == 'e' || g == 'E') {
                            d = true;
                            e_1 += g;
                            this_1.h++;
                            continue;
                        }
                        if ((g == '-' || g == '+') && e_1.length > 0) {
                            f = true;
                            break;
                        }
                        if (!this_1.a(g)) {
                            f = true;
                            break;
                        }
                        else {
                            e_1 += g;
                            this_1.h++;
                            if (this_1.h >= a.length) {
                                f = true;
                                break;
                            }
                        }
                    }
                    else if (b) {
                        if (g == '.') {
                            c = true;
                            e_1 += g;
                            this_1.h++;
                            continue;
                        }
                        if (g == 'e' || g == 'E') {
                            d = true;
                            e_1 += g;
                            this_1.h++;
                            continue;
                        }
                        if ((g == '-' || g == '+') && e_1.length > 0) {
                            f = true;
                            break;
                        }
                        if (!this_1.a(g)) {
                            f = true;
                            break;
                        }
                        else {
                            e_1 += g;
                            this_1.h++;
                            if (this_1.h >= a.length) {
                                f = true;
                                break;
                            }
                        }
                    }
                }
                if (f) {
                    this_1.f.add(((function () {
                        var $ret = new PathMarkupToken(10, false);
                        $ret.b = parseFloat(e_1);
                        return $ret;
                    })()));
                }
            }
        };
        var this_1 = this;
        while (this.d(a)) {
            _loop_1();
        }
        return this.j();
    };
    PathMarkupParser.prototype.a = function (a) {
        return a == '.' || a == '-' || a == '+' || (a.charCodeAt(0) >= '0'.charCodeAt(0) && a.charCodeAt(0) <= '9'.charCodeAt(0));
    };
    PathMarkupParser.prototype.j = function () {
        var _this = this;
        this.h = 0;
        var a = true;
        var b = new PathGeometry();
        var c = null;
        var d = 11;
        var e = null;
        var f = null;
        var g = null;
        while (this.h < this.f.count) {
            var h = this.f._inner[this.h++];
            if (a && h.c != 0) {
                return null;
            }
            switch (h.c) {
                case 0:
                    c = new PathFigure();
                    b.c.add(c);
                    this.l = this.m(h.a);
                    c._startPoint = this.l;
                    while (this.b()) {
                        this.l = this.m(h.a);
                        c._segments.add(new LineSegment(0, this.l));
                    }
                    d = 0;
                    break;
                case 1:
                case 2:
                case 3:
                    if (c == null) {
                        return null;
                    }
                    do {
                        switch (h.c) {
                            case 1:
                                this.l = this.m(h.a);
                                break;
                            case 2:
                                this.l.x = h.a ? this.g() : this.l.x + this.g();
                                break;
                            case 3:
                                this.l.y = h.a ? this.g() : this.l.y + this.g();
                                break;
                        }
                        c._segments.add(new LineSegment(0, this.l));
                    } while (this.b());
                    d = 1;
                    break;
                case 4:
                case 6:
                    if (c == null) {
                        return null;
                    }
                    do {
                        if (h.c == 6) {
                            if (d == 4) {
                                e = { $type: Point_$type, x: 2 * this.l.x - f.x, y: 2 * this.l.y - f.y };
                            }
                            else {
                                e = this.l;
                            }
                        }
                        else {
                            e = this.m(h.a);
                        }
                        f = this.m(h.a);
                        g = this.m(h.a);
                        c._segments.add(new BezierSegment(1, e, f, g));
                        this.l = g;
                        d = 4;
                    } while (this.b());
                    break;
                case 5:
                case 7: break;
                case 8:
                    if (c == null) {
                        return null;
                    }
                    var _loop_2 = function () {
                        var i = this_2.g();
                        var j = this_2.g();
                        var k = this_2.g();
                        var l = this_2.g();
                        var m = this_2.g();
                        this_2.l = this_2.m(h.a);
                        c._segments.add(((function () {
                            var $ret = new ArcSegment();
                            $ret.e = _this.l;
                            $ret.f = new Size(1, i, j);
                            $ret.c = k;
                            $ret.b = l == 1;
                            $ret.d = m == 1 ? 1 : 0;
                            return $ret;
                        })()));
                    };
                    var this_2 = this;
                    do {
                        _loop_2();
                    } while (this.b());
                    d = 8;
                    break;
                case 9:
                    if (c == null) {
                        return null;
                    }
                    c._isClosed = true;
                    break;
            }
            a = false;
        }
        return b;
    };
    PathMarkupParser.prototype.m = function (a) {
        var b = this.g();
        var c = this.g();
        if (!a) {
            b += this.l.x;
            c += this.l.y;
        }
        return { $type: Point_$type, x: b, y: c };
    };
    PathMarkupParser.prototype.g = function () {
        var a = this.f._inner[this.h++];
        if (a.c != 10) {
            throw new InvalidOperationException(0);
        }
        return a.b;
    };
    PathMarkupParser.prototype.b = function () {
        if (this.h >= this.f.count) {
            return false;
        }
        return this.f._inner[this.h].c == 10;
    };
    PathMarkupParser.prototype.d = function (a) {
        while (this.h < a.length && this.c(a.charAt(this.h))) {
            this.h++;
        }
        if (this.h < a.length) {
            this.e = a.charAt(this.h);
            this.h++;
            return true;
        }
        return false;
    };
    PathMarkupParser.prototype.c = function (a) {
        return a == '\r' || a == '\n' || a == ' ' || a == '\t';
    };
    PathMarkupParser.$t = markType(PathMarkupParser, 'PathMarkupParser');
    return PathMarkupParser;
}(Base));
export { PathMarkupParser };
