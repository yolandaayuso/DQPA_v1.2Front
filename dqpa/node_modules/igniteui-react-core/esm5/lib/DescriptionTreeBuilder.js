/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { __extends } from "tslib";
import { Base, String_$type, typeCast, Array_$type, markType } from "./type";
import { List$1 } from "./List$1";
import { HashSet$1 } from "./HashSet$1";
import { DescriptionTreeNode } from "./DescriptionTreeNode";
import { Description } from "./Description";
/**
 * @hidden
 */
var DescriptionTreeBuilder = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(DescriptionTreeBuilder, _super);
    function DescriptionTreeBuilder() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DescriptionTreeBuilder.c = function (item_) {
        var propertyKey_ = null;
        var ret_ = new List$1(String_$type, 0);
        var seen_ = new HashSet$1(String_$type, 0);
        var exclusions_ = {};
        var seen = new Set();
        var comp = item_;
        while (comp = (comp.prototype || Object.getPrototypeOf(comp))) {
            if (comp == Base.prototype) {
                break;
            }
            var props = Object.getOwnPropertyNames(comp.constructor.prototype);
            for (var i = 0; i < props.length; i++) {
                if (!seen.has(props[i])) {
                    seen.add(props[i]);
                    ret_.add(props[i]);
                }
            }
        }
        ;
        return ret_;
    };
    DescriptionTreeBuilder.createTree = function (a, description_) {
        return DescriptionTreeBuilder.createTreeWithOptions(a, description_, false);
    };
    DescriptionTreeBuilder.createTreeWithOptions = function (a, description_, b) {
        var c = new DescriptionTreeNode();
        if (description_ == null) {
            return null;
        }
        var d = DescriptionTreeBuilder.c(description_);
        for (var e = 0; e < d.count; e++) {
            var key_ = d._inner[e];
            if (key_.toLowerCase() != "type" && !description_.b(DescriptionTreeBuilder.d(key_))) {
                continue;
            }
            var f = description_[key_];
            if (typeCast(Description.$, f) !== null) {
                var g = DescriptionTreeBuilder.createTree(a, f);
                f = g;
            }
            if (typeCast(Array_$type, f) !== null) {
                var h = f;
                var i = new Array(h.length);
                for (var j = 0; j < i.length; j++) {
                    var k = h[j];
                    if (typeCast(Description.$, k) !== null) {
                        var l = DescriptionTreeBuilder.createTree(a, k);
                        i[j] = l;
                    }
                    else {
                        i[j] = k;
                    }
                }
                f = i;
            }
            if (key_.toLowerCase() == "type") {
                c.i = f;
            }
            c.j(DescriptionTreeBuilder.d(key_), f);
        }
        if (c.c("type")) {
            var m = c.a("type").b;
            var n = c.f();
            for (var o = 0; o < n.count; o++) {
                var p = n._inner[o];
                p.a = a.getMetadata(m, p.c);
            }
        }
        return c;
    };
    DescriptionTreeBuilder.d = function (key_) {
        if (key_ == null) {
            return null;
        }
        return key_.substr(0, 1).toUpperCase() + key_.substr(1);
    };
    DescriptionTreeBuilder.$t = markType(DescriptionTreeBuilder, 'DescriptionTreeBuilder');
    return DescriptionTreeBuilder;
}(Base));
export { DescriptionTreeBuilder };
