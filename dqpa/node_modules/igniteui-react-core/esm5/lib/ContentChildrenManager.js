import * as React from "react";
var ContentChildrenManager = /** @class */ /*@__PURE__*/ (function () {
    function ContentChildrenManager(getPropsKey, getKey, updateContentChildren) {
        this._contentChildren = null;
        this._contentChildrenActual = null;
        this._contentChildrenMap = null;
        this._contentChildrenUnresolvedSet = null;
        this._contentChildrenUnresolved = 0;
        this.getChildRef = this.getChildRef.bind(this);
        this._getPropsKey = getPropsKey;
        this._getKey = getKey;
        this._updateContentChildren = updateContentChildren;
        this._contentChildrenUnresolvedSet = new Set();
    }
    ContentChildrenManager.prototype.getChildren = function (propChildren) {
        var _this = this;
        var children = [];
        React.Children.forEach(propChildren, function (ch) {
            var key = _this._getPropsKey(ch);
            if (key === undefined) {
                throw new Error("each child must have a unique key or name property");
            }
            if (typeof ch.type === "string") {
                // this is a HTML element, not a React Component
                children.push(React.cloneElement(ch, {
                    key: key
                }));
            }
            else if (!ch.props.name) {
                children.push(React.cloneElement(ch, {
                    key: key,
                    name: key,
                    ref: _this.getChildRef,
                    originalRef: ch.ref
                }));
            }
            else {
                children.push(React.cloneElement(ch, {
                    key: key,
                    ref: _this.getChildRef,
                    originalRef: ch.ref
                }));
            }
        });
        this._contentChildren = children;
        var prevActual = this._contentChildrenActual;
        this._contentChildrenActual = [];
        var prevMap = this._contentChildrenMap;
        var prevUnresolved = this._contentChildrenUnresolvedSet;
        this._contentChildrenUnresolvedSet = new Set();
        this._contentChildrenMap = new Map();
        this._contentChildrenUnresolved = 0;
        if (this._contentChildren) {
            this._contentChildren.map(function (ch, i) {
                var key = _this._getPropsKey(ch);
                var unresolved = prevUnresolved.has(key);
                if (prevMap && prevMap.has(key) && !unresolved) {
                    _this._contentChildrenActual[i] = prevActual[prevMap.get(key)];
                }
                else {
                    _this._contentChildrenActual[i] = null;
                    _this._contentChildrenUnresolvedSet.add(key);
                    _this._contentChildrenUnresolved++;
                }
                _this._contentChildrenMap.set(key, i);
            });
        }
        return children;
    };
    ContentChildrenManager.prototype.getChildRef = function (child) {
        //console.log(child);
        this.trackChild(child);
    };
    Object.defineProperty(ContentChildrenManager.prototype, "contentChildrenActual", {
        get: function () {
            return this._contentChildrenActual;
        },
        enumerable: false,
        configurable: true
    });
    ContentChildrenManager.prototype.trackChild = function (child) {
        var _a;
        if (child === null) {
            return;
        }
        var name = this._getKey(child);
        var index = this._contentChildrenMap.get(name);
        // resolve any refs from content child.
        var contentChild = this._contentChildren[index];
        var ref = (_a = contentChild === null || contentChild === void 0 ? void 0 : contentChild.props) === null || _a === void 0 ? void 0 : _a.originalRef;
        if (ref && typeof ref === 'function') {
            // user has set a callback function.
            ref(child);
        }
        else if (ref && ref.hasOwnProperty('current')) {
            // user has set a useRef object.
            ref.current = child;
        }
        if (this._contentChildrenActual[index] === null) {
            this._contentChildrenActual[index] = child;
            this._contentChildrenUnresolvedSet.delete(name);
            this._contentChildrenUnresolved--;
            if (this._contentChildrenUnresolved <= 0) {
                this._updateContentChildren();
            }
        }
    };
    return ContentChildrenManager;
}());
export { ContentChildrenManager };
