/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { Base, Point_$type, typeCast, markType } from "./type";
import { Brush } from "./Brush";
import { MathUtil } from "./MathUtil";
import { LinearGradientBrush } from "./LinearGradientBrush";
import { StringBuilder } from "./StringBuilder";
import { CultureInfo } from "./culture";
import { isNaN_, isInfinity } from "./number";
import { numberToString } from "./numberExtended";
/**
 * @hidden
 */
export let CSSColorUtil = /*@__PURE__*/ (() => {
    class CSSColorUtil extends Base {
        static g(a) {
            return Brush.create(a);
        }
        static a(a) {
            let b = a[0];
            let c = a[1];
            if (isNaN_(b.x) || isNaN_(b.y)) {
                b = { $type: Point_$type, x: 0.5, y: 1 };
            }
            if (isNaN_(c.x) || isNaN_(c.y)) {
                c = { $type: Point_$type, x: 0.5, y: 0 };
            }
            let d = Math.atan2(c.y - b.y, c.x - b.x);
            d -= Math.PI;
            d = MathUtil.f(d);
            d = CSSColorUtil.b(d);
            return d;
        }
        static c(a) {
            if (a == null) {
                return null;
            }
            if (typeCast(LinearGradientBrush.$, a) !== null) {
                return CSSColorUtil.e(a);
            }
            else {
                return CSSColorUtil.f(a);
            }
        }
        static b(a) {
            if (isNaN_(a) || isInfinity(a)) {
                return a;
            }
            while (a > 360) {
                a -= 360;
            }
            while (a < 0) {
                a += 360;
            }
            return a;
        }
        static e(a) {
            let b = CSSColorUtil.a([{ $type: Point_$type, x: a.startX, y: a.startY }, { $type: Point_$type, x: a.endX, y: a.endY }]);
            let c = new StringBuilder(0);
            c.l("linear-gradient(");
            c.l(numberToString(b, CultureInfo.invariantCulture));
            c.l("deg");
            if (a.gradientStops != null && a.gradientStops.length > 0) {
                let f = a.gradientStops;
                for (let e = 0; e < f.length; e++) {
                    let d = f[e];
                    c.l(", ");
                    c.l(CSSColorUtil.d(d.color));
                    if (!isNaN_(d.offset)) {
                        c.l(" ");
                        c.l(numberToString((d.offset * 100), CultureInfo.invariantCulture) + "%");
                    }
                }
            }
            c.l(")");
            return c.toString();
        }
        static f(a) {
            return CSSColorUtil.d(a.color);
        }
        static d(a) {
            return "rgba(" + a.o.toString() + ", " + a.n.toString() + ", " + a.m.toString() + ", " + (a.l / 255).toString() + ")";
        }
    }
    CSSColorUtil.$t = /*@__PURE__*/ markType(CSSColorUtil, 'CSSColorUtil');
    return CSSColorUtil;
})();
