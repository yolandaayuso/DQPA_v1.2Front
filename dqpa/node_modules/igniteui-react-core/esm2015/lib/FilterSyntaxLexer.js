/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { Base, markType } from "./type";
import { List$1 } from "./List$1";
import { FilterSyntaxToken } from "./FilterSyntaxToken";
import { InvalidOperationException } from "./InvalidOperationException";
import { CultureInfo } from "./culture";
import { truncate } from "./number";
import { dateParse, dateParseExact } from "./dateExtended";
import { stringContains } from "./string";
import { parseNumber1 } from "./numberExtended";
import { isLetterOrDigit, isLetter } from "./stringExtended";
/**
 * @hidden
 */
export let FilterSyntaxLexer = /*@__PURE__*/ (() => {
    class FilterSyntaxLexer extends Base {
        constructor() {
            super();
        }
        e(a) {
            let b = 0;
            let c = a.length;
            let d = new List$1(FilterSyntaxToken.$, 0);
            while (b < c) {
                b = this.f(d, b, c, a);
            }
            return d;
        }
        f(a, b, c, d) {
            while (b < c && this.d(d.charAt(b))) {
                b++;
            }
            if (b > (c - 1)) {
                return b;
            }
            let e = d.charAt(b);
            if (e == '{') {
                a.add(((() => {
                    let $ret = new FilterSyntaxToken();
                    $ret.a = 14;
                    return $ret;
                })()));
                return b + 1;
            }
            if (e == '}') {
                a.add(((() => {
                    let $ret = new FilterSyntaxToken();
                    $ret.a = 15;
                    return $ret;
                })()));
                return b + 1;
            }
            if (e == '(') {
                a.add(((() => {
                    let $ret = new FilterSyntaxToken();
                    $ret.a = 10;
                    return $ret;
                })()));
                return b + 1;
            }
            if (e == ')') {
                a.add(((() => {
                    let $ret = new FilterSyntaxToken();
                    $ret.a = 11;
                    return $ret;
                })()));
                return b + 1;
            }
            if (e == '[') {
                a.add(((() => {
                    let $ret = new FilterSyntaxToken();
                    $ret.a = 12;
                    return $ret;
                })()));
                return b + 1;
            }
            if (e == ']') {
                a.add(((() => {
                    let $ret = new FilterSyntaxToken();
                    $ret.a = 13;
                    return $ret;
                })()));
                return b + 1;
            }
            if (e == ':') {
                a.add(((() => {
                    let $ret = new FilterSyntaxToken();
                    $ret.a = 18;
                    return $ret;
                })()));
                return b + 1;
            }
            if (e == ',') {
                a.add(((() => {
                    let $ret = new FilterSyntaxToken();
                    $ret.a = 6;
                    return $ret;
                })()));
                return b + 1;
            }
            if (e == '.') {
                a.add(((() => {
                    let $ret = new FilterSyntaxToken();
                    $ret.a = 17;
                    return $ret;
                })()));
                return b + 1;
            }
            if (e == '\'') {
                let f = "";
                let g = b;
                let h = false;
                for (g = b + 1; g < c; g++) {
                    if (d.charAt(g) == '\\') {
                        if (g + 1 < c && d.charAt(g + 1) == '\'') {
                            g++;
                        }
                        else {
                        }
                    }
                    else if (d.charAt(g) == '\'' && g + 1 < c && d.charAt(g + 1) == '\'') {
                        g++;
                    }
                    else if (d.charAt(g) == '\'') {
                        h = true;
                        break;
                    }
                    else {
                    }
                }
                if (!h) {
                    throw new InvalidOperationException(1, "missing end quote for string starting at position: " + b);
                }
                else {
                    f = d.substr(b + 1, (g - 1) - b);
                    b = g + 1;
                    a.add(((() => {
                        let $ret = new FilterSyntaxToken();
                        $ret.a = 2;
                        $ret.b = f;
                        return $ret;
                    })()));
                }
                return b;
            }
            if ((e == 't' || e == 'T') && (b + ("true").length) < c && d.substr(b, ("true").length).toLowerCase() == "true") {
                b += ("true").length;
                a.add(((() => {
                    let $ret = new FilterSyntaxToken();
                    $ret.a = 72;
                    $ret.b = true;
                    return $ret;
                })()));
                return b;
            }
            if ((e == 'f' || e == 'F') && (b + ("false").length) < c && d.substr(b, ("false").length).toLowerCase() == "false") {
                b += ("false").length;
                a.add(((() => {
                    let $ret = new FilterSyntaxToken();
                    $ret.a = 73;
                    $ret.b = false;
                    return $ret;
                })()));
                return b;
            }
            if ((e == 'n' || e == 'N') && (b + ("null").length) < c && d.substr(b, ("null").length).toLowerCase() == "null") {
                b += ("null").length;
                a.add(((() => {
                    let $ret = new FilterSyntaxToken();
                    $ret.a = 71;
                    return $ret;
                })()));
                return b;
            }
            if ((e == '-' && (b + 1 < c) && this.c(d.charAt(b + 1))) || this.c(e)) {
                let i = this.h(e, b, c, d);
                let j = this.g(e, b, c, d);
                let k = this.i(e, b, c, d);
                if (i >= 0) {
                    let l = d.substr(b, (i - b) + 1);
                    let m = dateParse(l, CultureInfo.invariantCulture);
                    a.add(((() => {
                        let $ret = new FilterSyntaxToken();
                        $ret.a = 3;
                        $ret.b = m;
                        return $ret;
                    })()));
                    return i + 1;
                }
                else if (j >= 0) {
                    let n = d.substr(b, (j - b) + 1);
                    let o = dateParse(n);
                    a.add(((() => {
                        let $ret = new FilterSyntaxToken();
                        $ret.a = 3;
                        $ret.b = o;
                        return $ret;
                    })()));
                    return j + 1;
                }
                else if (k >= 0) {
                    let p = d.substr(b, (j - b) + 1);
                    let q = dateParseExact(p, "hh:mm:ss.FFFFFFFFFFFF", CultureInfo.invariantCulture);
                    a.add(((() => {
                        let $ret = new FilterSyntaxToken();
                        $ret.a = 5;
                        $ret.b = q;
                        return $ret;
                    })()));
                    return k + 1;
                }
                else {
                    let r = b;
                    let s = true;
                    let t = false;
                    let u = false;
                    let v = "";
                    let w = false;
                    if (e == '-') {
                        v += e;
                        r++;
                    }
                    while (r < c) {
                        let x = d.charAt(r);
                        if (u) {
                            if (x == '-') {
                                v += x;
                                r++;
                            }
                            if (x == '+') {
                                v += x;
                                r++;
                            }
                            if (r < c) {
                                x = d.charAt(r);
                            }
                            if (!this.c(x)) {
                                w = true;
                                break;
                            }
                            else {
                                v += x;
                                r++;
                            }
                        }
                        else if (t) {
                            if (x == 'e' || x == 'E') {
                                v += x;
                                r++;
                                u = true;
                                continue;
                            }
                            if (!this.c(x)) {
                                w = true;
                                break;
                            }
                            else {
                                v += x;
                                r++;
                            }
                        }
                        else if (s) {
                            if (x == '.') {
                                v += x;
                                r++;
                                t = true;
                                continue;
                            }
                            if (x == 'e' || x == 'E') {
                                v += x;
                                r++;
                                u = true;
                                continue;
                            }
                            if (!this.c(x)) {
                                w = true;
                                break;
                            }
                            else {
                                v += x;
                                r++;
                            }
                        }
                    }
                    if (r >= c - 1) {
                        w = true;
                    }
                    if (!w) {
                        if (v.charAt(v.length - 1) == 'E' || v.charAt(v.length - 1) == 'e' || v.charAt(v.length - 1) == '.') {
                            throw new InvalidOperationException(1, "expected end of number starting at: " + b);
                        }
                    }
                    else {
                        b = r;
                        if (stringContains(v, ".") || stringContains(v, "E") || stringContains(v, "e")) {
                            a.add(((() => {
                                let $ret = new FilterSyntaxToken();
                                $ret.a = 1;
                                $ret.b = parseNumber1(v, 167);
                                return $ret;
                            })()));
                        }
                        else {
                            a.add(((() => {
                                let $ret = new FilterSyntaxToken();
                                $ret.a = 0;
                                $ret.b = truncate(parseNumber1(v, 7));
                                return $ret;
                            })()));
                        }
                    }
                    return b;
                }
            }
            if (this.a(e)) {
                let y = "";
                let z = b;
                let aa = false;
                for (z = b; z < c; z++) {
                    if (d.charAt(z) == '\r' || d.charAt(z) == '\n') {
                        aa = true;
                        break;
                    }
                    if (this.d(d.charAt(z))) {
                        aa = true;
                        break;
                    }
                    if (d.charAt(z) == ':') {
                        aa = true;
                        break;
                    }
                    if (!this.b(d.charAt(z))) {
                        aa = true;
                        break;
                    }
                    else {
                        y += d.charAt(z);
                    }
                }
                if (z >= c - 1) {
                    aa = true;
                }
                if (!aa) {
                    throw new InvalidOperationException(1, "invalidly formed identifier starting at position: " + b);
                }
                else {
                    b = z;
                    this.k(a, y);
                }
                return b;
            }
            throw new InvalidOperationException(1, "unexpected character: " + e + " at position: " + b);
        }
        i(a, b, c, d) {
            if (this.c(a) && (b + 1) < c && this.c(d.charAt(b + 1)) && (b + 2) < c && (d.charAt(b + 2) == ':') && (b + 3) < c && this.c(d.charAt(b + 3)) && (b + 4) < c && this.c(d.charAt(b + 4))) {
                if ((b + 5) < c && (d.charAt(b + 5) == ':')) {
                    if ((b + 6) < c && this.c(d.charAt(b + 6)) && (b + 7) < c && this.c(d.charAt(b + 7))) {
                        if ((b + 8) < c && (d.charAt(b + 8) == '.')) {
                            if ((b + 9) < c && this.c(d.charAt(b + 9))) {
                                let e = 0;
                                while (e < 12) {
                                    let f = b + 9 + e;
                                    if (f >= c) {
                                        break;
                                    }
                                    if (!this.c(d.charAt(f))) {
                                        break;
                                    }
                                    e++;
                                }
                                if (e > 12) {
                                    return -1;
                                }
                                return b + 9 + (e - 1);
                            }
                        }
                        else {
                            return b + 7;
                        }
                    }
                }
                else {
                    return b + 4;
                }
            }
            return -1;
        }
        h(a, b, c, d) {
            if (this.g(a, b, c, d) >= 0) {
                if ((b + 10) < c && (d.charAt(b + 10) == 'T')) {
                    if (b + 11 < c) {
                        let e = this.i(d.charAt(b + 11), b + 11, c, d);
                        if (e >= 0) {
                            if (e + 1 < c && (d.charAt(e + 1) == 'Z' || d.charAt(e + 1) == '+' || d.charAt(e + 1) == '-')) {
                                e = this.j(d.charAt(e + 1), e + 1, c, d);
                            }
                        }
                        return e;
                    }
                }
            }
            return -1;
        }
        j(a, b, c, d) {
            if (a == 'Z') {
                return b;
            }
            else if (a == '+' || a == '-') {
                return ((b + 1) < c && this.c(d.charAt(b + 1)) && (b + 2) < c && this.c(d.charAt(b + 2)) && (b + 3) < c && (d.charAt(b + 3) == ':') && (b + 5) < c && this.c(d.charAt(b + 5)) && (b + 6) < c && this.c(d.charAt(b + 6))) ? b + 6 : -1;
            }
            return -1;
        }
        g(a, b, c, d) {
            return (this.c(a) && (b + 1) < c && this.c(d.charAt(b + 1)) && (b + 2) < c && this.c(d.charAt(b + 2)) && (b + 3) < c && this.c(d.charAt(b + 3)) && (b + 4) < c && (d.charAt(b + 4) == '-') && (b + 5) < c && this.c(d.charAt(b + 5)) && (b + 6) < c && this.c(d.charAt(b + 6)) && (b + 7) < c && (d.charAt(b + 7) == '-') && (b + 8) < c && this.c(d.charAt(b + 8)) && (b + 9) < c && this.c(d.charAt(b + 9))) ? b + 9 : -1;
        }
        k(a, b) {
            switch (b) {
                case "substringof":
                    a.add(((() => {
                        let $ret = new FilterSyntaxToken();
                        $ret.a = 20;
                        $ret.b = b;
                        return $ret;
                    })()));
                    return;
                case "startswith":
                    a.add(((() => {
                        let $ret = new FilterSyntaxToken();
                        $ret.a = 21;
                        $ret.b = b;
                        return $ret;
                    })()));
                    return;
                case "endswith":
                    a.add(((() => {
                        let $ret = new FilterSyntaxToken();
                        $ret.a = 22;
                        $ret.b = b;
                        return $ret;
                    })()));
                    return;
                case "length":
                    a.add(((() => {
                        let $ret = new FilterSyntaxToken();
                        $ret.a = 24;
                        $ret.b = b;
                        return $ret;
                    })()));
                    return;
                case "replace":
                    a.add(((() => {
                        let $ret = new FilterSyntaxToken();
                        $ret.a = 23;
                        $ret.b = b;
                        return $ret;
                    })()));
                    return;
                case "indexof":
                    a.add(((() => {
                        let $ret = new FilterSyntaxToken();
                        $ret.a = 25;
                        $ret.b = b;
                        return $ret;
                    })()));
                    return;
                case "substring":
                    a.add(((() => {
                        let $ret = new FilterSyntaxToken();
                        $ret.a = 26;
                        $ret.b = b;
                        return $ret;
                    })()));
                    return;
                case "contains":
                    a.add(((() => {
                        let $ret = new FilterSyntaxToken();
                        $ret.a = 27;
                        $ret.b = b;
                        return $ret;
                    })()));
                    return;
                case "tolower":
                    a.add(((() => {
                        let $ret = new FilterSyntaxToken();
                        $ret.a = 28;
                        $ret.b = b;
                        return $ret;
                    })()));
                    return;
                case "toupper":
                    a.add(((() => {
                        let $ret = new FilterSyntaxToken();
                        $ret.a = 29;
                        $ret.b = b;
                        return $ret;
                    })()));
                    return;
                case "trim":
                    a.add(((() => {
                        let $ret = new FilterSyntaxToken();
                        $ret.a = 30;
                        $ret.b = b;
                        return $ret;
                    })()));
                    return;
                case "concat":
                    a.add(((() => {
                        let $ret = new FilterSyntaxToken();
                        $ret.a = 31;
                        $ret.b = b;
                        return $ret;
                    })()));
                    return;
                case "year":
                    a.add(((() => {
                        let $ret = new FilterSyntaxToken();
                        $ret.a = 32;
                        $ret.b = b;
                        return $ret;
                    })()));
                    return;
                case "month":
                    a.add(((() => {
                        let $ret = new FilterSyntaxToken();
                        $ret.a = 33;
                        $ret.b = b;
                        return $ret;
                    })()));
                    return;
                case "day":
                    a.add(((() => {
                        let $ret = new FilterSyntaxToken();
                        $ret.a = 34;
                        $ret.b = b;
                        return $ret;
                    })()));
                    return;
                case "days":
                    a.add(((() => {
                        let $ret = new FilterSyntaxToken();
                        $ret.a = 35;
                        $ret.b = b;
                        return $ret;
                    })()));
                    return;
                case "hour":
                    a.add(((() => {
                        let $ret = new FilterSyntaxToken();
                        $ret.a = 36;
                        $ret.b = b;
                        return $ret;
                    })()));
                    return;
                case "hours":
                    a.add(((() => {
                        let $ret = new FilterSyntaxToken();
                        $ret.a = 37;
                        $ret.b = b;
                        return $ret;
                    })()));
                    return;
                case "minute":
                    a.add(((() => {
                        let $ret = new FilterSyntaxToken();
                        $ret.a = 38;
                        $ret.b = b;
                        return $ret;
                    })()));
                    return;
                case "minutes":
                    a.add(((() => {
                        let $ret = new FilterSyntaxToken();
                        $ret.a = 39;
                        $ret.b = b;
                        return $ret;
                    })()));
                    return;
                case "second":
                    a.add(((() => {
                        let $ret = new FilterSyntaxToken();
                        $ret.a = 40;
                        $ret.b = b;
                        return $ret;
                    })()));
                    return;
                case "seconds":
                    a.add(((() => {
                        let $ret = new FilterSyntaxToken();
                        $ret.a = 41;
                        $ret.b = b;
                        return $ret;
                    })()));
                    return;
                case "date":
                    a.add(((() => {
                        let $ret = new FilterSyntaxToken();
                        $ret.a = 42;
                        $ret.b = b;
                        return $ret;
                    })()));
                    return;
                case "time":
                    a.add(((() => {
                        let $ret = new FilterSyntaxToken();
                        $ret.a = 43;
                        $ret.b = b;
                        return $ret;
                    })()));
                    return;
                case "round":
                    a.add(((() => {
                        let $ret = new FilterSyntaxToken();
                        $ret.a = 44;
                        $ret.b = b;
                        return $ret;
                    })()));
                    return;
                case "floor":
                    a.add(((() => {
                        let $ret = new FilterSyntaxToken();
                        $ret.a = 45;
                        $ret.b = b;
                        return $ret;
                    })()));
                    return;
                case "ceiling":
                    a.add(((() => {
                        let $ret = new FilterSyntaxToken();
                        $ret.a = 46;
                        $ret.b = b;
                        return $ret;
                    })()));
                    return;
                case "fractionalseconds":
                    a.add(((() => {
                        let $ret = new FilterSyntaxToken();
                        $ret.a = 47;
                        $ret.b = b;
                        return $ret;
                    })()));
                    return;
                case "totaloffsetminutes":
                    a.add(((() => {
                        let $ret = new FilterSyntaxToken();
                        $ret.a = 48;
                        $ret.b = b;
                        return $ret;
                    })()));
                    return;
                case "mindatetime":
                    a.add(((() => {
                        let $ret = new FilterSyntaxToken();
                        $ret.a = 49;
                        $ret.b = b;
                        return $ret;
                    })()));
                    return;
                case "maxdatetime":
                    a.add(((() => {
                        let $ret = new FilterSyntaxToken();
                        $ret.a = 50;
                        $ret.b = b;
                        return $ret;
                    })()));
                    return;
                case "now":
                    a.add(((() => {
                        let $ret = new FilterSyntaxToken();
                        $ret.a = 51;
                        $ret.b = b;
                        return $ret;
                    })()));
                    return;
                case "and":
                    a.add(((() => {
                        let $ret = new FilterSyntaxToken();
                        $ret.a = 52;
                        $ret.b = b;
                        return $ret;
                    })()));
                    return;
                case "or":
                    a.add(((() => {
                        let $ret = new FilterSyntaxToken();
                        $ret.a = 53;
                        $ret.b = b;
                        return $ret;
                    })()));
                    return;
                case "eq":
                    a.add(((() => {
                        let $ret = new FilterSyntaxToken();
                        $ret.a = 54;
                        $ret.b = b;
                        return $ret;
                    })()));
                    return;
                case "ne":
                    a.add(((() => {
                        let $ret = new FilterSyntaxToken();
                        $ret.a = 55;
                        $ret.b = b;
                        return $ret;
                    })()));
                    return;
                case "lt":
                    a.add(((() => {
                        let $ret = new FilterSyntaxToken();
                        $ret.a = 56;
                        $ret.b = b;
                        return $ret;
                    })()));
                    return;
                case "le":
                    a.add(((() => {
                        let $ret = new FilterSyntaxToken();
                        $ret.a = 57;
                        $ret.b = b;
                        return $ret;
                    })()));
                    return;
                case "gt":
                    a.add(((() => {
                        let $ret = new FilterSyntaxToken();
                        $ret.a = 58;
                        $ret.b = b;
                        return $ret;
                    })()));
                    return;
                case "ge":
                    a.add(((() => {
                        let $ret = new FilterSyntaxToken();
                        $ret.a = 59;
                        $ret.b = b;
                        return $ret;
                    })()));
                    return;
                case "has":
                    a.add(((() => {
                        let $ret = new FilterSyntaxToken();
                        $ret.a = 60;
                        $ret.b = b;
                        return $ret;
                    })()));
                    return;
                case "add":
                    a.add(((() => {
                        let $ret = new FilterSyntaxToken();
                        $ret.a = 61;
                        $ret.b = b;
                        return $ret;
                    })()));
                    return;
                case "sub":
                    a.add(((() => {
                        let $ret = new FilterSyntaxToken();
                        $ret.a = 62;
                        $ret.b = b;
                        return $ret;
                    })()));
                    return;
                case "mul":
                    a.add(((() => {
                        let $ret = new FilterSyntaxToken();
                        $ret.a = 63;
                        $ret.b = b;
                        return $ret;
                    })()));
                    return;
                case "div":
                    a.add(((() => {
                        let $ret = new FilterSyntaxToken();
                        $ret.a = 64;
                        $ret.b = b;
                        return $ret;
                    })()));
                    return;
                case "mod":
                    a.add(((() => {
                        let $ret = new FilterSyntaxToken();
                        $ret.a = 65;
                        $ret.b = b;
                        return $ret;
                    })()));
                    return;
                case "not":
                    a.add(((() => {
                        let $ret = new FilterSyntaxToken();
                        $ret.a = 66;
                        $ret.b = b;
                        return $ret;
                    })()));
                    return;
                case "isof":
                    a.add(((() => {
                        let $ret = new FilterSyntaxToken();
                        $ret.a = 67;
                        $ret.b = b;
                        return $ret;
                    })()));
                    return;
                case "cast":
                    a.add(((() => {
                        let $ret = new FilterSyntaxToken();
                        $ret.a = 68;
                        $ret.b = b;
                        return $ret;
                    })()));
                    return;
                case "NaN":
                    a.add(((() => {
                        let $ret = new FilterSyntaxToken();
                        $ret.a = 69;
                        $ret.b = b;
                        return $ret;
                    })()));
                    return;
                case "infinity":
                    a.add(((() => {
                        let $ret = new FilterSyntaxToken();
                        $ret.a = 70;
                        $ret.b = b;
                        return $ret;
                    })()));
                    return;
                case "env":
                    a.add(((() => {
                        let $ret = new FilterSyntaxToken();
                        $ret.a = 75;
                        $ret.b = b;
                        return $ret;
                    })()));
                    return;
            }
            a.add(((() => {
                let $ret = new FilterSyntaxToken();
                $ret.a = 74;
                $ret.b = b;
                return $ret;
            })()));
        }
        b(a) {
            return isLetterOrDigit(a);
        }
        a(a) {
            return isLetter(a);
        }
        c(a) {
            return a == '0' || a == '1' || a == '2' || a == '3' || a == '4' || a == '5' || a == '6' || a == '7' || a == '8' || a == '9';
        }
        d(a) {
            return a == '\r' || a == '\n' || a == ' ' || a == '\t';
        }
    }
    FilterSyntaxLexer.$t = /*@__PURE__*/ markType(FilterSyntaxLexer, 'FilterSyntaxLexer');
    return FilterSyntaxLexer;
})();
