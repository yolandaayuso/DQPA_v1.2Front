/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { Base, String_$type, Number_$type, typeCast, fromEnum, markType } from "./type";
import { List$1 } from "./List$1";
import { Dictionary$2 } from "./Dictionary$2";
import { JsonDictionaryObject } from "./JsonDictionaryObject";
import { JsonDictionaryParser } from "./JsonDictionaryParser";
import { HashSet$1 } from "./HashSet$1";
import { Tuple$2 } from "./Tuple$2";
import { JsonDictionaryItem } from "./JsonDictionaryItem";
import { JsonDictionaryArray } from "./JsonDictionaryArray";
import { JsonDictionaryValue } from "./JsonDictionaryValue";
import { stringJoin, stringContains } from "./string";
/**
 * @hidden
 */
export let DescriptionJsonValidator = /*@__PURE__*/ (() => {
    class DescriptionJsonValidator extends Base {
        constructor() {
            super();
            this.i = new List$1(String_$type, 0);
            this.h = new Dictionary$2(String_$type, List$1.$.specialize(String_$type), 0);
            this.e = null;
            this.g = null;
        }
        getContainingModules(a) {
            if (this.h.containsKey(a)) {
                return this.h.item(a).toArray();
            }
            return null;
        }
        validate(a) {
            let b = new JsonDictionaryParser();
            let c = b.parse(a);
            let d = this.b(c);
            let e = this.a(c);
            let f = new HashSet$1(String_$type, 0);
            for (let h = 0; h < e.length; h++) {
                let g = e[h];
                f.add_1(g);
            }
            let i = null;
            for (let k = 0; k < d.length; k++) {
                let j = d[k];
                let l = this.getContainingModules(j);
                let m = false;
                if (l != null) {
                    for (let o = 0; o < l.length; o++) {
                        let n = l[o];
                        if (f.contains(n)) {
                            m = true;
                        }
                    }
                }
                if (!m) {
                    let p = a.indexOf("\"" + j + "\"");
                    let q = this.l(a, p);
                    let r = q.c;
                    let s = q.d;
                    let t = s + ("\"" + j + "\"").length;
                    i = this.f(i, r, s, r, t, "Type " + j + " appears not to have a containing module, consider adding one of: " + stringJoin(", ", ...l));
                }
            }
            for (let v = 0; v < d.length; v++) {
                let u = d[v];
                if (u == "PropertyEditor") {
                    let w = a.indexOf("\"" + u + "\"");
                    let x = this.l(a, w);
                    let y = x.c;
                    let z = x.d;
                    let aa = z + ("\"" + u + "\"").length;
                    if (!f.contains("withDescriptions")) {
                        i = this.f(i, y, z, y, aa, "Property editor is included, but withDescriptions is not in modules, did you forget it?");
                    }
                }
            }
            return i == null ? null : i.b();
        }
        l(a, b) {
            let c = a.split('\n');
            let d = 0;
            let e = 0;
            while (e <= b && d < c.length) {
                let f = c[d];
                if ((f.length + 1) >= (b - e)) {
                    return new Tuple$2(Number_$type, Number_$type, d + 1, (b - e) + 1);
                }
                e += (f.length + 1);
                d++;
            }
            return new Tuple$2(Number_$type, Number_$type, d + 1, (b - e) + 1);
        }
        f(a, b, c, d, e, f) {
            if (a == null) {
                a = new JsonDictionaryObject();
                a.item("warnings", new JsonDictionaryArray());
            }
            let g = a.item("warnings");
            let h = g.items;
            let i = new List$1(JsonDictionaryItem.$, 0);
            if (h != null) {
                for (let j = 0; j < h.length; j++) {
                    i.add(h[j]);
                }
            }
            let k = new JsonDictionaryObject();
            k.item("line", ((() => {
                let $ret = new JsonDictionaryValue();
                $ret.e = 0;
                $ret.value = b;
                return $ret;
            })()));
            k.item("column", ((() => {
                let $ret = new JsonDictionaryValue();
                $ret.e = 0;
                $ret.value = c;
                return $ret;
            })()));
            k.item("endLine", ((() => {
                let $ret = new JsonDictionaryValue();
                $ret.e = 0;
                $ret.value = d;
                return $ret;
            })()));
            k.item("endColumn", ((() => {
                let $ret = new JsonDictionaryValue();
                $ret.e = 0;
                $ret.value = e;
                return $ret;
            })()));
            k.item("message", ((() => {
                let $ret = new JsonDictionaryValue();
                $ret.e = 2;
                $ret.value = f;
                return $ret;
            })()));
            i.add(k);
            g.items = i.toArray();
            return a;
        }
        a(a) {
            let b = new List$1(String_$type, 0);
            if (a != null && a.g("modules")) {
                if (typeCast(JsonDictionaryArray.$, a.item("modules")) !== null) {
                    let c = a.item("modules");
                    if (c.items != null) {
                        for (let d = 0; d < c.items.length; d++) {
                            let e = c.items[d];
                            let f = e.value.toString();
                            if (stringContains(f, "/")) {
                                let g = f.split('/');
                                b.add(g[1]);
                            }
                            else {
                                b.add(f);
                            }
                        }
                    }
                }
            }
            return b.toArray();
        }
        b(a) {
            let b = new HashSet$1(String_$type, 0);
            this.m(b, null, a);
            let c = new List$1(String_$type, 0);
            for (let d of fromEnum(b)) {
                c.add(d);
            }
            return c.toArray();
        }
        m(a, b, c) {
            if (typeCast(JsonDictionaryObject.$, c) !== null) {
                let d = c;
                let e = d.e();
                for (let g = 0; g < e.length; g++) {
                    let f = e[g];
                    this.m(a, f, d.item(f));
                }
            }
            if (typeCast(JsonDictionaryArray.$, c) !== null) {
                let h = c;
                if (h.items != null) {
                    for (let i = 0; i < h.items.length; i++) {
                        this.m(a, b + "[" + i + "]", h.items[i]);
                    }
                }
            }
            if (typeCast(JsonDictionaryValue.$, c) !== null) {
                if (b != null && b == "type") {
                    a.add_1(c.value.toString());
                }
            }
        }
        static fromJson(a) {
            let b = new DescriptionJsonValidator();
            let c = new JsonDictionaryParser();
            let d = c.parse(a);
            let e = typeCast(JsonDictionaryObject.$, d);
            if (e != null) {
                if (e.g("types")) {
                    let f = e.item("types");
                    if (f.items != null) {
                        for (let g = 0; g < f.items.length; g++) {
                            b.i.add(f.items[g].value.toString());
                        }
                    }
                }
                if (e.g("containingModules")) {
                    let h = e.item("containingModules");
                    let i = h.e();
                    for (let j = 0; j < i.length; j++) {
                        let k = i[j];
                        let l = h.item(k);
                        b.h.item(k, new List$1(String_$type, 0));
                        for (let m = 0; m < l.items.length; m++) {
                            let n = l.items[m];
                            b.h.item(k).add(n.value.toString());
                        }
                    }
                }
            }
            return b;
        }
        toJson() {
            let a = new JsonDictionaryObject();
            let b = new JsonDictionaryArray();
            let c = new List$1(JsonDictionaryItem.$, 0);
            for (let d of fromEnum(this.i)) {
                c.add(((() => {
                    let $ret = new JsonDictionaryValue();
                    $ret.value = d;
                    $ret.e = 2;
                    return $ret;
                })()));
            }
            b.items = c.toArray();
            a.item("types", b);
            let e = new JsonDictionaryObject();
            for (let f of fromEnum(this.h.keys)) {
                let g = new List$1(JsonDictionaryItem.$, 0);
                for (let h of fromEnum(this.h.item(f))) {
                    g.add(((() => {
                        let $ret = new JsonDictionaryValue();
                        $ret.value = h;
                        $ret.e = 2;
                        return $ret;
                    })()));
                }
                e.item(f, ((() => {
                    let $ret = new JsonDictionaryArray();
                    $ret.items = g.toArray();
                    return $ret;
                })()));
            }
            a.item("containingModules", e);
            return a.b();
        }
    }
    DescriptionJsonValidator.$t = /*@__PURE__*/ markType(DescriptionJsonValidator, 'DescriptionJsonValidator');
    return DescriptionJsonValidator;
})();
