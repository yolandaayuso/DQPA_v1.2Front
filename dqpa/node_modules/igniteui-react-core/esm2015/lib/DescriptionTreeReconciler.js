/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { Base, typeCast, String_$type, markType } from "./type";
import { DiffApplyInfo } from "./DiffApplyInfo";
import { DescriptionTreeNode } from "./DescriptionTreeNode";
import { List$1 } from "./List$1";
import { DescriptionTreeAction } from "./DescriptionTreeAction";
import { DescriptionPropertyValue } from "./DescriptionPropertyValue";
import { Dictionary$2 } from "./Dictionary$2";
import { DescriptionTreeReconciler_TreeModeData } from "./DescriptionTreeReconciler_TreeModeData";
/**
 * @hidden
 */
export let DescriptionTreeReconciler = /*@__PURE__*/ (() => {
    class DescriptionTreeReconciler extends Base {
        static a(a, b) {
            let c = new DiffApplyInfo();
            for (let d = 0; d < b.count; d++) {
                let e = b._inner[d];
                switch (e.a) {
                    case 0:
                        if (typeCast(DescriptionTreeNode.$, e.h) !== null) {
                            let f = e.h.g;
                            c.a.add_1(f);
                        }
                        e.c.o(e.j, e.g, e.d);
                        if (typeCast(DescriptionTreeNode.$, e.g) !== null) {
                            let g = e.g.g;
                            if (c.a.contains(g)) {
                                c.a.remove(g);
                            }
                            c.c.add(e);
                        }
                        break;
                    case 1:
                        if (typeCast(DescriptionTreeNode.$, e.h) !== null) {
                            let h = e.h.g;
                            c.a.add_1(h);
                        }
                        e.c.m(e.j);
                        break;
                    case 3:
                        {
                            let i = e.c.a(e.j).b;
                            let j = i[e.f];
                            if (typeCast(DescriptionTreeNode.$, j) !== null) {
                                let k = j.g;
                                c.a.add_1(k);
                            }
                            i[e.f] = e.g;
                            if (typeCast(DescriptionTreeNode.$, e.g) !== null) {
                                let l = e.g.g;
                                if (c.a.contains(l)) {
                                    c.a.remove(l);
                                }
                                c.b.add(e);
                            }
                        }
                        break;
                    case 4:
                        {
                            let m = e.c.a(e.j).b;
                            let n = m[e.f];
                            if (typeCast(DescriptionTreeNode.$, n) !== null) {
                                let o = n.g;
                                c.a.add_1(o);
                            }
                            let p = new Array(m.length - 1);
                            let q = 0;
                            for (let r = 0; r < m.length; r++) {
                                if (r != e.f) {
                                    p[q] = m[r];
                                    q++;
                                }
                            }
                            e.c.n(e.j, p);
                        }
                        break;
                    case 2:
                        {
                            if (e.c == null && a == null) {
                                c.d.add(e);
                            }
                            else {
                                let s = e.c.a(e.j).b;
                                let t = new Array(s.length + 1);
                                let u = 0;
                                for (let v = 0; v < t.length; v++) {
                                    if (v == e.e) {
                                        t[v] = e.g;
                                    }
                                    else {
                                        t[v] = s[u];
                                        u++;
                                    }
                                }
                                e.c.n(e.j, t);
                                if (typeCast(DescriptionTreeNode.$, e.g) !== null) {
                                    let w = e.g.g;
                                    if (c.a.contains(w)) {
                                        c.a.remove(w);
                                    }
                                    c.b.add(e);
                                }
                            }
                        }
                        break;
                    case 5:
                        {
                            let x = e.c.a(e.j).b;
                            for (let y = 0; y < x.length; y++) {
                                let z = x[y];
                                if (typeCast(DescriptionTreeNode.$, z) !== null) {
                                    let aa = z.g;
                                    c.a.add_1(aa);
                                }
                            }
                            e.c.n(e.j, []);
                        }
                        break;
                }
            }
            return c;
        }
        static c(a, b, c) {
            let d = new List$1(DescriptionTreeAction.$, 0);
            if (a == null && b == null) {
                return d;
            }
            if (a != null && b == null) {
                let e = new DescriptionTreeAction();
                e.a = 4;
                e.f = 0;
                e.h = a;
                e.d = null;
                e.j = null;
                d.add(e);
                return d;
            }
            if (a == null && b != null) {
                let f = new DescriptionTreeAction();
                f.a = 2;
                f.f = 0;
                f.g = b;
                f.d = null;
                f.j = null;
                d.add(f);
                return d;
            }
            if (b.i != a.i) {
                let g = new DescriptionTreeAction();
                g.a = 3;
                g.f = 0;
                g.h = a;
                g.g = b;
                g.d = null;
                g.j = null;
                d.add(g);
                return d;
            }
            DescriptionTreeReconciler.g(d, a, b, c);
            return d;
        }
        static g(a, b, c, d) {
            c.g = b.g;
            let e = DescriptionTreeReconciler.e(b);
            let f = DescriptionTreeReconciler.e(c);
            let g = new List$1(DescriptionPropertyValue.$, 0);
            let h = new List$1(DescriptionPropertyValue.$, 0);
            let i = new List$1(DescriptionPropertyValue.$, 0);
            for (let j = 0; j < e.count; j++) {
                let k = e._inner[j];
                if (c.c(k.c)) {
                    if (!Base.equalsStatic(k, c.a(k.c))) {
                        let l = c.a(k.c);
                        if (typeCast(DescriptionTreeNode.$, k.b) !== null && typeCast(DescriptionTreeNode.$, l.b) !== null) {
                            let m = k.b;
                            let n = l.b;
                            if (m.i == n.i) {
                                if ((!m.c("Name") && !n.c("Name")) || (m.c("Name") && n.c("Name") && (m.a("Name").b == n.a("Name").b))) {
                                    DescriptionTreeReconciler.g(a, m, n, d);
                                }
                                else {
                                    i.add(c.a(k.c));
                                }
                            }
                            else {
                                i.add(c.a(k.c));
                            }
                        }
                        else {
                            i.add(c.a(k.c));
                        }
                    }
                }
                else {
                    if (!d) {
                        g.add(k);
                    }
                }
            }
            for (let o = 0; o < f.count; o++) {
                let p = f._inner[o];
                if (!b.c(p.c)) {
                    h.add(p);
                }
            }
            for (let q = 0; q < g.count; q++) {
                let r = g._inner[q];
                let s = new DescriptionTreeAction();
                s.c = b;
                s.b = c;
                s.a = 1;
                s.j = r.c;
                s.d = r.a;
                s.h = r.b;
                a.add(s);
            }
            for (let t = 0; t < h.count; t++) {
                let u = h._inner[t];
                let v = new DescriptionTreeAction();
                v.c = b;
                v.b = c;
                v.a = 0;
                v.j = u.c;
                v.d = u.a;
                v.g = u.b;
                v.h = null;
                a.add(v);
            }
            for (let w = 0; w < i.count; w++) {
                let x = i._inner[w];
                let y = b.a(x.c).b;
                let z = x.b;
                if (!Base.equalsStatic(z, y)) {
                    let aa = new DescriptionTreeAction();
                    aa.c = b;
                    aa.b = c;
                    aa.a = 0;
                    aa.j = x.c;
                    aa.d = x.a;
                    aa.g = x.b;
                    aa.h = b.a(x.c).b;
                    a.add(aa);
                }
            }
            let ab = DescriptionTreeReconciler.d(b);
            let ac = DescriptionTreeReconciler.d(c);
            let ad = new List$1(DescriptionPropertyValue.$, 0);
            let ae = new List$1(DescriptionPropertyValue.$, 0);
            let af = new List$1(DescriptionPropertyValue.$, 0);
            for (let ag = 0; ag < ab.count; ag++) {
                let ah = ab._inner[ag];
                if (c.c(ah.c)) {
                    if (!DescriptionTreeReconciler.b(ah.b, c.a(ah.c).b)) {
                        af.add(c.a(ah.c));
                    }
                    else {
                        let ai = ah.b;
                        let aj = c.a(ah.c).b;
                        if (ai != null) {
                            for (let ak = 0; ak < ai.length; ak++) {
                                let al = ai[ak];
                                let am = aj[ak];
                                if (typeCast(DescriptionTreeNode.$, al) !== null && typeCast(DescriptionTreeNode.$, am) !== null) {
                                    let an = al;
                                    let ao = am;
                                    let ap = false;
                                    let aq = an.i == ao.i && an.i == "EmbeddedRef";
                                    if (aq) {
                                        let ar = an.f().toArray();
                                        let as = ao.f().toArray();
                                        for (let at = 0; at <= ar.length - 1; at++) {
                                            let au = ar[at];
                                            let av = as[at];
                                            if (au.c != av.c || au.b != av.b) {
                                                ap = true;
                                                break;
                                            }
                                        }
                                    }
                                    if (an.i == ao.i && !ap) {
                                        DescriptionTreeReconciler.g(a, an, ao, d);
                                    }
                                    else {
                                        let aw = new DescriptionTreeAction();
                                        aw.j = ah.c;
                                        aw.d = ah.a;
                                        aw.c = b;
                                        aw.b = c;
                                        aw.a = 3;
                                        aw.f = ak;
                                        aw.e = ak;
                                        aw.h = an;
                                        aw.g = ao;
                                        a.add(aw);
                                    }
                                }
                                else {
                                    if (!Base.equalsStatic(al, am)) {
                                        let ax = new DescriptionTreeAction();
                                        ax.j = ah.c;
                                        ax.d = ah.a;
                                        ax.c = b;
                                        ax.b = c;
                                        ax.a = 3;
                                        ax.f = ak;
                                        ax.e = ak;
                                        ax.h = al;
                                        ax.g = am;
                                        a.add(ax);
                                    }
                                }
                            }
                        }
                    }
                }
                else {
                    if (!d) {
                        ad.add(ah);
                    }
                }
            }
            for (let ay = 0; ay < ac.count; ay++) {
                let az = ac._inner[ay];
                if (!b.c(az.c)) {
                    ae.add(az);
                }
            }
            for (let a0 = 0; a0 < ad.count; a0++) {
                let a1 = ad._inner[a0];
                let a2 = new DescriptionTreeAction();
                a2.c = b;
                a2.b = c;
                a2.j = a1.c;
                a2.d = a1.a;
                a2.a = 5;
                a2.h = a1.b;
                a.add(a2);
            }
            for (let a3 = 0; a3 < ae.count; a3++) {
                let a4 = ae._inner[a3];
                let a5 = new DescriptionTreeAction();
                a5.c = b;
                a5.b = c;
                a5.j = a4.c;
                a5.d = a4.a;
                a5.a = 0;
                a5.h = null;
                a5.g = a4.b;
                a.add(a5);
            }
            for (let a6 = 0; a6 < af.count; a6++) {
                DescriptionTreeReconciler.h(a, b, c, b.a(af._inner[a6].c), af._inner[a6], d);
            }
        }
        static f(a) {
            if (a == null) {
                return "UNKOWN";
            }
            if (!a.c("Type")) {
                return "UNKOWN";
            }
            return a.a("Type").b;
        }
        static h(a, b, c, d, e, f) {
            let g = false;
            let h = d.b;
            let i = e.b;
            if (h.length > 0) {
                if (typeCast(DescriptionTreeNode.$, h[0]) !== null) {
                    let j = h[0];
                    if (j.c("Name") && j.a("Name") != null) {
                        g = true;
                    }
                    if (j.c("RefType") && j.a("RefType").b == "uuid") {
                        g = true;
                    }
                }
            }
            if (i.length > 0) {
                if (typeCast(DescriptionTreeNode.$, i[0]) !== null) {
                    let k = i[0];
                    if (k.c("Name") && k.a("Name") != null) {
                        g = true;
                    }
                    if (k.c("RefType") && k.a("RefType").b == "uuid") {
                        g = true;
                    }
                }
            }
            if (g) {
                let l = new Dictionary$2(String_$type, DescriptionTreeReconciler_TreeModeData.$, 0);
                let m = new List$1(DescriptionTreeReconciler_TreeModeData.$, 0);
                let n = new Dictionary$2(String_$type, DescriptionTreeReconciler_TreeModeData.$, 0);
                let o = new List$1(DescriptionTreeReconciler_TreeModeData.$, 0);
                let p = 0;
                for (let q = 0; q < h.length; q++) {
                    let r = new DescriptionTreeReconciler_TreeModeData();
                    r.a = h[q];
                    r.d = q;
                    r.f = r.a.c("Name") ? r.a.a("Name").b : r.a.c("RefType") ? r.a.a("Value").b : null;
                    if (r.f == null) {
                        r.f = "BADKEY_" + p.toString();
                        p++;
                    }
                    m.add(r);
                    l.addItem(r.f, r);
                }
                for (let s = 0; s < i.length; s++) {
                    let t = new DescriptionTreeReconciler_TreeModeData();
                    t.a = i[s];
                    t.d = s;
                    t.f = t.a.c("Name") ? t.a.a("Name").b : t.a.c("RefType") ? t.a.a("Value").b : null;
                    if (t.f == null) {
                        t.f = "BADKEY_" + p.toString();
                        p++;
                    }
                    o.add(t);
                    n.addItem(t.f, t);
                }
                for (let u = 0; u < m.count; u++) {
                    let v = m._inner[u];
                    if (!n.containsKey(v.f) || (n.containsKey(v.f) && DescriptionTreeReconciler.f(v.a) != DescriptionTreeReconciler.f(n.item(v.f).a))) {
                        v.c = true;
                    }
                }
                for (let w = 0; w < o.count; w++) {
                    let x = o._inner[w];
                    if (!l.containsKey(x.f) || (l.containsKey(x.f) && DescriptionTreeReconciler.f(x.a) != DescriptionTreeReconciler.f(l.item(x.f).a))) {
                        x.b = true;
                    }
                    else {
                        l.item(x.f).e = w;
                    }
                }
                for (let y = 0; y < m.count; y++) {
                    let z = m._inner[y];
                    if (z.c) {
                        let aa = new DescriptionTreeAction();
                        aa.j = e.c;
                        aa.c = b;
                        aa.b = c;
                        aa.d = e.a;
                        aa.f = z.d;
                        aa.a = 4;
                        aa.h = z.a;
                        a.add(aa);
                        for (let ab = y + 1; ab < m.count; ab++) {
                            let ac = m._inner[ab];
                            ac.d--;
                        }
                    }
                }
                for (let ad = 0; ad < o.count; ad++) {
                    let ae = o._inner[ad];
                    if (ae.b) {
                        let af = new DescriptionTreeAction();
                        af.j = e.c;
                        af.c = b;
                        af.b = c;
                        af.d = e.a;
                        af.e = ad;
                        af.a = 2;
                        af.g = i[ad];
                        a.add(af);
                        for (let ag = 0; ag < m.count; ag++) {
                            let ah = m._inner[ag];
                            if (!ah.c && ah.d >= ad) {
                                ah.d++;
                            }
                        }
                    }
                    else {
                        let ai = l.item(ae.f);
                        if (ai.d == ai.e) {
                            DescriptionTreeReconciler.g(a, ai.a, ae.a, f);
                            continue;
                        }
                        let aj = new DescriptionTreeAction();
                        aj.j = e.c;
                        aj.c = b;
                        aj.b = c;
                        aj.d = e.a;
                        aj.f = ai.d;
                        aj.a = 4;
                        aj.h = ai.a;
                        a.add(aj);
                        for (let ak = 0; ak < m.count; ak++) {
                            let al = m._inner[ak];
                            if (!al.c && al.a != ai.a && al.d >= ai.d) {
                                al.d--;
                            }
                        }
                        aj = new DescriptionTreeAction();
                        aj.j = e.c;
                        aj.c = b;
                        aj.b = c;
                        aj.d = e.a;
                        aj.e = ai.e;
                        aj.a = 2;
                        aj.g = ai.a;
                        a.add(aj);
                        ai.d = ai.e;
                        for (let am = 0; am < m.count; am++) {
                            let an = m._inner[am];
                            if (!an.c && an.a != ai.a && an.d >= ai.d) {
                                an.d++;
                            }
                        }
                        DescriptionTreeReconciler.g(a, ai.a, ae.a, f);
                    }
                }
            }
            else {
                let ao = Math.max(h.length, i.length);
                for (let ap = 0; ap < ao; ap++) {
                    if (ap >= h.length) {
                        let aq = new DescriptionTreeAction();
                        aq.j = e.c;
                        aq.c = b;
                        aq.b = c;
                        aq.d = e.a;
                        aq.e = ap;
                        aq.a = 2;
                        aq.g = i[ap];
                        a.add(aq);
                    }
                    else if (ap >= i.length) {
                        let ar = new DescriptionTreeAction();
                        ar.j = e.c;
                        ar.c = b;
                        ar.b = c;
                        ar.d = e.a;
                        ar.f = i.length;
                        ar.a = 4;
                        ar.h = h[ap];
                        a.add(ar);
                    }
                    else {
                        let as = h[ap];
                        let at = i[ap];
                        if (typeCast(DescriptionTreeNode.$, as) !== null && typeCast(DescriptionTreeNode.$, at) !== null) {
                            let au = as;
                            let av = at;
                            if (au.i == av.i) {
                                DescriptionTreeReconciler.g(a, au, av, f);
                            }
                            else {
                                let aw = new DescriptionTreeAction();
                                aw.j = e.c;
                                aw.c = b;
                                aw.b = c;
                                aw.d = e.a;
                                aw.f = ap;
                                aw.e = ap;
                                aw.a = 3;
                                aw.h = h[ap];
                                aw.g = i[ap];
                                a.add(aw);
                            }
                        }
                        else {
                            if (!Base.equalsStatic(as, at)) {
                                let ax = new DescriptionTreeAction();
                                ax.j = e.c;
                                ax.c = b;
                                ax.b = c;
                                ax.d = e.a;
                                ax.f = ap;
                                ax.e = ap;
                                ax.a = 3;
                                ax.h = h[ap];
                                ax.g = i[ap];
                                a.add(ax);
                            }
                        }
                    }
                }
            }
        }
        static b(a, b) {
            let c = a;
            let d = b;
            if (c == null && d == null) {
                return true;
            }
            if ((c != null && d == null) || (c == null && d != null)) {
                return false;
            }
            if (c.length != d.length) {
                return false;
            }
            for (let e = 0; e < c.length; e++) {
                let f = c[e];
                let g = d[e];
                if (typeCast(DescriptionTreeNode.$, f) !== null && !(typeCast(DescriptionTreeNode.$, g) !== null)) {
                    return false;
                }
                if (!(typeCast(DescriptionTreeNode.$, f) !== null) && typeCast(DescriptionTreeNode.$, g) !== null) {
                    return false;
                }
                if (typeCast(DescriptionTreeNode.$, f) !== null) {
                    let h = f;
                    let i = g;
                    if (h.i != i.i) {
                        return false;
                    }
                    let j = h.c("Name") ? h.a("Name").b : null;
                    let k = i.c("Name") ? i.a("Name").b : null;
                    if (!Base.equalsStatic(j, k)) {
                        return false;
                    }
                }
                else {
                    if (!Base.equalsStatic(f, g)) {
                        return false;
                    }
                }
            }
            return true;
        }
        static e(a) {
            let b = new List$1(DescriptionPropertyValue.$, 0);
            let c = a.f();
            for (let d = 0; d < c.count; d++) {
                let e = c._inner[d];
                if (e.a != null && e.a.knownType != 10 && e.a.knownType != 9) {
                    b.add(e);
                }
            }
            return b;
        }
        static d(a) {
            let b = new List$1(DescriptionPropertyValue.$, 0);
            let c = a.f();
            for (let d = 0; d < c.count; d++) {
                let e = c._inner[d];
                if (e.a != null && (e.a.knownType == 10 || e.a.knownType == 9)) {
                    b.add(e);
                }
            }
            return b;
        }
    }
    DescriptionTreeReconciler.$t = /*@__PURE__*/ markType(DescriptionTreeReconciler, 'DescriptionTreeReconciler');
    return DescriptionTreeReconciler;
})();
