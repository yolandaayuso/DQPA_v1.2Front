/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { Base, Point_$type, fromEnum, markType } from "./type";
import { Rect } from "./Rect";
import { CoreGeometryUtil } from "./CoreGeometryUtil";
import { MathUtil } from "./MathUtil";
import { List$1 } from "./List$1";
import { Tuple$2 } from "./Tuple$2";
import { isNaN_, isInfinity } from "./number";
/**
 * @hidden
 */
export let GeometryUtil = /*@__PURE__*/ (() => {
    class GeometryUtil extends Base {
        static n(a) {
            if (isNaN_(a) || isInfinity(a)) {
                return a;
            }
            while (a > 360) {
                a -= 360;
            }
            while (a < 0) {
                a += 360;
            }
            return a;
        }
        static g(a) {
            return Math.atan(a);
        }
        static o(a, b) {
            return (b.y - a.y) / (b.x - a.x);
        }
        static i(a) {
            return 1 - Math.pow(a.height / 2, 2) / Math.pow(a.width / 2, 2);
        }
        static x(a, b, c, d, e) {
            let f = Math.cos(a);
            let g = Math.sin(a);
            let h = Math.sqrt(d * d / (1 - (b * Math.pow(f, 2))));
            h *= e;
            return { $type: Point_$type, x: h * f + c.x, y: h * g + c.y };
        }
        static t(a, b, c, d, e) {
            let f;
            if (c) {
                f = GeometryUtil.u({ $type: Point_$type, x: a / 2, y: b / 2 }, d, e);
            }
            else {
                f = { $type: Point_$type, x: a / 2, y: b / 2 };
            }
            return f;
        }
        static u(a, b, c) {
            b = b / 180 * Math.PI;
            let d = a.y + c * Math.sin(b);
            let e = a.x + c * Math.cos(b);
            return { $type: Point_$type, x: e, y: d };
        }
        static w(a, b, c) {
            let d = b.x - a.x;
            let e = b.y - a.y;
            let f = Math.sqrt(d * d + e * e);
            d = d / f * c;
            e = e / f * c;
            return { $type: Point_$type, x: a.x + d, y: a.y + e };
        }
        static k(a, b) {
            let c = Math.abs(b.x - a.x);
            let d = Math.abs(b.y - a.y);
            return Math.sqrt(c * c + d * d);
        }
        static v(a, b, c, d, e) {
            return CoreGeometryUtil.c(a, b, c, d, e);
        }
        static j(a, b) {
            let c = Math.sqrt(Math.pow(b.x - a.x, 2) + Math.pow(b.y - a.y, 2));
            let d = Math.acos((b.x - a.x) / c);
            if ((b.y - a.y) < 0) {
                d = (2 * Math.PI) - d;
            }
            return d;
        }
        static f(a, b, c, d, e, f) {
            if (isNaN_(c) || isNaN_(d) || isNaN_(e)) {
                return false;
            }
            let g = e * e;
            let h = f * f;
            let i = a.x - b.x;
            let j = a.y - b.y;
            if (i > g || j > g) {
                return false;
            }
            let k = i * i + j * j;
            if (k > g) {
                return false;
            }
            if (k < h) {
                return false;
            }
            let l = Math.atan2(j, i);
            return GeometryUtil.b(l, c, d);
        }
        static b(a, b, c) {
            let d = MathUtil.f(a);
            let e = MathUtil.f(b);
            let f = MathUtil.f(c);
            d = GeometryUtil.n(d);
            let g = Math.min(e, f);
            let h = Math.max(e, f);
            return (d > g && d < h) || (d - 360 > g && d - 360 < h) || (d + 360 > g && d + 360 < h);
        }
        static y(a, b, c, d) {
            let e = { $type: Point_$type, x: a.x + Math.cos(b) * d, y: a.y + Math.sin(b) * d };
            let f = { $type: Point_$type, x: a.x + Math.cos(c) * d, y: a.y + Math.sin(c) * d };
            let g = new List$1(Point_$type, 0);
            g.add(e);
            g.add(f);
            g.add(a);
            let h = MathUtil.f(b);
            let i = MathUtil.f(c);
            h = GeometryUtil.n(h);
            i = GeometryUtil.n(i);
            if ((0 > h && 0 < i) || (360 > h && 360 < i) || (i < h)) {
                g.add(GeometryUtil.u(a, 0, d));
            }
            if (90 > h && 90 < i) {
                g.add(GeometryUtil.u(a, 90, d));
            }
            if (180 > h && 180 < i) {
                g.add(GeometryUtil.u(a, 180, d));
            }
            if (270 > h && 270 < i) {
                g.add(GeometryUtil.u(a, 270, d));
            }
            let j = 1.7976931348623157E+308;
            let k = 1.7976931348623157E+308;
            let l = -1.7976931348623157E+308;
            let m = -1.7976931348623157E+308;
            for (let n of fromEnum(g)) {
                j = Math.min(j, n.x);
                k = Math.min(k, n.y);
                l = Math.max(l, n.x);
                m = Math.max(m, n.y);
            }
            return new Rect(0, j, k, l - j, m - k);
        }
        static c(a, b, c) {
            let d = a.x - b.x;
            let e = a.y - b.y;
            let f = d * d + e * e;
            let g = c * c;
            return f < g;
        }
        static r(a, b, c, d) {
            let e = a.x - c.x;
            let f = a.y - c.y;
            let g = b.x - c.x;
            let h = b.y - c.y;
            let i = g - e;
            let j = h - f;
            let k = Math.sqrt(i * i + j * j);
            let l = e * h - g * f;
            let m = d * d;
            let n = k * k;
            let o = l * l;
            let p = m * n - o;
            if (p < 0) {
                return new Tuple$2(Point_$type, Point_$type, { $type: Point_$type, x: NaN, y: NaN }, { $type: Point_$type, x: NaN, y: NaN });
            }
            let q = 1;
            if (j < 0) {
                q = -1;
            }
            let r = (l * j + q * i * Math.sqrt(p)) / n;
            let s = (l * j - q * i * Math.sqrt(p)) / n;
            let t = (-1 * l * i + Math.abs(j) * Math.sqrt(p)) / n;
            let u = (-1 * l * i - Math.abs(j) * Math.sqrt(p)) / n;
            return new Tuple$2(Point_$type, Point_$type, { $type: Point_$type, x: r + c.x, y: t + c.y }, { $type: Point_$type, x: s + c.x, y: u + c.y });
        }
        static d(a, b, c, d) {
            let e = d * d;
            let f = b.x;
            let g = b.y;
            let h = c.x;
            let i = c.y;
            let j = a.x;
            let k = a.y;
            if (g == i) {
                let l = Math.abs(g - k) < d;
                let m = j >= Math.min(f, h) - d && j <= Math.max(f, h) + d;
                if (l && m) {
                    return true;
                }
                else {
                    return false;
                }
            }
            if (f == h) {
                let n = Math.abs(f - j) < d;
                let o = k >= Math.min(g, i) - d && k <= Math.max(g, i) + d;
                if (n && o) {
                    return true;
                }
                else {
                    return false;
                }
            }
            let p = h - f;
            let q = i - g;
            let r = p * p + q * q;
            if (r == 0) {
                return (j - f) * (j - f) + (k - g) * (k - g) < e;
            }
            let s = ((j - f) * p + (k - g) * q) / r;
            s = s < 0 ? 0 : (s > 1 ? 1 : s);
            let t = f + p * s;
            let u = g + q * s;
            let v = (t - j) * (t - j) + (u - k) * (u - k);
            if (v < e) {
                return true;
            }
            return false;
        }
        static h(a, b, c) {
            let d = b.x;
            let e = b.y;
            let f = c.x;
            let g = c.y;
            let h = a.x;
            let i = a.y;
            let j = f - d;
            let k = g - e;
            let l = j * j + k * k;
            if (l == 0) {
                return (h - d) * (h - d) + (i - e) * (i - e);
            }
            let m = ((h - d) * j + (i - e) * k) / l;
            m = m < 0 ? 0 : (m > 1 ? 1 : m);
            let n = d + j * m;
            let o = e + k * m;
            let p = (n - h) * (n - h) + (o - i) * (o - i);
            return p;
        }
        static m(a, b, c) {
            let d = b.x;
            let e = b.y;
            let f = c.x;
            let g = c.y;
            let h = a.x;
            let i = a.y;
            let j = f - d;
            let k = g - e;
            let l = j * j + k * k;
            if (l == 0) {
                return 0;
            }
            let m = ((h - d) * j + (i - e) * k) / l;
            m = m < 0 ? 0 : (m > 1 ? 1 : m);
            return m;
        }
        static e(a, b, c, d) {
            let e;
            let f;
            let g = d * d;
            let h = c.count;
            if (h == 0) {
                return (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y) < g;
            }
            let i = a.x;
            let j = a.y;
            for (let k = 0; k < h; k++) {
                if (k == 0) {
                    f = c.item(k);
                    e = b;
                }
                else {
                    f = c.item(k);
                    e = c.item(k - 1);
                }
                let l = e.x;
                let m = e.y;
                let n = f.x;
                let o = f.y;
                if (m == o) {
                    let p = Math.abs(m - j) < d;
                    let q = i >= Math.min(l, n) - d && i <= Math.max(l, n) + d;
                    if (p && q) {
                        return true;
                    }
                    else {
                        continue;
                    }
                }
                if (l == n) {
                    let r = Math.abs(l - i) < d;
                    let s = j >= Math.min(m, o) - d && j <= Math.max(m, o) + d;
                    if (r && s) {
                        return true;
                    }
                    else {
                        continue;
                    }
                }
                let t = n - l;
                let u = o - m;
                let v = t * t + u * u;
                if (v == 0) {
                    return (i - l) * (i - l) + (j - m) * (j - m) < g;
                }
                let w = ((i - l) * t + (j - m) * u) / v;
                w = w < 0 ? 0 : (w > 1 ? 1 : w);
                let x = l + t * w;
                let y = m + u * w;
                let z = (x - i) * (x - i) + (y - j) * (y - j);
                if (z < g) {
                    return true;
                }
            }
            return false;
        }
        static l(a, b, c, d) {
            let e = Math.abs(Math.cos(b));
            let f = Math.abs(Math.sin(b));
            let g = c * 0.5;
            let h = d * 0.5;
            let i = e * h - f * g;
            if (a * a >= i * i) {
                let j = e * g + f * h + Math.sqrt(a * a - i * i);
                let k = j * e - g;
                let l = j * f - h;
                if (k > 0 && l > 0) {
                    return j;
                }
                else if (k > 0) {
                    return (a + g) / e;
                }
                else if (l > 0) {
                    return (a + h) / f;
                }
                else {
                    return 0;
                }
            }
            else {
                if (i > 0) {
                    return (a + g) / e;
                }
                else if (i < 0) {
                    return (a + h) / f;
                }
                else {
                    return 0;
                }
            }
        }
        static q(a, b, c, d, e, f, g) {
            let h, i, j, k, l, m, n;
            h = e.x - d.x;
            i = e.y - d.y;
            j = h * h + i * i;
            k = 2 * (h * (d.x - a) + i * (d.y - b));
            l = (d.x - a) * (d.x - a) + (d.y - b) * (d.y - b) - c * c;
            m = k * k - 4 * j * l;
            if ((j <= 1E-07) || (m < 0)) {
                f = { $type: Point_$type, x: NaN, y: NaN };
                g = { $type: Point_$type, x: NaN, y: NaN };
                return {
                    ret: 0,
                    p5: f,
                    p6: g
                };
            }
            else if (m == 0) {
                n = -k / (2 * j);
                f = { $type: Point_$type, x: d.x + n * h, y: d.y + n * i };
                g = { $type: Point_$type, x: NaN, y: NaN };
                return {
                    ret: 1,
                    p5: f,
                    p6: g
                };
            }
            else {
                n = ((-k + Math.sqrt(m)) / (2 * j));
                f = { $type: Point_$type, x: d.x + n * h, y: d.y + n * i };
                n = ((-k - Math.sqrt(m)) / (2 * j));
                g = { $type: Point_$type, x: d.x + n * h, y: d.y + n * i };
                return {
                    ret: 2,
                    p5: f,
                    p6: g
                };
            }
        }
        static p(a, b, c, d, e, f, g) {
            let h, i, j, k, l, m;
            h = e.x - d.x;
            i = e.y - d.y;
            j = h * h + i * i;
            k = 2 * (h * (d.x - a) + i * (d.y - b));
            l = (d.x - a) * (d.x - a) + (d.y - b) * (d.y - b) - c * c;
            m = k * k - 4 * j * l;
            if ((j <= 1E-07) || (m < 0) || (m == 0)) {
                f = { $type: Point_$type, x: NaN, y: NaN };
                g = { $type: Point_$type, x: NaN, y: NaN };
                return {
                    ret: 0,
                    p5: f,
                    p6: g
                };
            }
            else {
                let n = 0;
                let o = ((-k + Math.sqrt(m)) / (2 * j));
                let p = ((-k - Math.sqrt(m)) / (2 * j));
                if (o >= 0 && o <= 1) {
                    n++;
                    f = { $type: Point_$type, x: d.x + o * h, y: d.y + o * i };
                    if (p >= 0 && p <= 1) {
                        n++;
                        g = { $type: Point_$type, x: d.x + p * h, y: d.y + p * i };
                    }
                    else {
                        g = { $type: Point_$type, x: NaN, y: NaN };
                    }
                }
                else {
                    g = { $type: Point_$type, x: NaN, y: NaN };
                    if (p >= 0 && p <= 1) {
                        n++;
                        f = { $type: Point_$type, x: d.x + p * h, y: d.y + p * i };
                    }
                    else {
                        f = { $type: Point_$type, x: NaN, y: NaN };
                    }
                }
                return {
                    ret: n,
                    p5: f,
                    p6: g
                };
            }
        }
        static s(a, b, c, d, e) {
            let f = new List$1(Point_$type, 0);
            let g = { $type: Point_$type, x: a.left, y: a.bottom };
            let h = { $type: Point_$type, x: a.right, y: a.bottom };
            let i = { $type: Point_$type, x: a.left, y: a.top };
            let j = { $type: Point_$type, x: a.right, y: a.top };
            let k = c.y - a.bottom;
            let l = c.y - a.top;
            let m = c.x - a.left;
            let n = c.x - a.right;
            if (Math.sqrt(k * k + m * m) < b) {
                f.add(g);
            }
            if (Math.sqrt(k * k + n * n) < b) {
                f.add(h);
            }
            if (Math.sqrt(l * l + m * m) < b) {
                f.add(i);
            }
            if (Math.sqrt(l * l + n * n) < b) {
                f.add(j);
            }
            let o, p;
            let q = ((() => { let r = GeometryUtil.p(c.x, c.y, b, g, h, o, p); o = r.p5; p = r.p6; return r.ret; })());
            if (q > 0) {
                f.add(o);
            }
            if (q > 1) {
                f.add(p);
            }
            q = ((() => { let r = GeometryUtil.p(c.x, c.y, b, g, i, o, p); o = r.p5; p = r.p6; return r.ret; })());
            if (q > 0) {
                f.add(o);
            }
            if (q > 1) {
                f.add(p);
            }
            q = ((() => { let r = GeometryUtil.p(c.x, c.y, b, j, i, o, p); o = r.p5; p = r.p6; return r.ret; })());
            if (q > 0) {
                f.add(o);
            }
            if (q > 1) {
                f.add(p);
            }
            q = ((() => { let r = GeometryUtil.p(c.x, c.y, b, j, h, o, p); o = r.p5; p = r.p6; return r.ret; })());
            if (q > 0) {
                f.add(o);
            }
            if (q > 1) {
                f.add(p);
            }
            if (f.count == 0) {
                d = -1;
                e = -1;
                return {
                    p3: d,
                    p4: e
                };
            }
            d = 1.7976931348623157E+308;
            e = -1.7976931348623157E+308;
            let r = 1.7976931348623157E+308;
            let s = -1.7976931348623157E+308;
            for (let t = 0; t < f.count; t++) {
                let u = GeometryUtil.j(c, f._inner[t]);
                if (u < d) {
                    d = u;
                }
                if (u > e) {
                    e = u;
                }
                if (u < Math.PI && u > s) {
                    s = u;
                }
                if (u > Math.PI && u < s) {
                    r = u;
                }
            }
            if (e - d > Math.PI) {
                d = r;
                e = s;
            }
            return {
                p3: d,
                p4: e
            };
        }
        static a(a, b, c, d) {
            let e = ((b.x - a.x) * (d.y - c.y)) - ((b.y - a.y) * (d.x - c.x));
            let f = ((a.y - c.y) * (d.x - c.x)) - ((a.x - c.x) * (d.y - c.y));
            let g = ((a.y - c.y) * (b.x - a.x)) - ((a.x - c.x) * (b.y - a.y));
            if (e == 0) {
                return f == 0 && g == 0;
            }
            let h = f / e;
            let i = g / e;
            return (h >= 0 && h <= 1) && (i >= 0 && i <= 1);
        }
    }
    GeometryUtil.$t = /*@__PURE__*/ markType(GeometryUtil, 'GeometryUtil');
    return GeometryUtil;
})();
