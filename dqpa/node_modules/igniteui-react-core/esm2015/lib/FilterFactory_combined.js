/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { Base, markType, typeCast, typeGetValue, EnumUtil, enumGetBox, IComparable_$type, Date_$type, String_$type, Number_$type, Boolean_$type, getInstanceType } from "./type";
import { IFilterExpression_$type } from "./IFilterExpression";
import { DataSourceSchemaPropertyType_$type } from "./DataSourceSchemaPropertyType";
import { FilterExpressionOperatorType_$type } from "./FilterExpressionOperatorType";
import { FilterExpressionFunctionType, FilterExpressionFunctionType_$type } from "./FilterExpressionFunctionType";
import { dateMinValue, dateGetMonth, dateGetDate, dateNow, dateAddDays, dateAddMonths, dateAddYears } from "./date";
import { Convert } from "./Convert";
import { IOperationFilterExpression_$type } from "./IOperationFilterExpression";
import { NotImplementedException } from "./NotImplementedException";
import { InvalidOperationException } from "./InvalidOperationException";
import { intDivide, isNaN_ } from "./number";
import { CompareUtil } from "./compareUtil";
import { stringCompareTo, stringConcat, stringEndsWith, stringReplace, stringStartsWith, stringContains } from "./string";
import { IFunctionFilterExpression_$type } from "./IFunctionFilterExpression";
import { FilterExpressionCollection } from "./FilterExpressionCollection";
import { IPropertyReferenceFilterExpression_$type } from "./IPropertyReferenceFilterExpression";
import { ILiteralFilterExpression_$type } from "./ILiteralFilterExpression";
/**
 * @hidden
 */
export let FilterFactory = /*@__PURE__*/ (() => {
    class FilterFactory extends Base {
        constructor() {
            super(...arguments);
            this.av = dateMinValue();
        }
        get todayOverride() {
            return this.av;
        }
        set todayOverride(a) {
            this.av = a;
        }
        static get instance() {
            if (FilterFactory.at == null) {
                FilterFactory.at = new FilterFactory();
            }
            return FilterFactory.at;
        }
        static build(a) {
            let b = FilterFactory.instance;
            return a(b);
        }
        property(a) {
            return FilterExpression.property(a);
        }
        literal(a) {
            return FilterExpression.literal(a);
        }
        group(a) {
            return FilterExpression.operation(a, 15, null);
        }
        and(a, b) {
            return FilterExpression.operation(a, 7, b);
        }
        or(a, b) {
            return FilterExpression.operation(a, 8, b);
        }
        not(a) {
            return FilterExpression.operation(a, 9, null);
        }
        add(a, b) {
            return FilterExpression.operation(a, 10, b);
        }
        divide(a, b) {
            return FilterExpression.operation(a, 13, b);
        }
        equal(a, b) {
            return FilterExpression.operation(a, 1, b);
        }
        greaterThan(a, b) {
            return FilterExpression.operation(a, 3, b);
        }
        greaterThanOrEqual(a, b) {
            return FilterExpression.operation(a, 4, b);
        }
        lessThan(a, b) {
            return FilterExpression.operation(a, 5, b);
        }
        lessThanOrEqual(a, b) {
            return FilterExpression.operation(a, 6, b);
        }
        modulus(a, b) {
            return FilterExpression.operation(a, 14, b);
        }
        multiply(a, b) {
            return FilterExpression.operation(a, 12, b);
        }
        notEqual(a, b) {
            return FilterExpression.operation(a, 2, b);
        }
        subtract(a, b) {
            return FilterExpression.operation(a, 11, b);
        }
        ceiling(a) {
            return FilterExpression.func(19, a);
        }
        concat(a, b) {
            return FilterExpression.func(10, a, b);
        }
        concat1(a, b) {
            return FilterExpression.func(10, a, FilterExpression.literal(b));
        }
        contains(a, b) {
            if (typeof b === 'string') {
                b = FilterExpression.literal(b);
            }
            return FilterExpression.func(0, a, b);
        }
        day(a) {
            return FilterExpression.func(11, a);
        }
        endsWith(a, b) {
            if (typeof b === 'string') {
                b = FilterExpression.literal(b);
            }
            return FilterExpression.func(1, a, b);
        }
        floor(a) {
            return FilterExpression.func(18, a);
        }
        hour(a) {
            return FilterExpression.func(12, a);
        }
        indexOf(a, b) {
            if (typeof b === 'string') {
                b = FilterExpression.literal(b);
            }
            return FilterExpression.func(4, a, b);
        }
        length(a) {
            return FilterExpression.func(FilterExpressionFunctionType.Length, a);
        }
        minute(a) {
            return FilterExpression.func(13, a);
        }
        month(a) {
            return FilterExpression.func(14, a);
        }
        replace(a, b, c) {
            if (typeof b === 'string') {
                b = FilterExpression.literal(b);
            }
            if (typeof c === 'string') {
                c = FilterExpression.literal(c);
            }
            return FilterExpression.func(5, a, b, c);
        }
        round(a) {
            return FilterExpression.func(17, a);
        }
        second(a) {
            return FilterExpression.func(15, a);
        }
        startsWith(a, b) {
            if (typeof b === 'string') {
                b = FilterExpression.literal(b);
            }
            return FilterExpression.func(2, a, b);
        }
        substring(a, b, c = null) {
            if (typeof b === 'number') {
                b = FilterExpression.literal(b);
            }
            if (c != null && typeof c === 'number') {
                c = FilterExpression.literal(c);
            }
            if (c != null) {
                return FilterExpression.func(6, a, b, c);
            }
            else {
                return FilterExpression.func(6, a, b);
            }
        }
        toLower(a) {
            return FilterExpression.func(7, a);
        }
        toUpper(a) {
            return FilterExpression.func(8, a);
        }
        trim(a) {
            return FilterExpression.func(9, a);
        }
        year(a) {
            return FilterExpression.func(16, a);
        }
        date(a) {
            return FilterExpression.func(20, a);
        }
        time(a) {
            return FilterExpression.func(21, a);
        }
        now() {
            return FilterExpression.func(16);
        }
        isOf(a, b) {
            return FilterExpression.func(16, a);
        }
        cast(a, b) {
            return FilterExpression.func(24, a);
        }
        env(a) {
            return FilterExpression.func(25, a);
        }
    }
    FilterFactory.$t = /*@__PURE__*/ markType(FilterFactory, 'FilterFactory');
    FilterFactory.at = null;
    return FilterFactory;
})();
/**
 * @hidden
 */
export let FilterExpression = /*@__PURE__*/ (() => {
    class FilterExpression extends Base {
        constructor() {
            super(...arguments);
            this.bj = false;
            this._precedence = 0;
            this.bk = false;
        }
        get_precedence() {
            return this._precedence;
        }
        get precedence() {
            return this.get_precedence();
        }
        markAutoGenerated() {
            this.bk = true;
        }
        get isAutoGenerated() {
            return this.bk;
        }
        static isFilterExpression(a) {
            return typeCast(IFilterExpression_$type, a) !== null;
        }
        static isSchemaType(a) {
            return typeCast(DataSourceSchemaPropertyType_$type, a) !== null;
        }
        static operation(a, b, c) {
            if (FilterExpression.isFilterExpression(a)) {
                let d = a;
                if (FilterExpression.isFilterExpression(c)) {
                    let e = c;
                    return new OperationFilterExpression(d, b, e);
                }
                else {
                    return new OperationFilterExpression(d, b, c);
                }
            }
            else {
                let f = a;
                if (FilterExpression.isFilterExpression(c)) {
                    let g = c;
                    return new OperationFilterExpression(f, b, g);
                }
                else {
                    return new OperationFilterExpression(f, b, c);
                }
            }
        }
        static func(a, ...b) {
            return new FunctionFilterExpression(a, ...b);
        }
        bq() {
            this.bj = this.bo();
        }
        static property(a) {
            if (a == null) {
                return null;
            }
            let b = new PropertyReferenceFilterExpression(null);
            b.propertyReference = a;
            return b;
        }
        static nullLiteral() {
            let a = new LiteralFilterExpression(null, false);
            return a;
        }
        static literal(a) {
            let b = new LiteralFilterExpression(a, false);
            return b;
        }
        static unquotedLiteral(a) {
            let b = new LiteralFilterExpression(a, true);
            return b;
        }
        match(a, b, c) {
            return this.matchWithEnvironment(a, b, c, null);
        }
        matchWithEnvironment(a, b, c, d) {
            let e = this.evaluateWithEnvironment(a, b, c, d);
            return this.bp(e, b, c);
        }
        bp(a, b, c) {
            if (!this.bj) {
                return this.bl(a, b, c);
            }
            return a;
        }
        bl(a, b, c) {
            return Convert.toBoolean(a);
        }
        evaluate(a, b, c) {
            return this.evaluateWithEnvironment(a, b, c, null);
        }
        get_isPropertyReference() {
            return false;
        }
        get isPropertyReference() {
            return this.get_isPropertyReference();
        }
        get_isOperation() {
            return false;
        }
        get isOperation() {
            return this.get_isOperation();
        }
        get_isFunction() {
            return false;
        }
        get isFunction() {
            return this.get_isFunction();
        }
        get_isLiteral() {
            return false;
        }
        get isLiteral() {
            return this.get_isLiteral();
        }
        get_isNull() {
            return false;
        }
        get isNull() {
            return this.get_isNull();
        }
        get_isWrapper() {
            return false;
        }
        get isWrapper() {
            return this.get_isWrapper();
        }
        group() {
            return FilterExpression.operation(this, 15, null);
        }
        and(a) {
            return FilterExpression.operation(this, 7, a);
        }
        or(a) {
            return FilterExpression.operation(this, 8, a);
        }
        not() {
            return FilterExpression.operation(this, 9, null);
        }
        add(a) {
            if (FilterExpression.isFilterExpression(a)) {
                let b = a;
                return FilterExpression.operation(this, 10, b);
            }
            else {
                return FilterExpression.operation(this, 10, a);
            }
        }
        plus(a) {
            if (FilterExpression.isFilterExpression(a)) {
                let b = a;
                return FilterExpression.operation(this, 10, b);
            }
            else {
                return FilterExpression.operation(this, 10, a);
            }
        }
        divide(a) {
            if (FilterExpression.isFilterExpression(a)) {
                let b = a;
                return FilterExpression.operation(this, 13, b);
            }
            else {
                return FilterExpression.operation(this, 13, a);
            }
        }
        divideBy(a) {
            if (FilterExpression.isFilterExpression(a)) {
                let b = a;
                return FilterExpression.operation(this, 13, b);
            }
            else {
                return FilterExpression.operation(this, 13, a);
            }
        }
        isEqualTo(a) {
            if (FilterExpression.isFilterExpression(a)) {
                let b = a;
                return FilterExpression.operation(this, 1, b);
            }
            else {
                return FilterExpression.operation(this, 1, a);
            }
        }
        isGreaterThan(a) {
            if (FilterExpression.isFilterExpression(a)) {
                let b = a;
                return FilterExpression.operation(this, 3, b);
            }
            else {
                return FilterExpression.operation(this, 3, a);
            }
        }
        isGreaterThanOrEqualTo(a) {
            if (FilterExpression.isFilterExpression(a)) {
                let b = a;
                return FilterExpression.operation(this, 4, b);
            }
            else {
                return FilterExpression.operation(this, 4, a);
            }
        }
        isLessThan(a) {
            if (FilterExpression.isFilterExpression(a)) {
                let b = a;
                return FilterExpression.operation(this, 5, b);
            }
            else {
                return FilterExpression.operation(this, 5, a);
            }
        }
        isLessThanOrEqualTo(a) {
            if (FilterExpression.isFilterExpression(a)) {
                let b = a;
                return FilterExpression.operation(this, 6, b);
            }
            else {
                return FilterExpression.operation(this, 6, a);
            }
        }
        modulo(a) {
            if (FilterExpression.isFilterExpression(a)) {
                let b = a;
                return FilterExpression.operation(this, 14, b);
            }
            else {
                return FilterExpression.operation(this, 14, a);
            }
        }
        multiply(a) {
            if (FilterExpression.isFilterExpression(a)) {
                let b = a;
                return FilterExpression.operation(this, 12, b);
            }
            else {
                return FilterExpression.operation(this, 12, a);
            }
        }
        times(a) {
            if (FilterExpression.isFilterExpression(a)) {
                let b = a;
                return FilterExpression.operation(this, 12, b);
            }
            else {
                return FilterExpression.operation(this, 12, a);
            }
        }
        isNotEqualTo(a) {
            if (FilterExpression.isFilterExpression(a)) {
                let b = a;
                return FilterExpression.operation(this, 2, b);
            }
            else {
                return FilterExpression.operation(this, 2, a);
            }
        }
        subtract(a) {
            if (FilterExpression.isFilterExpression(a)) {
                let b = a;
                return FilterExpression.operation(this, 11, b);
            }
            else {
                return FilterExpression.operation(this, 11, a);
            }
        }
        minus(a) {
            if (FilterExpression.isFilterExpression(a)) {
                let b = a;
                return FilterExpression.operation(this, 11, b);
            }
            else {
                return FilterExpression.operation(this, 11, a);
            }
        }
        ceiling() {
            return FilterExpression.func(19, this);
        }
        concat(a) {
            if (FilterExpression.isFilterExpression(a)) {
                let b = a;
                return FilterExpression.func(10, this, b);
            }
            else {
                let c = a;
                return FilterExpression.func(10, this, FilterExpression.literal(c));
            }
        }
        contains(a) {
            if (FilterExpression.isFilterExpression(a)) {
                let b = a;
                return FilterExpression.func(0, this, b);
            }
            else {
                let c = a;
                return FilterExpression.func(0, this, FilterExpression.literal(c));
            }
        }
        day() {
            return FilterExpression.func(11, this);
        }
        endsWith(a) {
            if (FilterExpression.isFilterExpression(a)) {
                let b = a;
                return FilterExpression.func(1, this, b);
            }
            else {
                let c = a;
                return FilterExpression.func(1, this, FilterExpression.literal(c));
            }
        }
        floor() {
            return FilterExpression.func(18, this);
        }
        hour() {
            return FilterExpression.func(12, this);
        }
        indexOf(a) {
            if (FilterExpression.isFilterExpression(a)) {
                let b = a;
                return FilterExpression.func(4, this, b);
            }
            else {
                let c = a;
                return FilterExpression.func(4, this, FilterExpression.literal(c));
            }
        }
        length() {
            return FilterExpression.func(FilterExpressionFunctionType.Length, this);
        }
        minute() {
            return FilterExpression.func(13, this);
        }
        month() {
            return FilterExpression.func(14, this);
        }
        isToday() {
            return new TodayExpression(1, this);
        }
        isTomorrow() {
            return new TomorrowExpression(1, this);
        }
        isYesterday() {
            return new YesterdayExpression(1, this);
        }
        isThisWeek() {
            return new ThisWeekExpression(1, this);
        }
        isNextWeek() {
            return new NextWeekExpression(1, this);
        }
        isLastWeek() {
            return new LastWeekExpression(1, this);
        }
        isThisMonth() {
            return new ThisMonthExpression(1, this);
        }
        isNextMonth() {
            return new NextMonthExpression(1, this);
        }
        isLastMonth() {
            return new LastMonthExpression(1, this);
        }
        isThisYear() {
            return new ThisYearExpression(1, this);
        }
        isNextYear() {
            return new NextYearExpression(1, this);
        }
        isLastYear() {
            return new LastYearExpression(1, this);
        }
        isYearToDate() {
            return new YearToDateExpression(1, this);
        }
        isThisQuarter() {
            return new ThisQuarterExpression(1, this);
        }
        isNextQuarter() {
            return new NextQuarterExpression(1, this);
        }
        isLastQuarter() {
            return new LastQuarterExpression(1, this);
        }
        isQ1() {
            return new Q1Expression(1, this);
        }
        isQ2() {
            return new Q2Expression(1, this);
        }
        isQ3() {
            return new Q3Expression(1, this);
        }
        isQ4() {
            return new Q4Expression(1, this);
        }
        replace(a, b) {
            if (FilterExpression.isFilterExpression(a)) {
                let c = a;
                if (FilterExpression.isFilterExpression(b)) {
                    let d = b;
                    return FilterExpression.func(5, this, c, d);
                }
                else {
                    let e = b;
                    return FilterExpression.func(5, this, c, FilterExpression.literal(e));
                }
            }
            else {
                let f = a;
                if (FilterExpression.isFilterExpression(b)) {
                    let g = b;
                    return FilterExpression.func(5, this, FilterExpression.literal(f), g);
                }
                else {
                    let h = b;
                    return FilterExpression.func(5, this, FilterExpression.literal(f), FilterExpression.literal(h));
                }
            }
        }
        round() {
            return FilterExpression.func(17, this);
        }
        second() {
            return FilterExpression.func(15, this);
        }
        startsWith(a) {
            if (FilterExpression.isFilterExpression(a)) {
                let b = a;
                return FilterExpression.func(2, this, b);
            }
            else {
                let c = a;
                return FilterExpression.func(2, this, FilterExpression.literal(c));
            }
        }
        substring(a, b = null) {
            if (FilterExpression.isFilterExpression(a)) {
                let c = a;
                if (b == null) {
                    return FilterExpression.func(6, this, c);
                }
                else {
                    if (FilterExpression.isFilterExpression(b)) {
                        let d = b;
                        return FilterExpression.func(6, this, c, d);
                    }
                    else {
                        let e = typeGetValue(b);
                        return FilterExpression.func(6, this, c, FilterExpression.literal(e));
                    }
                }
            }
            else {
                let f = typeGetValue(a);
                if (b == null) {
                    return FilterExpression.func(6, this, FilterExpression.literal(f));
                }
                else {
                    if (FilterExpression.isFilterExpression(b)) {
                        let g = b;
                        return FilterExpression.func(6, this, FilterExpression.literal(f), g);
                    }
                    else {
                        let h = typeGetValue(b);
                        return FilterExpression.func(6, this, FilterExpression.literal(f), FilterExpression.literal(h));
                    }
                }
            }
        }
        toLower() {
            return FilterExpression.func(7, this);
        }
        toUpper() {
            return FilterExpression.func(8, this);
        }
        trim() {
            return FilterExpression.func(9, this);
        }
        year() {
            return FilterExpression.func(16, this);
        }
        date() {
            return FilterExpression.func(20, this);
        }
        time() {
            return FilterExpression.func(21, this);
        }
        now() {
            return FilterExpression.func(22);
        }
        isOf(a) {
            if (FilterExpression.isFilterExpression(a)) {
                let b = a;
                return FilterExpression.func(23, this, b);
            }
            else {
                let c = a;
                return FilterExpression.func(23, this, FilterExpression.literal(a));
            }
        }
        cast(a) {
            if (FilterExpression.isFilterExpression(a)) {
                let b = a;
                return FilterExpression.func(24, this, b);
            }
            else if (FilterExpression.isSchemaType(a)) {
                let c = EnumUtil.getEnumValue(DataSourceSchemaPropertyType_$type, a);
                return FilterExpression.func(24, this, FilterExpression.literal(enumGetBox(DataSourceSchemaPropertyType_$type, c)));
            }
            else {
                let d = a;
                return FilterExpression.func(24, this, FilterExpression.literal(d));
            }
        }
        env(a) {
            return FilterExpression.func(25, FilterExpression.literal(a));
        }
    }
    FilterExpression.$t = /*@__PURE__*/ markType(FilterExpression, 'FilterExpression', Base.$, [IFilterExpression_$type]);
    return FilterExpression;
})();
/**
 * @hidden
 */
export let OperationFilterExpression = /*@__PURE__*/ (() => {
    class OperationFilterExpression extends FilterExpression {
        constructor(a, b, c) {
            super();
            this.bs = null;
            this.bu = false;
            this.bt = null;
            this.bv = false;
            this.br = 0;
            if (a != null) {
                if (FilterExpression.isFilterExpression(a)) {
                    this.bs = a;
                }
                else {
                    this.propertyName = a;
                }
            }
            if (c != null) {
                if (FilterExpression.isFilterExpression(c)) {
                    this.bt = c;
                }
                else {
                    this.value = c;
                }
            }
            this.br = b;
        }
        get_isOperation() {
            return true;
        }
        bo() {
            return this.b1;
        }
        get isComparisonOperation() {
            let a = this.operator;
            switch (a) {
                case 0:
                case 1:
                case 2:
                case 3:
                case 5:
                case 6:
                case 4: return true;
            }
            return false;
        }
        get propertyName() {
            if (this.bs == null || !this.bs.isPropertyReference) {
                return null;
            }
            return this.bs.propertyReference;
        }
        set propertyName(a) {
            this.left = FilterExpression.property(a);
        }
        get hasPropertyName() {
            return this.bs != null && this.bs.isPropertyReference;
        }
        get value() {
            if (this.bt == null) {
                return null;
            }
            if (this.bt.isNull) {
                return null;
            }
            if (!this.bt.isLiteral) {
                return null;
            }
            return this.bt.literalValue;
        }
        set value(a) {
            if (a == null) {
                this.right = FilterExpression.nullLiteral();
                return;
            }
            this.right = FilterExpression.literal(a);
        }
        get hasValue() {
            return this.bt != null;
        }
        get left() {
            return this.bs;
        }
        set left(a) {
            this.bs = a;
            this.bu = true;
            this.bq();
        }
        get hasLeft() {
            return this.bu;
        }
        get right() {
            return this.bt;
        }
        set right(a) {
            this.bt = a;
            this.bv = true;
            this.bq();
        }
        get hasRight() {
            return this.bv;
        }
        get operator() {
            return this.br;
        }
        set operator(a) {
            let b = enumGetBox(FilterExpressionOperatorType_$type, this.br);
            let c = a;
            if (c == null) {
                a = 0;
            }
            if ((typeof c == "number")) {
                let d = typeGetValue(c);
                if ((EnumUtil.getName(FilterExpressionOperatorType_$type, d) == undefined)) {
                    a = 0;
                }
                a = d;
            }
            else {
                a = (typeGetValue(EnumUtil.parse(FilterExpressionOperatorType_$type, c, true)));
            }
            this.br = a;
            this.bq();
        }
        get hasOperator() {
            return this.br != 0;
        }
        get b1() {
            switch (this.operator) {
                case 7:
                case 1:
                case 3:
                case 4:
                case 5:
                case 6:
                case 9:
                case 2:
                case 8: return true;
            }
            return false;
        }
        get_precedence() {
            switch (this.operator) {
                case 15: return 0;
                case 9: return 4;
                case 12: return 6;
                case 13: return 7;
                case 14: return 8;
                case 10: return 9;
                case 11: return 10;
                case 5: return 11;
                case 3: return 12;
                case 6: return 13;
                case 4: return 14;
                case 1: return 16;
                case 2: return 17;
                case 7: return 18;
                case 8: return 19;
                case 0: return 99;
            }
            return 99;
        }
        evaluateWithEnvironment(a, b, c, d) {
            switch (this.operator) {
                case 10:
                case 13:
                case 14:
                case 12:
                case 11: return this.b4(a, b, c, d);
                case 0:
                case 1:
                case 3:
                case 4:
                case 5:
                case 6:
                case 2: return this.b5(a, b, c, d);
                case 7:
                case 9:
                case 8: return this.b6(a, b, c, d);
                case 15: if (this.left != null) {
                    return this.left.evaluateWithEnvironment(a, b, c, d);
                }
                else {
                    if (this.right == null) {
                        return null;
                    }
                    return this.right.evaluateWithEnvironment(a, b, c, d);
                }
            }
            throw new NotImplementedException(0);
        }
        b5(a, b, c, d) {
            let e = null;
            let f = null;
            let g = -1;
            if (this.left != null) {
                e = this.left.evaluateWithEnvironment(a, b, c, d);
            }
            if (this.right != null) {
                f = this.right.evaluateWithEnvironment(a, b, c, d);
            }
            if (e == null && f == null) {
                g = 0;
            }
            let h = null;
            let i = null;
            if (typeCast(IComparable_$type, e) !== null) {
                h = e;
            }
            if (typeCast(IComparable_$type, f) !== null) {
                i = f;
            }
            if (typeof e === 'number' && isNaN_(e) || typeof f === 'number' && isNaN_(f) || typeof e === 'number' && isNaN_(e) || typeof f === 'number' && isNaN_(f)) {
                return false;
            }
            if (typeof e === 'number' && !(typeof f === 'number')) {
                f = OperationFilterExpression.b3(f);
            }
            if (typeof f === 'number' && !(typeof e === 'number')) {
                e = OperationFilterExpression.b3(e);
            }
            if (typeCast(Date_$type, e) !== null && typeCast(Date_$type, f) !== null) {
                switch (this.operator) {
                    case 1: return e.getTime() == f.getTime();
                    case 2: return e.getTime() != f.getTime();
                    case 3: return e.getTime() > f.getTime();
                    case 4: return e.getTime() >= f.getTime();
                    case 5: return e.getTime() < f.getTime();
                    case 6: return e.getTime() <= f.getTime();
                }
            }
            if (h != null) {
                if (f == null) {
                    g = CompareUtil.compareToObject(h, 0);
                    if (g == 0) {
                        g = -1;
                    }
                }
                else {
                    g = CompareUtil.compareToObject(h, f);
                }
            }
            else if (i != null) {
                if (e == null) {
                    let j = CompareUtil.compareToObject(i, 0);
                    if (j == 0) {
                        g = 1;
                    }
                    else {
                        g = 1;
                        if (j == 0) {
                            g = 0;
                        }
                        if (j > 0) {
                            g = -1;
                        }
                    }
                }
                else {
                    let k = CompareUtil.compareToObject(i, e);
                    g = 1;
                    if (k == 0) {
                        g = 0;
                    }
                    if (k > 0) {
                        g = -1;
                    }
                }
            }
            else {
                let l = null;
                let m = null;
                if (e != null) {
                    l = e.toString();
                }
                if (f != null) {
                    m = f.toString();
                }
                if (l != null) {
                    if (m == null) {
                        g = 1;
                    }
                    else {
                        g = stringCompareTo(l, m);
                    }
                }
                else if (m != null) {
                    if (l == null) {
                        g = -1;
                    }
                    else {
                        let n = stringCompareTo(m, l);
                        g = 1;
                        if (n == 0) {
                            g = 0;
                        }
                        if (n > 0) {
                            g = -1;
                        }
                    }
                }
                else {
                    g = 0;
                }
            }
            switch (this.operator) {
                case 0:
                case 1: return g == 0;
                case 3: return g > 0;
                case 4: return g >= 0;
                case 5: return g < 0;
                case 6: return g <= 0;
                case 2: return g != 0;
            }
            throw new InvalidOperationException(0);
        }
        static b3(a) {
            if (typeCast(Date_$type, a) !== null) {
                return a.getTime();
            }
            if (a == null) {
                return 0;
            }
            return a;
        }
        b6(a, b, c, d) {
            let e = null;
            let f = null;
            if (this.left != null) {
                e = this.left.evaluateWithEnvironment(a, b, c, d);
            }
            if (this.right != null) {
                f = this.right.evaluateWithEnvironment(a, b, c, d);
            }
            if (f == null && e == null) {
                return false;
            }
            if (f == null) {
                f = false;
            }
            if (e == null) {
                e = false;
            }
            switch (this.operator) {
                case 7: return e && f;
                case 9: if (this.left == null) {
                    return !f;
                }
                else {
                    return !e;
                }
                case 8: return e || f;
            }
            return false;
        }
        b4(a, b, c, d) {
            let e = null;
            let f = null;
            if (this.left != null) {
                e = this.left.evaluateWithEnvironment(a, b, c, d);
            }
            if (this.right != null) {
                f = this.right.evaluateWithEnvironment(a, b, c, d);
            }
            if (e == null) {
                return f;
            }
            if (f == null) {
                return e;
            }
            if (e == null && f == null) {
                return 0;
            }
            if (typeof e === 'number' || typeof f === 'number') {
                switch (this.operator) {
                    case 10: return e + f;
                    case 13: return e / f;
                    case 14: return e % f;
                    case 12: return e * f;
                    case 11: return e - f;
                }
            }
            if (typeof e === 'number' || typeof f === 'number') {
                switch (this.operator) {
                    case 10: return e + f;
                    case 13: return e / f;
                    case 14: return e % f;
                    case 12: return e * f;
                    case 11: return e - f;
                }
            }
            if (typeof e === 'number' || typeof f === 'number') {
                switch (this.operator) {
                    case 10: return e + f;
                    case 13: return e / f;
                    case 14: return e % f;
                    case 12: return e * f;
                    case 11: return e - f;
                }
            }
            if (typeof e === 'number' || typeof f === 'number') {
                switch (this.operator) {
                    case 10: return typeGetValue(e) + typeGetValue(f);
                    case 13: return intDivide(typeGetValue(e), typeGetValue(f));
                    case 14: return typeGetValue(e) % typeGetValue(f);
                    case 12: return typeGetValue(e) * typeGetValue(f);
                    case 11: return typeGetValue(e) - typeGetValue(f);
                }
            }
            if (typeof e === 'number' || typeof f === 'number') {
                switch (this.operator) {
                    case 10: return typeGetValue(e) + typeGetValue(f);
                    case 13: return intDivide(typeGetValue(e), typeGetValue(f));
                    case 14: return typeGetValue(e) % typeGetValue(f);
                    case 12: return typeGetValue(e) * typeGetValue(f);
                    case 11: return typeGetValue(e) - typeGetValue(f);
                }
            }
            if (typeof e === 'number' || typeof f === 'number') {
                switch (this.operator) {
                    case 10: return typeGetValue(e) + typeGetValue(f);
                    case 13: return intDivide(typeGetValue(e), typeGetValue(f));
                    case 14: return typeGetValue(e) % typeGetValue(f);
                    case 12: return typeGetValue(e) * typeGetValue(f);
                    case 11: return typeGetValue(e) - typeGetValue(f);
                }
            }
            if (typeof e === 'number' || typeof f === 'number') {
                switch (this.operator) {
                    case 10: return typeGetValue(e) + typeGetValue(f);
                    case 13: return intDivide(typeGetValue(e), typeGetValue(f));
                    case 14: return typeGetValue(e) % typeGetValue(f);
                    case 12: return typeGetValue(e) * typeGetValue(f);
                    case 11: return typeGetValue(e) - typeGetValue(f);
                }
            }
            throw new NotImplementedException(0);
        }
    }
    OperationFilterExpression.$t = /*@__PURE__*/ markType(OperationFilterExpression, 'OperationFilterExpression', FilterExpression.$, [IOperationFilterExpression_$type]);
    return OperationFilterExpression;
})();
/**
 * @hidden
 */
export let FunctionFilterExpression = /*@__PURE__*/ (() => {
    class FunctionFilterExpression extends FilterExpression {
        constructor(a, ...b) {
            super();
            this.bs = 19;
            this.br = new FilterExpressionCollection();
            this.bs = a;
            for (let c = 0; c < b.length; c++) {
                this.br.add(b[c]);
            }
        }
        get_isFunction() {
            return true;
        }
        bo() {
            return this.bt;
        }
        get functionType() {
            return this.bs;
        }
        set functionType(a) {
            let b = enumGetBox(FilterExpressionFunctionType_$type, this.bs);
            let c = a;
            if (c == null) {
                a = 0;
            }
            if ((typeof c == "number")) {
                let d = typeGetValue(c);
                if ((EnumUtil.getName(FilterExpressionFunctionType_$type, d) == undefined)) {
                    a = 0;
                }
                a = d;
            }
            else {
                a = (typeGetValue(EnumUtil.parse(FilterExpressionFunctionType_$type, c, true)));
            }
            this.bs = a;
            this.bq();
        }
        get bt() {
            switch (this.functionType) {
                case 1:
                case 2:
                case 0: return true;
            }
            return false;
        }
        get functionArguments() {
            return this.br;
        }
        get hasFunctionArguments() {
            return this.br.k.count > 0;
        }
        evaluateWithEnvironment(a, b, c, d) {
            let e = null;
            let f = null;
            let g = null;
            let h = null;
            let i = this.functionArguments.k;
            if (i.count > 0) {
                for (let j = 0; j < i.count; j++) {
                    let k = null;
                    if (i.item(j) != null) {
                        k = i.item(j).evaluateWithEnvironment(a, b, c, d);
                    }
                    switch (j) {
                        case 0:
                            e = k;
                            break;
                        case 1:
                            f = k;
                            break;
                        case 2:
                            g = k;
                            break;
                        case 3:
                            h = k;
                            break;
                    }
                    if (j > 3) {
                        break;
                    }
                }
            }
            switch (this.functionType) {
                case 19:
                    if (e == null) {
                        e = 0;
                    }
                    if (!(typeof e === 'number')) {
                        e = OperationFilterExpression.b3(e);
                    }
                    return Math.ceil(e);
                case 18:
                    if (e == null) {
                        e = 0;
                    }
                    if (!(typeof e === 'number')) {
                        e = OperationFilterExpression.b3(e);
                    }
                    return Math.floor(e);
                case 17:
                    if (e == null) {
                        e = 0;
                    }
                    if (typeof e === 'number') {
                        return Math.round(e);
                    }
                    if (!(typeof e === 'number')) {
                        e = OperationFilterExpression.b3(e);
                    }
                    return Math.round(e);
                case 11:
                    if (e == null) {
                        return 0;
                    }
                    return e.getDate();
                case 12:
                    if (e == null) {
                        return 0;
                    }
                    return e.getHours();
                case 13:
                    if (e == null) {
                        return 0;
                    }
                    return e.getMinutes();
                case 14:
                    if (e == null) {
                        return 0;
                    }
                    return dateGetMonth(e);
                case 16:
                    if (e == null) {
                        return 0;
                    }
                    return e.getFullYear();
                case 15:
                    if (e == null) {
                        return 0;
                    }
                    return e.getSeconds();
                case 20:
                    if (e == null) {
                        return 0;
                    }
                    return dateGetDate(e);
                case 21:
                    if (e == null) {
                        return 0;
                    }
                    return e;
                case 22: return dateNow();
                case 23:
                    let l = this.bw(f, g);
                    let m = e;
                    if (m == null) {
                        return true;
                    }
                    if (l == null) {
                        return false;
                    }
                    if (l.isAssignableFrom(getInstanceType(m))) {
                        return true;
                    }
                    return false;
                case 24:
                    let n = this.bw(f, e);
                    let o = e;
                    if (o == null) {
                        return null;
                    }
                    if (n == null) {
                        return null;
                    }
                    return this.bu(o, n);
                case 10:
                    if (e == null) {
                        e = "";
                    }
                    if (f == null) {
                        f = "";
                    }
                    return stringConcat(e, f);
                case 1:
                    if (e == null) {
                        e = "";
                    }
                    if (f == null) {
                        f = "";
                    }
                    return stringEndsWith(e, f);
                case 4:
                    if (e == null) {
                        e = "";
                    }
                    if (f == null) {
                        f = "";
                    }
                    return e.indexOf(f);
                case FilterExpressionFunctionType.Length:
                    if (e == null) {
                        e = "";
                    }
                    return e.length;
                case 5:
                    if (e == null) {
                        e = "";
                    }
                    if (f == null) {
                        f = "";
                    }
                    if (g == null) {
                        g = "";
                    }
                    return stringReplace(e, f, g);
                case 2:
                    if (e == null) {
                        e = "";
                    }
                    if (f == null) {
                        f = "";
                    }
                    return stringStartsWith(e, f);
                case 6:
                    if (e == null) {
                        e = "";
                    }
                    if (f == null) {
                        f = 0;
                    }
                    if (g != null) {
                        return e.substr(typeGetValue(f), typeGetValue(g));
                    }
                    else {
                        return e.substr(typeGetValue(f));
                    }
                case 0:
                    if (e == null) {
                        e = "";
                    }
                    if (f == null) {
                        f = "";
                    }
                    return stringContains(e, f);
                case 7:
                    if (e == null) {
                        e = "";
                    }
                    return e.toLowerCase();
                case 8:
                    if (e == null) {
                        e = "";
                    }
                    return e.toUpperCase();
                case 9:
                    if (e == null) {
                        e = "";
                    }
                    return e.trim();
                case 25:
                    if (e == null) {
                        e = "";
                    }
                    if (d != null) {
                        if (d.hasVariable(e)) {
                            return d.getVariableValue(e);
                        }
                    }
                    return null;
            }
            throw new NotImplementedException(0);
        }
        get_precedence() {
            switch (this.functionType) {
                case 23: return 15;
                case 24: return 5;
            }
            return 2;
        }
        bu(a, b) {
            if (b == String_$type) {
                if (a == null) {
                    return "";
                }
                return a.toString();
            }
            else if (b == Number_$type || b == Number_$type || b == Number_$type) {
                return Convert.toInt321(a);
            }
            else if (b == Boolean_$type) {
                return Convert.toBoolean(a);
            }
            else if (b == Number_$type) {
                return Convert.toByte1(a);
            }
            else if (b == Date_$type) {
                return Convert.toDateTime(a);
            }
            else if (b == Number_$type || b == Number_$type) {
                return Convert.toInt64(a);
            }
            else if (b == Number_$type) {
                return Convert.toDecimal2(a);
            }
            else {
                return a;
            }
        }
        bw(a, b) {
            if (typeCast(DataSourceSchemaPropertyType_$type, a) !== null || typeof a === 'number') {
                let c = typeGetValue(a);
                switch (c) {
                    case 2: return Boolean_$type;
                    case 10: return Number_$type;
                    case 9: return Date_$type;
                    case 8: return Date_$type;
                    case 6: return Number_$type;
                    case 5: return Number_$type;
                    case 1: return Number_$type;
                    case 3: return Number_$type;
                    case 11:
                        if (b != null && typeof b === 'string') {
                            return this.bv(b);
                        }
                        return Base.$;
                    case 4: return Number_$type;
                    case 7: return Number_$type;
                    case 0: return String_$type;
                }
            }
            if (typeof a === 'string') {
                return this.bv(b);
            }
            return Base.$;
        }
        bv(a) {
            switch (a) {
                case "Edm.Boolean":
                case "Boolean":
                case "bool":
                case "boolean": return Boolean_$type;
                case "Edm.Byte":
                case "Byte":
                case "byte":
                case "Edm.SByte":
                case "SByte": return Number_$type;
                case "Edm.DateTimeOffset":
                case "DateTimeOffset": return Date_$type;
                case "Edm.DateTime":
                case "DateTime":
                case "Calendar":
                case "datetime":
                case "calendar":
                case "Edm.Time":
                case "Time":
                case "time": return Date_$type;
                case "Edm.Decimal":
                case "Decimal":
                case "decimal": return Number_$type;
                case "Edm.Double":
                case "Double":
                case "double": return Number_$type;
                case "Edm.Float":
                case "Float":
                case "float":
                case "Edm.Single":
                case "Single":
                case "single": return Number_$type;
                case "Edm.Int16":
                case "Int16":
                case "Short":
                case "short": return Number_$type;
                case "Edm.Int32":
                case "Int32":
                case "int":
                case "Integer": return Number_$type;
                case "Edm.Int64":
                case "Int64":
                case "long":
                case "Long": return Number_$type;
                case "Edm.String":
                case "String":
                case "string": return String_$type;
            }
            return Base.$;
        }
    }
    FunctionFilterExpression.$t = /*@__PURE__*/ markType(FunctionFilterExpression, 'FunctionFilterExpression', FilterExpression.$, [IFunctionFilterExpression_$type]);
    return FunctionFilterExpression;
})();
/**
 * @hidden
 */
export let PropertyReferenceFilterExpression = /*@__PURE__*/ (() => {
    class PropertyReferenceFilterExpression extends FilterExpression {
        constructor(a) {
            super();
            this.br = null;
            this.br = a;
        }
        get_isPropertyReference() {
            return true;
        }
        get_precedence() {
            return 99;
        }
        bo() {
            return false;
        }
        get propertyReference() {
            return this.br;
        }
        set propertyReference(a) {
            this.br = a;
        }
        evaluateWithEnvironment(a, b, c, d) {
            let e = b.getItemValue(a, this.propertyReference);
            return e;
        }
    }
    PropertyReferenceFilterExpression.$t = /*@__PURE__*/ markType(PropertyReferenceFilterExpression, 'PropertyReferenceFilterExpression', FilterExpression.$, [IPropertyReferenceFilterExpression_$type]);
    return PropertyReferenceFilterExpression;
})();
/**
 * @hidden
 */
export let LiteralFilterExpression = /*@__PURE__*/ (() => {
    class LiteralFilterExpression extends FilterExpression {
        constructor(a, b) {
            super();
            this.bs = null;
            this.br = false;
            this.bs = a;
        }
        get_precedence() {
            return 99;
        }
        get_isLiteral() {
            return true;
        }
        get_isNull() {
            return this.literalValue == null;
        }
        get literalValue() {
            return this.bs;
        }
        set literalValue(a) {
            this.bs = a;
        }
        get leaveUnquoted() {
            return this.br;
        }
        set leaveUnquoted(a) {
            this.br = a;
        }
        bo() {
            return typeCast(Boolean_$type, this.literalValue) !== null;
        }
        evaluateWithEnvironment(a, b, c, d) {
            return this.literalValue;
        }
    }
    LiteralFilterExpression.$t = /*@__PURE__*/ markType(LiteralFilterExpression, 'LiteralFilterExpression', FilterExpression.$, [ILiteralFilterExpression_$type]);
    return LiteralFilterExpression;
})();
/**
 * @hidden
 */
export let WrapperExpression = /*@__PURE__*/ (() => {
    class WrapperExpression extends FilterExpression {
        get innerExpression() {
            return this._innerExpression;
        }
        set innerExpression(a) {
            this._innerExpression = a;
        }
        get expression() {
            return this.br;
        }
        set expression(a) {
            this.br = a;
            this.bx = true;
        }
        get propertyName() {
            if (this.br == null || !this.br.isPropertyReference) {
                return null;
            }
            return this.br.propertyReference;
        }
        set propertyName(a) {
            this.expression = FilterExpression.property(a);
        }
        get_isWrapper() {
            return true;
        }
        get_precedence() {
            return 99;
        }
        get bu() {
            return FilterFactory.instance;
        }
        constructor(a, ..._rest) {
            super();
            this.br = null;
            this.bx = false;
            this._innerExpression = null;
            a = (a == void 0) ? 0 : a;
            switch (a) {
                case 0:
                    {
                        let c = _rest[0];
                        this.expression = FilterFactory.instance.property(c);
                        this.propertyName = c;
                    }
                    break;
                case 1:
                    {
                        let c = _rest[0];
                        this.expression = c;
                        if (this.expression.isPropertyReference) {
                            this.propertyName = this.expression.propertyReference;
                        }
                    }
                    break;
            }
        }
        bo() {
            return true;
        }
        evaluateWithEnvironment(a, b, c, d) {
            if (this.innerExpression == null || this.bx) {
                this.innerExpression = this.bv();
                this.bx = false;
            }
            return this.innerExpression.evaluateWithEnvironment(a, b, c, d);
        }
    }
    WrapperExpression.$t = /*@__PURE__*/ markType(WrapperExpression, 'WrapperExpression', FilterExpression.$);
    return WrapperExpression;
})();
/**
 * @hidden
 */
export let TodayExpression = /*@__PURE__*/ (() => {
    class TodayExpression extends WrapperExpression {
        constructor(a, ..._rest) {
            a = (a == void 0) ? 0 : a;
            switch (a) {
                case 0:
                    {
                        let c = _rest[0];
                        super(0, c);
                    }
                    break;
                case 1:
                    {
                        let c = _rest[0];
                        super(1, c);
                    }
                    break;
            }
        }
        getWrapperType() {
            return 0;
        }
        bv() {
            let a = +(this.bu.todayOverride) != +(dateMinValue()) ? this.bu.todayOverride : dateGetDate(dateNow());
            let b = FilterFactory.instance.literal(dateGetMonth(a));
            let c = FilterFactory.instance.literal(a.getDate());
            let d = FilterFactory.instance.literal(a.getFullYear());
            return this.expression.month().isEqualTo(b).and(this.expression.day().isEqualTo(c)).and(this.expression.year().isEqualTo(d));
        }
    }
    TodayExpression.$t = /*@__PURE__*/ markType(TodayExpression, 'TodayExpression', WrapperExpression.$);
    return TodayExpression;
})();
/**
 * @hidden
 */
export let TomorrowExpression = /*@__PURE__*/ (() => {
    class TomorrowExpression extends WrapperExpression {
        constructor(a, ..._rest) {
            a = (a == void 0) ? 0 : a;
            switch (a) {
                case 0:
                    {
                        let c = _rest[0];
                        super(0, c);
                    }
                    break;
                case 1:
                    {
                        let c = _rest[0];
                        super(1, c);
                    }
                    break;
            }
        }
        getWrapperType() {
            return 1;
        }
        bv() {
            let a = +(this.bu.todayOverride) != +(dateMinValue()) ? this.bu.todayOverride : dateGetDate(dateNow());
            a = dateAddDays(a, 1);
            let b = FilterFactory.instance.literal(dateGetMonth(a));
            let c = FilterFactory.instance.literal(a.getDate());
            let d = FilterFactory.instance.literal(a.getFullYear());
            return this.expression.month().isEqualTo(b).and(this.expression.day().isEqualTo(c)).and(this.expression.year().isEqualTo(d));
        }
    }
    TomorrowExpression.$t = /*@__PURE__*/ markType(TomorrowExpression, 'TomorrowExpression', WrapperExpression.$);
    return TomorrowExpression;
})();
/**
 * @hidden
 */
export let YesterdayExpression = /*@__PURE__*/ (() => {
    class YesterdayExpression extends WrapperExpression {
        constructor(a, ..._rest) {
            a = (a == void 0) ? 0 : a;
            switch (a) {
                case 0:
                    {
                        let c = _rest[0];
                        super(0, c);
                    }
                    break;
                case 1:
                    {
                        let c = _rest[0];
                        super(1, c);
                    }
                    break;
            }
        }
        getWrapperType() {
            return 2;
        }
        bv() {
            let a = +(this.bu.todayOverride) != +(dateMinValue()) ? this.bu.todayOverride : dateGetDate(dateNow());
            a = dateAddDays(a, -1);
            let b = FilterFactory.instance.literal(dateGetMonth(a));
            let c = FilterFactory.instance.literal(a.getDate());
            let d = FilterFactory.instance.literal(a.getFullYear());
            return this.expression.month().isEqualTo(b).and(this.expression.day().isEqualTo(c)).and(this.expression.year().isEqualTo(d));
        }
    }
    YesterdayExpression.$t = /*@__PURE__*/ markType(YesterdayExpression, 'YesterdayExpression', WrapperExpression.$);
    return YesterdayExpression;
})();
/**
 * @hidden
 */
export let OffsettableWeekExpression = /*@__PURE__*/ (() => {
    class OffsettableWeekExpression extends WrapperExpression {
        constructor(a, ..._rest) {
            a = (a == void 0) ? 0 : a;
            switch (a) {
                case 0:
                    {
                        let c = _rest[0];
                        super(0, c);
                        this.bz = 0;
                    }
                    break;
                case 1:
                    {
                        let c = _rest[0];
                        super(1, c);
                        this.bz = 0;
                    }
                    break;
            }
        }
        bv() {
            let a = +(this.bu.todayOverride) != +(dateMinValue()) ? this.bu.todayOverride : dateGetDate(dateNow());
            a = dateAddDays(a, this.bz);
            let b = dateAddDays(a, 0 - a.getDay());
            let c = dateAddDays(a, 6 - a.getDay());
            let d = false;
            let e = dateMinValue();
            let f = dateMinValue();
            let g = dateMinValue();
            let h = dateMinValue();
            for (let i = 0; i < 7; i++) {
                let j = dateAddDays(c, -i);
                if (j.getDate() == 1) {
                    if (i == 6) {
                        break;
                    }
                    d = true;
                    f = dateAddDays(j, -1);
                    e = dateAddDays(f, -(6 - i - 1));
                    g = j;
                    h = dateAddDays(j, i);
                    break;
                }
            }
            if (d) {
                let k = this.expression.year().isEqualTo(this.bu.literal(e.getFullYear())).and(this.expression.month().isEqualTo(this.bu.literal(dateGetMonth(e))));
                let l = null;
                if (f.getDate() - e.getDate() > 0) {
                    l = this.expression.day().isGreaterThanOrEqualTo(this.bu.literal(e.getDate())).and(this.expression.day().isLessThanOrEqualTo(this.bu.literal(f.getDate())));
                }
                else {
                    l = this.expression.day().isEqualTo(this.bu.literal(e.getDate()));
                }
                let m = k.and(l);
                let n = this.expression.year().isEqualTo(this.bu.literal(g.getFullYear())).and(this.expression.month().isEqualTo(this.bu.literal(dateGetMonth(g))));
                let o = null;
                if (h.getDate() - g.getDate() > 0) {
                    o = this.expression.day().isGreaterThanOrEqualTo(this.bu.literal(g.getDate())).and(this.expression.day().isLessThanOrEqualTo(this.bu.literal(h.getDate())));
                }
                else {
                    o = this.expression.day().isEqualTo(this.bu.literal(g.getDate()));
                }
                let p = n.and(o);
                return m.or(p);
            }
            let q = FilterFactory.instance.literal(dateGetMonth(a));
            let r = FilterFactory.instance.literal(a.getFullYear());
            let s = FilterFactory.instance.literal(b.getDate());
            let t = FilterFactory.instance.literal(c.getDate());
            return this.expression.year().isEqualTo(r).and(this.expression.month().isEqualTo(q)).and(this.expression.day().isGreaterThanOrEqualTo(s)).and(this.expression.day().isLessThanOrEqualTo(t));
        }
    }
    OffsettableWeekExpression.$t = /*@__PURE__*/ markType(OffsettableWeekExpression, 'OffsettableWeekExpression', WrapperExpression.$);
    return OffsettableWeekExpression;
})();
/**
 * @hidden
 */
export let ThisWeekExpression = /*@__PURE__*/ (() => {
    class ThisWeekExpression extends OffsettableWeekExpression {
        constructor(a, ..._rest) {
            a = (a == void 0) ? 0 : a;
            switch (a) {
                case 0:
                    {
                        let c = _rest[0];
                        super(0, c);
                    }
                    break;
                case 1:
                    {
                        let c = _rest[0];
                        super(1, c);
                    }
                    break;
            }
        }
        getWrapperType() {
            return 3;
        }
    }
    ThisWeekExpression.$t = /*@__PURE__*/ markType(ThisWeekExpression, 'ThisWeekExpression', OffsettableWeekExpression.$);
    return ThisWeekExpression;
})();
/**
 * @hidden
 */
export let NextWeekExpression = /*@__PURE__*/ (() => {
    class NextWeekExpression extends OffsettableWeekExpression {
        constructor(a, ..._rest) {
            a = (a == void 0) ? 0 : a;
            switch (a) {
                case 0:
                    {
                        let c = _rest[0];
                        super(0, c);
                        this.bz = 7;
                    }
                    break;
                case 1:
                    {
                        let c = _rest[0];
                        super(1, c);
                        this.bz = 7;
                    }
                    break;
            }
        }
        getWrapperType() {
            return 4;
        }
    }
    NextWeekExpression.$t = /*@__PURE__*/ markType(NextWeekExpression, 'NextWeekExpression', OffsettableWeekExpression.$);
    return NextWeekExpression;
})();
/**
 * @hidden
 */
export let LastWeekExpression = /*@__PURE__*/ (() => {
    class LastWeekExpression extends OffsettableWeekExpression {
        constructor(a, ..._rest) {
            a = (a == void 0) ? 0 : a;
            switch (a) {
                case 0:
                    {
                        let c = _rest[0];
                        super(0, c);
                        this.bz = -7;
                    }
                    break;
                case 1:
                    {
                        let c = _rest[0];
                        super(1, c);
                        this.bz = -7;
                    }
                    break;
            }
        }
        getWrapperType() {
            return 5;
        }
    }
    LastWeekExpression.$t = /*@__PURE__*/ markType(LastWeekExpression, 'LastWeekExpression', OffsettableWeekExpression.$);
    return LastWeekExpression;
})();
/**
 * @hidden
 */
export let ThisMonthExpression = /*@__PURE__*/ (() => {
    class ThisMonthExpression extends WrapperExpression {
        constructor(a, ..._rest) {
            a = (a == void 0) ? 0 : a;
            switch (a) {
                case 0:
                    {
                        let c = _rest[0];
                        super(0, c);
                    }
                    break;
                case 1:
                    {
                        let c = _rest[0];
                        super(1, c);
                    }
                    break;
            }
        }
        getWrapperType() {
            return 6;
        }
        bv() {
            let a = +(this.bu.todayOverride) != +(dateMinValue()) ? this.bu.todayOverride : dateGetDate(dateNow());
            return this.expression.year().isEqualTo(this.bu.literal(a.getFullYear())).and(this.expression.month().isEqualTo(this.bu.literal(dateGetMonth(a))));
        }
    }
    ThisMonthExpression.$t = /*@__PURE__*/ markType(ThisMonthExpression, 'ThisMonthExpression', WrapperExpression.$);
    return ThisMonthExpression;
})();
/**
 * @hidden
 */
export let NextMonthExpression = /*@__PURE__*/ (() => {
    class NextMonthExpression extends WrapperExpression {
        constructor(a, ..._rest) {
            a = (a == void 0) ? 0 : a;
            switch (a) {
                case 0:
                    {
                        let c = _rest[0];
                        super(0, c);
                    }
                    break;
                case 1:
                    {
                        let c = _rest[0];
                        super(1, c);
                    }
                    break;
            }
        }
        getWrapperType() {
            return 7;
        }
        bv() {
            let a = +(this.bu.todayOverride) != +(dateMinValue()) ? this.bu.todayOverride : dateGetDate(dateNow());
            a = dateAddMonths(a, 1);
            return this.expression.year().isEqualTo(this.bu.literal(a.getFullYear())).and(this.expression.month().isEqualTo(this.bu.literal(dateGetMonth(a))));
        }
    }
    NextMonthExpression.$t = /*@__PURE__*/ markType(NextMonthExpression, 'NextMonthExpression', WrapperExpression.$);
    return NextMonthExpression;
})();
/**
 * @hidden
 */
export let LastMonthExpression = /*@__PURE__*/ (() => {
    class LastMonthExpression extends WrapperExpression {
        constructor(a, ..._rest) {
            a = (a == void 0) ? 0 : a;
            switch (a) {
                case 0:
                    {
                        let c = _rest[0];
                        super(0, c);
                    }
                    break;
                case 1:
                    {
                        let c = _rest[0];
                        super(1, c);
                    }
                    break;
            }
        }
        getWrapperType() {
            return 8;
        }
        bv() {
            let a = +(this.bu.todayOverride) != +(dateMinValue()) ? this.bu.todayOverride : dateGetDate(dateNow());
            a = dateAddMonths(a, -1);
            return this.expression.year().isEqualTo(this.bu.literal(a.getFullYear())).and(this.expression.month().isEqualTo(this.bu.literal(dateGetMonth(a))));
        }
    }
    LastMonthExpression.$t = /*@__PURE__*/ markType(LastMonthExpression, 'LastMonthExpression', WrapperExpression.$);
    return LastMonthExpression;
})();
/**
 * @hidden
 */
export let ThisYearExpression = /*@__PURE__*/ (() => {
    class ThisYearExpression extends WrapperExpression {
        constructor(a, ..._rest) {
            a = (a == void 0) ? 0 : a;
            switch (a) {
                case 0:
                    {
                        let c = _rest[0];
                        super(0, c);
                    }
                    break;
                case 1:
                    {
                        let c = _rest[0];
                        super(1, c);
                    }
                    break;
            }
        }
        getWrapperType() {
            return 9;
        }
        bv() {
            let a = +(this.bu.todayOverride) != +(dateMinValue()) ? this.bu.todayOverride : dateGetDate(dateNow());
            return this.expression.year().isEqualTo(this.bu.literal(a.getFullYear()));
        }
    }
    ThisYearExpression.$t = /*@__PURE__*/ markType(ThisYearExpression, 'ThisYearExpression', WrapperExpression.$);
    return ThisYearExpression;
})();
/**
 * @hidden
 */
export let NextYearExpression = /*@__PURE__*/ (() => {
    class NextYearExpression extends WrapperExpression {
        constructor(a, ..._rest) {
            a = (a == void 0) ? 0 : a;
            switch (a) {
                case 0:
                    {
                        let c = _rest[0];
                        super(0, c);
                    }
                    break;
                case 1:
                    {
                        let c = _rest[0];
                        super(1, c);
                    }
                    break;
            }
        }
        getWrapperType() {
            return 10;
        }
        bv() {
            let a = +(this.bu.todayOverride) != +(dateMinValue()) ? this.bu.todayOverride : dateGetDate(dateNow());
            a = dateAddYears(a, 1);
            return this.expression.year().isEqualTo(this.bu.literal(a.getFullYear()));
        }
    }
    NextYearExpression.$t = /*@__PURE__*/ markType(NextYearExpression, 'NextYearExpression', WrapperExpression.$);
    return NextYearExpression;
})();
/**
 * @hidden
 */
export let LastYearExpression = /*@__PURE__*/ (() => {
    class LastYearExpression extends WrapperExpression {
        constructor(a, ..._rest) {
            a = (a == void 0) ? 0 : a;
            switch (a) {
                case 0:
                    {
                        let c = _rest[0];
                        super(0, c);
                    }
                    break;
                case 1:
                    {
                        let c = _rest[0];
                        super(1, c);
                    }
                    break;
            }
        }
        getWrapperType() {
            return 11;
        }
        bv() {
            let a = +(this.bu.todayOverride) != +(dateMinValue()) ? this.bu.todayOverride : dateGetDate(dateNow());
            a = dateAddYears(a, -1);
            return this.expression.year().isEqualTo(this.bu.literal(a.getFullYear()));
        }
    }
    LastYearExpression.$t = /*@__PURE__*/ markType(LastYearExpression, 'LastYearExpression', WrapperExpression.$);
    return LastYearExpression;
})();
/**
 * @hidden
 */
export let YearToDateExpression = /*@__PURE__*/ (() => {
    class YearToDateExpression extends WrapperExpression {
        constructor(a, ..._rest) {
            a = (a == void 0) ? 0 : a;
            switch (a) {
                case 0:
                    {
                        let c = _rest[0];
                        super(0, c);
                    }
                    break;
                case 1:
                    {
                        let c = _rest[0];
                        super(1, c);
                    }
                    break;
            }
        }
        getWrapperType() {
            return 15;
        }
        bv() {
            let a = +(this.bu.todayOverride) != +(dateMinValue()) ? this.bu.todayOverride : dateGetDate(dateNow());
            return this.expression.year().isEqualTo(this.bu.literal(a.getFullYear())).and(this.expression.month().isEqualTo(this.bu.literal(dateGetMonth(a))).and(this.expression.day().isLessThanOrEqualTo(this.bu.literal(a.getDate()))).or(this.expression.month().isLessThan(this.bu.literal(dateGetMonth(a)))));
        }
    }
    YearToDateExpression.$t = /*@__PURE__*/ markType(YearToDateExpression, 'YearToDateExpression', WrapperExpression.$);
    return YearToDateExpression;
})();
/**
 * @hidden
 */
export let ThisQuarterExpression = /*@__PURE__*/ (() => {
    class ThisQuarterExpression extends WrapperExpression {
        constructor(a, ..._rest) {
            a = (a == void 0) ? 0 : a;
            switch (a) {
                case 0:
                    {
                        let c = _rest[0];
                        super(0, c);
                    }
                    break;
                case 1:
                    {
                        let c = _rest[0];
                        super(1, c);
                    }
                    break;
            }
        }
        getWrapperType() {
            return 12;
        }
        bv() {
            let a = +(this.bu.todayOverride) != +(dateMinValue()) ? this.bu.todayOverride : dateGetDate(dateNow());
            let b = this.expression.year().isEqualTo(this.bu.literal(a.getFullYear()));
            if (dateGetMonth(a) == 1 || dateGetMonth(a) == 2 || dateGetMonth(a) == 3) {
                return b.and(this.expression.isQ1());
            }
            else if (dateGetMonth(a) == 4 || dateGetMonth(a) == 5 || dateGetMonth(a) == 6) {
                return b.and(this.expression.isQ2());
            }
            else if (dateGetMonth(a) == 7 || dateGetMonth(a) == 8 || dateGetMonth(a) == 9) {
                return b.and(this.expression.isQ3());
            }
            else {
                return b.and(this.expression.isQ4());
            }
        }
    }
    ThisQuarterExpression.$t = /*@__PURE__*/ markType(ThisQuarterExpression, 'ThisQuarterExpression', WrapperExpression.$);
    return ThisQuarterExpression;
})();
/**
 * @hidden
 */
export let NextQuarterExpression = /*@__PURE__*/ (() => {
    class NextQuarterExpression extends WrapperExpression {
        constructor(a, ..._rest) {
            a = (a == void 0) ? 0 : a;
            switch (a) {
                case 0:
                    {
                        let c = _rest[0];
                        super(0, c);
                    }
                    break;
                case 1:
                    {
                        let c = _rest[0];
                        super(1, c);
                    }
                    break;
            }
        }
        getWrapperType() {
            return 13;
        }
        bv() {
            let a = +(this.bu.todayOverride) != +(dateMinValue()) ? this.bu.todayOverride : dateGetDate(dateNow());
            let b = this.expression.year().isEqualTo(this.bu.literal(a.getFullYear()));
            if (dateGetMonth(a) == 1 || dateGetMonth(a) == 2 || dateGetMonth(a) == 3) {
                return b.and(this.expression.isQ2());
            }
            else if (dateGetMonth(a) == 4 || dateGetMonth(a) == 5 || dateGetMonth(a) == 6) {
                return b.and(this.expression.isQ3());
            }
            else if (dateGetMonth(a) == 7 || dateGetMonth(a) == 8 || dateGetMonth(a) == 9) {
                return b.and(this.expression.isQ4());
            }
            else {
                return this.expression.year().isEqualTo(this.bu.literal(a.getFullYear() + 1)).and(this.expression.isQ1());
            }
        }
    }
    NextQuarterExpression.$t = /*@__PURE__*/ markType(NextQuarterExpression, 'NextQuarterExpression', WrapperExpression.$);
    return NextQuarterExpression;
})();
/**
 * @hidden
 */
export let LastQuarterExpression = /*@__PURE__*/ (() => {
    class LastQuarterExpression extends WrapperExpression {
        constructor(a, ..._rest) {
            a = (a == void 0) ? 0 : a;
            switch (a) {
                case 0:
                    {
                        let c = _rest[0];
                        super(0, c);
                    }
                    break;
                case 1:
                    {
                        let c = _rest[0];
                        super(1, c);
                    }
                    break;
            }
        }
        getWrapperType() {
            return 13;
        }
        bv() {
            let a = +(this.bu.todayOverride) != +(dateMinValue()) ? this.bu.todayOverride : dateGetDate(dateNow());
            let b = this.expression.year().isEqualTo(this.bu.literal(a.getFullYear()));
            if (dateGetMonth(a) == 1 || dateGetMonth(a) == 2 || dateGetMonth(a) == 3) {
                return this.expression.year().isEqualTo(this.bu.literal(a.getFullYear() - 1)).and(this.expression.isQ4());
            }
            else if (dateGetMonth(a) == 4 || dateGetMonth(a) == 5 || dateGetMonth(a) == 6) {
                return b.and(this.expression.isQ1());
            }
            else if (dateGetMonth(a) == 7 || dateGetMonth(a) == 8 || dateGetMonth(a) == 9) {
                return b.and(this.expression.isQ2());
            }
            else {
                return b.and(this.expression.isQ3());
            }
        }
    }
    LastQuarterExpression.$t = /*@__PURE__*/ markType(LastQuarterExpression, 'LastQuarterExpression', WrapperExpression.$);
    return LastQuarterExpression;
})();
/**
 * @hidden
 */
export let Q1Expression = /*@__PURE__*/ (() => {
    class Q1Expression extends WrapperExpression {
        constructor(a, ..._rest) {
            a = (a == void 0) ? 0 : a;
            switch (a) {
                case 0:
                    {
                        let c = _rest[0];
                        super(0, c);
                    }
                    break;
                case 1:
                    {
                        let c = _rest[0];
                        super(1, c);
                    }
                    break;
            }
        }
        getWrapperType() {
            return 16;
        }
        bv() {
            return this.expression.month().isEqualTo(this.bu.literal(1)).or(this.expression.month().isEqualTo(this.bu.literal(2))).or(this.expression.month().isEqualTo(this.bu.literal(3)));
        }
    }
    Q1Expression.$t = /*@__PURE__*/ markType(Q1Expression, 'Q1Expression', WrapperExpression.$);
    return Q1Expression;
})();
/**
 * @hidden
 */
export let Q2Expression = /*@__PURE__*/ (() => {
    class Q2Expression extends WrapperExpression {
        constructor(a, ..._rest) {
            a = (a == void 0) ? 0 : a;
            switch (a) {
                case 0:
                    {
                        let c = _rest[0];
                        super(0, c);
                    }
                    break;
                case 1:
                    {
                        let c = _rest[0];
                        super(1, c);
                    }
                    break;
            }
        }
        getWrapperType() {
            return 17;
        }
        bv() {
            return this.expression.month().isEqualTo(this.bu.literal(4)).or(this.expression.month().isEqualTo(this.bu.literal(5))).or(this.expression.month().isEqualTo(this.bu.literal(6)));
        }
    }
    Q2Expression.$t = /*@__PURE__*/ markType(Q2Expression, 'Q2Expression', WrapperExpression.$);
    return Q2Expression;
})();
/**
 * @hidden
 */
export let Q3Expression = /*@__PURE__*/ (() => {
    class Q3Expression extends WrapperExpression {
        constructor(a, ..._rest) {
            a = (a == void 0) ? 0 : a;
            switch (a) {
                case 0:
                    {
                        let c = _rest[0];
                        super(0, c);
                    }
                    break;
                case 1:
                    {
                        let c = _rest[0];
                        super(1, c);
                    }
                    break;
            }
        }
        getWrapperType() {
            return 18;
        }
        bv() {
            return this.expression.month().isEqualTo(this.bu.literal(7)).or(this.expression.month().isEqualTo(this.bu.literal(8))).or(this.expression.month().isEqualTo(this.bu.literal(9)));
        }
    }
    Q3Expression.$t = /*@__PURE__*/ markType(Q3Expression, 'Q3Expression', WrapperExpression.$);
    return Q3Expression;
})();
/**
 * @hidden
 */
export let Q4Expression = /*@__PURE__*/ (() => {
    class Q4Expression extends WrapperExpression {
        constructor(a, ..._rest) {
            a = (a == void 0) ? 0 : a;
            switch (a) {
                case 0:
                    {
                        let c = _rest[0];
                        super(0, c);
                    }
                    break;
                case 1:
                    {
                        let c = _rest[0];
                        super(1, c);
                    }
                    break;
            }
        }
        getWrapperType() {
            return 19;
        }
        bv() {
            return this.expression.month().isEqualTo(this.bu.literal(10)).or(this.expression.month().isEqualTo(this.bu.literal(11))).or(this.expression.month().isEqualTo(this.bu.literal(12)));
        }
    }
    Q4Expression.$t = /*@__PURE__*/ markType(Q4Expression, 'Q4Expression', WrapperExpression.$);
    return Q4Expression;
})();
