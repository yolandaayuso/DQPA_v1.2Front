/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { Base, markType, Point_$type } from "./type";
import { PathFigureCollection } from "./PathFigureCollection";
import { List$1 } from "./List$1";
import { PathMarkupToken } from "./PathMarkupToken";
import { PathFigure } from "./PathFigure";
import { LineSegment } from "./LineSegment";
import { BezierSegment } from "./BezierSegment";
import { ArcSegment } from "./ArcSegment";
import { Size } from "./Size";
import { InvalidOperationException } from "./InvalidOperationException";
import { stringEmpty } from "./string";
/**
 * @hidden
 */
export let Geometry = /*@__PURE__*/ (() => {
    class Geometry extends Base {
        constructor() {
            super();
        }
        static a(a) {
            if (a != null) {
                let b = new PathMarkupParser();
                return b.k(a);
            }
            return null;
        }
    }
    Geometry.$t = /*@__PURE__*/ markType(Geometry, 'Geometry');
    return Geometry;
})();
/**
 * @hidden
 */
export let PathGeometry = /*@__PURE__*/ (() => {
    class PathGeometry extends Geometry {
        constructor() {
            super();
            this.c = null;
            this.c = new PathFigureCollection();
        }
        get_b() {
            return 4;
        }
        get b() {
            return this.get_b();
        }
    }
    PathGeometry.$t = /*@__PURE__*/ markType(PathGeometry, 'PathGeometry', Geometry.$);
    return PathGeometry;
})();
/**
 * @hidden
 */
export let PathMarkupParser = /*@__PURE__*/ (() => {
    class PathMarkupParser extends Base {
        constructor() {
            super(...arguments);
            this.e = '\0';
            this.h = 0;
            this.l = { $type: Point_$type, x: 0, y: 0 };
            this.f = null;
            this.i = null;
        }
        k(a) {
            this.f = new List$1(PathMarkupToken.$, 0);
            this.h = 0;
            while (this.d(a)) {
                switch (this.e) {
                    case 'M':
                    case 'm':
                        this.f.add(new PathMarkupToken(0, this.e.charCodeAt(0) < 'm'.charCodeAt(0)));
                        break;
                    case 'L':
                    case 'l':
                        this.f.add(new PathMarkupToken(1, this.e.charCodeAt(0) < 'l'.charCodeAt(0)));
                        break;
                    case 'H':
                    case 'h':
                        this.f.add(new PathMarkupToken(2, this.e.charCodeAt(0) < 'h'.charCodeAt(0)));
                        break;
                    case 'V':
                    case 'v':
                        this.f.add(new PathMarkupToken(3, this.e.charCodeAt(0) < 'v'.charCodeAt(0)));
                        break;
                    case 'C':
                    case 'c':
                        this.f.add(new PathMarkupToken(4, this.e.charCodeAt(0) < 'c'.charCodeAt(0)));
                        break;
                    case 'Q':
                    case 'q':
                        this.f.add(new PathMarkupToken(5, this.e.charCodeAt(0) < 'q'.charCodeAt(0)));
                        break;
                    case 'S':
                    case 's':
                        this.f.add(new PathMarkupToken(6, this.e.charCodeAt(0) < 's'.charCodeAt(0)));
                        break;
                    case 'T':
                    case 't':
                        this.f.add(new PathMarkupToken(7, this.e.charCodeAt(0) < 't'.charCodeAt(0)));
                        break;
                    case 'A':
                    case 'a':
                        this.f.add(new PathMarkupToken(8, this.e.charCodeAt(0) < 'a'.charCodeAt(0)));
                        break;
                    case 'Z':
                    case 'z':
                        this.f.add(new PathMarkupToken(9, this.e.charCodeAt(0) < 'z'.charCodeAt(0)));
                        break;
                }
                if (this.a(this.e)) {
                    let b = true;
                    let c = false;
                    let d = false;
                    let e = stringEmpty();
                    let f = false;
                    this.h = this.h - 1;
                    while (this.h < a.length) {
                        let g = a.charAt(this.h);
                        if (d) {
                            if (!this.a(g)) {
                                f = true;
                                break;
                            }
                            else {
                                e += g;
                                this.h++;
                                if (this.h >= a.length) {
                                    f = true;
                                    break;
                                }
                            }
                        }
                        else if (c) {
                            if (g == 'e' || g == 'E') {
                                d = true;
                                e += g;
                                this.h++;
                                continue;
                            }
                            if ((g == '-' || g == '+') && e.length > 0) {
                                f = true;
                                break;
                            }
                            if (!this.a(g)) {
                                f = true;
                                break;
                            }
                            else {
                                e += g;
                                this.h++;
                                if (this.h >= a.length) {
                                    f = true;
                                    break;
                                }
                            }
                        }
                        else if (b) {
                            if (g == '.') {
                                c = true;
                                e += g;
                                this.h++;
                                continue;
                            }
                            if (g == 'e' || g == 'E') {
                                d = true;
                                e += g;
                                this.h++;
                                continue;
                            }
                            if ((g == '-' || g == '+') && e.length > 0) {
                                f = true;
                                break;
                            }
                            if (!this.a(g)) {
                                f = true;
                                break;
                            }
                            else {
                                e += g;
                                this.h++;
                                if (this.h >= a.length) {
                                    f = true;
                                    break;
                                }
                            }
                        }
                    }
                    if (f) {
                        this.f.add(((() => {
                            let $ret = new PathMarkupToken(10, false);
                            $ret.b = parseFloat(e);
                            return $ret;
                        })()));
                    }
                }
            }
            return this.j();
        }
        a(a) {
            return a == '.' || a == '-' || a == '+' || (a.charCodeAt(0) >= '0'.charCodeAt(0) && a.charCodeAt(0) <= '9'.charCodeAt(0));
        }
        j() {
            this.h = 0;
            let a = true;
            let b = new PathGeometry();
            let c = null;
            let d = 11;
            let e = null;
            let f = null;
            let g = null;
            while (this.h < this.f.count) {
                let h = this.f._inner[this.h++];
                if (a && h.c != 0) {
                    return null;
                }
                switch (h.c) {
                    case 0:
                        c = new PathFigure();
                        b.c.add(c);
                        this.l = this.m(h.a);
                        c._startPoint = this.l;
                        while (this.b()) {
                            this.l = this.m(h.a);
                            c._segments.add(new LineSegment(0, this.l));
                        }
                        d = 0;
                        break;
                    case 1:
                    case 2:
                    case 3:
                        if (c == null) {
                            return null;
                        }
                        do {
                            switch (h.c) {
                                case 1:
                                    this.l = this.m(h.a);
                                    break;
                                case 2:
                                    this.l.x = h.a ? this.g() : this.l.x + this.g();
                                    break;
                                case 3:
                                    this.l.y = h.a ? this.g() : this.l.y + this.g();
                                    break;
                            }
                            c._segments.add(new LineSegment(0, this.l));
                        } while (this.b());
                        d = 1;
                        break;
                    case 4:
                    case 6:
                        if (c == null) {
                            return null;
                        }
                        do {
                            if (h.c == 6) {
                                if (d == 4) {
                                    e = { $type: Point_$type, x: 2 * this.l.x - f.x, y: 2 * this.l.y - f.y };
                                }
                                else {
                                    e = this.l;
                                }
                            }
                            else {
                                e = this.m(h.a);
                            }
                            f = this.m(h.a);
                            g = this.m(h.a);
                            c._segments.add(new BezierSegment(1, e, f, g));
                            this.l = g;
                            d = 4;
                        } while (this.b());
                        break;
                    case 5:
                    case 7: break;
                    case 8:
                        if (c == null) {
                            return null;
                        }
                        do {
                            let i = this.g();
                            let j = this.g();
                            let k = this.g();
                            let l = this.g();
                            let m = this.g();
                            this.l = this.m(h.a);
                            c._segments.add(((() => {
                                let $ret = new ArcSegment();
                                $ret.e = this.l;
                                $ret.f = new Size(1, i, j);
                                $ret.c = k;
                                $ret.b = l == 1;
                                $ret.d = m == 1 ? 1 : 0;
                                return $ret;
                            })()));
                        } while (this.b());
                        d = 8;
                        break;
                    case 9:
                        if (c == null) {
                            return null;
                        }
                        c._isClosed = true;
                        break;
                }
                a = false;
            }
            return b;
        }
        m(a) {
            let b = this.g();
            let c = this.g();
            if (!a) {
                b += this.l.x;
                c += this.l.y;
            }
            return { $type: Point_$type, x: b, y: c };
        }
        g() {
            let a = this.f._inner[this.h++];
            if (a.c != 10) {
                throw new InvalidOperationException(0);
            }
            return a.b;
        }
        b() {
            if (this.h >= this.f.count) {
                return false;
            }
            return this.f._inner[this.h].c == 10;
        }
        d(a) {
            while (this.h < a.length && this.c(a.charAt(this.h))) {
                this.h++;
            }
            if (this.h < a.length) {
                this.e = a.charAt(this.h);
                this.h++;
                return true;
            }
            return false;
        }
        c(a) {
            return a == '\r' || a == '\n' || a == ' ' || a == '\t';
        }
    }
    PathMarkupParser.$t = /*@__PURE__*/ markType(PathMarkupParser, 'PathMarkupParser');
    return PathMarkupParser;
})();
