/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { DependencyObjectNotifier } from "./DependencyObjectNotifier";
import { IList$1_$type, BaseError, delegateCombine, Point_$type, fromEnum, markType, markDep } from "./type";
import { ShapefileRecord } from "./ShapefileRecord";
import { INotifyCollectionChanged_$type } from "./INotifyCollectionChanged";
import { Rect } from "./Rect";
import { DependencyProperty } from "./DependencyProperty";
import { ObservableCollection$1 } from "./ObservableCollection$1";
import { List$1 } from "./List$1";
import { AsyncCompletedEventArgs } from "./AsyncCompletedEventArgs";
import { BinaryReader } from "./BinaryReader";
import { BinaryFileDownloader } from "./BinaryFileDownloader";
import { ShapeFilterRecordEventArgs } from "./ShapeFilterRecordEventArgs";
import { ShapeFileUtil } from "./ShapeFileUtil";
import { PropertyMetadata } from "./PropertyMetadata";
import { isNaN_, isInfinity } from "./number";
/**
 * @hidden
 */
export let ShapefileConverter = /*@__PURE__*/ (() => {
    class ShapefileConverter extends DependencyObjectNotifier {
        get name() {
            return this._name;
        }
        set name(a) {
            this._name = a;
        }
        constructor() {
            super();
            this._name = null;
            this.a8 = null;
            this.a7 = Rect.empty;
            this._shapeHeader = null;
            this.q = false;
            this.importPending = null;
            this.importCompleted = null;
            this.x = null;
            this.collectionChanged = null;
            this.filter = null;
            this.records = new ObservableCollection$1(ShapefileRecord.$, 0);
            let a = this.records;
            a.collectionChanged = delegateCombine(a.collectionChanged, (a, b) => {
                if (this.collectionChanged != null) {
                    this.collectionChanged(this, b);
                }
            });
        }
        get worldRect() {
            return this.a8;
        }
        set worldRect(a) {
            if (Rect.l_op_Inequality(this.a8, a)) {
                let b = this.a8;
                this.a8 = a;
                this.aw("WorldRect", b, this.a8);
            }
        }
        get computedWorldRect() {
            return this.a7;
        }
        set computedWorldRect(a) {
            if (Rect.l_op_Inequality(this.a7, a)) {
                let b = this.a7;
                this.a7 = a;
                this.aw("ComputedWorldRect", b, this.a7);
            }
        }
        getWorldBounds(a) {
            if (a && this.computedWorldRect.isEmpty == false) {
                return this.computedWorldRect;
            }
            return this.worldRect;
        }
        setWorldBounds(a, b) {
            if (a) {
                this.computedWorldRect = b;
            }
            else {
                this.worldRect = b;
            }
        }
        get shapeType() {
            return this.shapeHeader.a;
        }
        get shapeHeader() {
            return this._shapeHeader;
        }
        set shapeHeader(a) {
            this._shapeHeader = a;
        }
        aw(a, b, c) {
            switch (a) {
                case ShapefileConverter.$$p[2]:
                case ShapefileConverter.$$p[0]:
                    if (this.shapefileSource != null && this.databaseSource != null) {
                        this.at();
                    }
                    break;
            }
            this.j(a);
        }
        sendImportCompleted() {
            if (this.deferImportCompleted && this.q) {
                this.deferImportCompleted = false;
                if (this.importCompleted != null) {
                    this.importCompleted(this, new AsyncCompletedEventArgs(null, false, null));
                }
            }
        }
        au(a) {
            this.q = true;
            if (this.deferImportCompleted) {
                if (this.importPending != null) {
                    this.importPending(this, a);
                }
                return;
            }
            if (this.importCompleted != null) {
                this.importCompleted(this, a);
            }
        }
        at() {
            this.q = false;
            let a = null;
            let b = null;
            let c = () => {
                if (a != null && b != null) {
                    this.av(a, b);
                    this.au(new AsyncCompletedEventArgs(null, false, null));
                }
            };
            BinaryFileDownloader.a(this.shapefileSource, (d) => {
                a = new BinaryReader(0, d, false);
                c();
            }, (d) => {
                throw new BaseError(1, "shape file download error: " + d);
            });
            BinaryFileDownloader.a(this.databaseSource, (d) => {
                b = new BinaryReader(0, d, false);
                c();
            }, (d) => {
                throw new BaseError(1, "dbf file download error: " + d);
            });
        }
        av(a, b) {
            this.shapeHeader = ShapeFileUtil.a(a, b);
            this.worldRect = this.shapeHeader.e;
            let c = a.currentPosition;
            let d = a.length;
            let e = Rect.empty;
            while (c < d) {
                let f = ShapeFileUtil.f(this.shapeHeader, a, b);
                let record_ = f;
                let g = true;
                if (this.filter != null) {
                    let h = new ShapeFilterRecordEventArgs();
                    h.b = true;
                    h.a = f;
                    this.filter(this, h);
                    if (!h.b) {
                        g = false;
                    }
                }
                if (g) {
                    this.records.add(f);
                    if (e.isEmpty) {
                        e = f.bounds;
                    }
                    else {
                        e.union(f.bounds);
                    }
                }
                c = a.currentPosition;
                d = a.length;
            }
            this.computedWorldRect = e.isEmpty ? this.worldRect : e;
        }
        get records() {
            return this.x;
        }
        set records(a) {
            this.x = a;
        }
        indexOf(a) {
            return this.x.indexOf(a);
        }
        insert(a, b) {
            this.x.insert(a, b);
        }
        removeAt(a) {
            this.x.removeAt(a);
        }
        item(a, b) {
            if (arguments.length === 2) {
                this.x.item(a, b);
                return b;
            }
            else {
                return this.x._inner[a];
            }
        }
        add(a) {
            this.x.add(a);
        }
        clear() {
            this.x.clear();
        }
        contains(a) {
            return this.x.contains(a);
        }
        copyTo(a, b) {
            this.x.copyTo(a, b);
        }
        get count() {
            return this.x.count;
        }
        get isReadOnly() {
            return this.x.isReadOnly;
        }
        remove(a) {
            return this.x.remove(a);
        }
        getEnumerator() {
            return this.x.getEnumerator();
        }
        getEnumeratorObject() {
            return this.getEnumerator();
        }
        getPointData() {
            return new List$1(ShapefileRecord.$, 1, this.records);
        }
        getRecordsCount() {
            if (this.records == null) {
                return 0;
            }
            return this.records.count;
        }
        getRecord(a) {
            return this.records._inner[a];
        }
        getRecordBounds(a) {
            if (this.records == null) {
                return Rect.empty;
            }
            if (a < 0 || a > this.records.count - 1) {
                return Rect.empty;
            }
            return this.records._inner[a].bounds;
        }
        getRecordFieldNames(a) {
            if (this.records == null) {
                return null;
            }
            if (a < 0 || a > this.records.count - 1) {
                return null;
            }
            let b = this.records._inner[a];
            if (b == null || b.fieldsNames == null) {
                return null;
            }
            return b.fieldsNames.toArray();
        }
        getRecordValue(a, b) {
            if (this.records == null) {
                return null;
            }
            if (a < 0 || a > this.records.count - 1) {
                return null;
            }
            let c = this.records._inner[a];
            if (c == null || c.fieldsNames == null) {
                return null;
            }
            return c.getFieldValue(b);
        }
        removeRecord(a) {
            if (this.records == null) {
                return;
            }
            if (a < 0 || a > this.records.count - 1) {
                return;
            }
            this.records.removeAt(a);
        }
        shiftAllShapes(a, b) {
            if (this.records == null) {
                return;
            }
            for (let c = 0; c < this.records.count; c++) {
                this.shiftShapes(c, a, b);
            }
        }
        shiftShapes(a, b, c) {
            if (this.records == null) {
                return;
            }
            if (a < 0 || a > this.records.count - 1) {
                return;
            }
            let d = new List$1(List$1.$.specialize(Point_$type), 0);
            let e = this.records._inner[a].points;
            for (let f of fromEnum(e)) {
                let g = ShapefileConverter.w(f, b, c);
                for (let h of fromEnum(g)) {
                    d.add(h);
                }
            }
            this.records._inner[a].points = d;
        }
        static ai(a, b) {
            return ShapefileConverter.ag(a, b, -180, 180);
        }
        static ah(a, b) {
            return ShapefileConverter.ag(a, b, -85.05112878, 85.05112878);
        }
        static ag(a, b, c, d) {
            let e = a;
            if (isNaN_(b) || b == 0) {
                return e;
            }
            if (e + b < c) {
                e += 2 * d;
                e += b;
            }
            else if (e + b > d) {
                e -= 2 * d;
                e += b;
            }
            else {
                e += b;
            }
            return e;
        }
        static isValidGeoPoint(a) {
            if (a.x < -180 || a.x > 180) {
                return false;
            }
            if (a.y < -90 || a.y > 90) {
                return false;
            }
            return true;
        }
        static isValidGeoShape(a) {
            if (a.count < 3) {
                return false;
            }
            for (let b of fromEnum(a)) {
                if (!ShapefileConverter.isValidGeoPoint(b)) {
                    return false;
                }
            }
            return true;
        }
        static w(a, b, c, d = "") {
            let e = 1.7976931348623157E+308;
            let f = -1.7976931348623157E+308;
            let g = new List$1(Point_$type, 0);
            for (let h of fromEnum(a)) {
                let i = ShapefileConverter.ag(h.x, b, -180, 180);
                let j = ShapefileConverter.ag(h.y, c, -85.05112878, 85.05112878);
                e = Math.min(e, i);
                f = Math.max(f, i);
                g.add({ $type: Point_$type, x: i, y: j });
            }
            let k = new List$1(List$1.$.specialize(Point_$type), 0);
            let l = ShapefileConverter.ba(g);
            let m = l.width;
            if (l.left >= -180 && l.right <= 180 && l.width > 180) {
                let n = new List$1(Point_$type, 0);
                let o = new List$1(Point_$type, 0);
                for (let p of fromEnum(g)) {
                    if (p.x >= -180 && p.x < 0) {
                        n.add(p);
                    }
                    else {
                        o.add(p);
                    }
                }
                let q = ShapefileConverter.ba(n);
                let r = q.width;
                let s = ShapefileConverter.ba(o);
                let t = s.width;
                if (ShapefileConverter.isValidGeoShape(n)) {
                    k.add(n);
                }
                if (ShapefileConverter.isValidGeoShape(o)) {
                    k.add(o);
                }
            }
            else {
                if (ShapefileConverter.isValidGeoShape(g)) {
                    k.add(g);
                }
            }
            return k;
        }
        getMaxLongitude(a, b, c, d) {
            if (this.records == null) {
                return NaN;
            }
            if (a < 0 || a > this.records.count - 1) {
                return NaN;
            }
            let e = this.records._inner[a].points;
            let f = c;
            if (b) {
                let g = ShapefileConverter.v(e);
                for (let h of fromEnum(g)) {
                    if (h.x < d) {
                        f = Math.max(f, h.x);
                    }
                }
            }
            else {
                for (let i of fromEnum(e)) {
                    for (let j of fromEnum(i)) {
                        if (j.x < d) {
                            f = Math.max(f, j.x);
                        }
                    }
                }
            }
            return f;
        }
        setRecordValue(a, b, c) {
            if (this.records == null) {
                return;
            }
            if (a < 0 || a > this.records.count - 1) {
                return;
            }
            let d = this.records._inner[a];
            if (d == null || d.fieldsNames == null) {
                return;
            }
            d.setFieldValue(b, c);
        }
        getRecordValues(a) {
            if (this.records == null) {
                return null;
            }
            let b = new Array(this.records.count);
            for (let c = 0; c < this.records.count; c++) {
                let d = this.getRecordValue(c, a);
                b[c] = d;
            }
            return b;
        }
        setRecordValues(a, b) {
            if (this.records == null) {
                return;
            }
            let c = Math.min(b.length, this.records.count);
            for (let d = 0; d < c; d++) {
                this.setRecordValue(d, a, b[d]);
            }
        }
        static ba(a) {
            let b = Number.POSITIVE_INFINITY;
            let c = Number.POSITIVE_INFINITY;
            let d = Number.NEGATIVE_INFINITY;
            let e = Number.NEGATIVE_INFINITY;
            for (let f = 0; f < a.count; f++) {
                let g = a._inner[f];
                b = Math.min(b, g.x);
                c = Math.min(c, g.y);
                d = Math.max(d, g.x);
                e = Math.max(e, g.y);
            }
            if (isInfinity(b) || isInfinity(c) || isInfinity(c) || isInfinity(e)) {
                return Rect.empty;
            }
            return new Rect(0, b, c, d - b, e - c);
        }
        getLargestShapeBoundsForRecord(a) {
            if (this.records == null) {
                return Rect.empty;
            }
            if (a < 0 || a > this.records.count - 1) {
                return Rect.empty;
            }
            let b = this.records._inner[a];
            if (b == null || b.fieldsNames == null) {
                return Rect.empty;
            }
            let c = ShapefileConverter.v(b.points);
            return ShapefileConverter.ba(c);
        }
        static v(a) {
            let b = new List$1(Point_$type, 0);
            let c = -1.7976931348623157E+308;
            for (let d of fromEnum(a)) {
                let e = 1.7976931348623157E+308;
                let f = -1.7976931348623157E+308;
                let g = 1.7976931348623157E+308;
                let h = -1.7976931348623157E+308;
                for (let i of fromEnum(d)) {
                    g = Math.min(g, i.y);
                    h = Math.max(h, i.y);
                    e = Math.min(e, i.x);
                    f = Math.max(f, i.x);
                }
                let j = f - e;
                let k = h - g;
                let l = new Rect(0, e, g, j, k);
                let m = l.width * l.height;
                if (m > c) {
                    c = m;
                    b = d;
                }
            }
            return b;
        }
    }
    ShapefileConverter.$t = /*@__PURE__*/ markType(ShapefileConverter, 'ShapefileConverter', DependencyObjectNotifier.$, [/*@__PURE__*/ IList$1_$type.specialize(ShapefileRecord.$), INotifyCollectionChanged_$type]);
    ShapefileConverter.minLatitude = -85.05112878;
    ShapefileConverter.maxLatitude = 85.05112878;
    ShapefileConverter.minLongitude = -180;
    ShapefileConverter.maxLongitude = 180;
    ShapefileConverter.$$p = /*@__PURE__*/ markDep(DependencyProperty, PropertyMetadata, ShapefileConverter, 'aw', ['DatabaseSource', [2, null], 'DeferImportCompleted', [0, false], 'ShapefileSource', [2, null]]);
    return ShapefileConverter;
})();
