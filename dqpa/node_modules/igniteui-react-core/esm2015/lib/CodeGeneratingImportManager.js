/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { Base, String_$type, fromEnum, markType } from "./type";
import { Dictionary$2 } from "./Dictionary$2";
import { List$1 } from "./List$1";
import { HashSet$1 } from "./HashSet$1";
import { StringBuilder } from "./StringBuilder";
import { stringJoin1, stringStartsWith } from "./string";
/**
 * @hidden
 */
export let CodeGeneratingImportManager = /*@__PURE__*/ (() => {
    class CodeGeneratingImportManager extends Base {
        constructor() {
            super(...arguments);
            this._packageOverride = null;
            this._isImportsOnly = false;
            this.k = new List$1(String_$type, 0);
            this.i = new HashSet$1(String_$type, 0);
            this.j = new List$1(String_$type, 0);
            this.h = new HashSet$1(String_$type, 0);
            this.f = new Dictionary$2(String_$type, List$1.$.specialize(String_$type), 0);
            this.g = new Dictionary$2(String_$type, HashSet$1.$.specialize(String_$type), 0);
        }
        get packageOverride() {
            return this._packageOverride;
        }
        set packageOverride(a) {
            this._packageOverride = a;
        }
        get isImportsOnly() {
            return this._isImportsOnly;
        }
        set isImportsOnly(a) {
            this._isImportsOnly = a;
        }
        addUsing(a) {
            if (!this.i.contains(a)) {
                this.i.add_1(a);
                this.k.add(a);
            }
        }
        get hasPackageImports() {
            return this.f.count > 0;
        }
        packageImportsToString() {
            let a = new StringBuilder(0);
            for (let b = 0; b < this.j.count; b++) {
                let c = this.j._inner[b];
                let d = this.f.item(c);
                let e = stringJoin1(String_$type, ", ", d);
                if (this.isImportsOnly && b > 0) {
                    a.u(",");
                }
                if (this.isImportsOnly) {
                    a.l(e);
                }
                else {
                    if (this.h.contains(c)) {
                        if (e == "@SELF@") {
                            a.u("import '" + c + "';");
                        }
                        else {
                            a.u("import " + e + " from '" + c + "';");
                        }
                    }
                    else {
                        a.u("import { " + e + " } from '" + c + "';");
                    }
                }
            }
            return a.toString();
        }
        usingsToString(a) {
            let b = new StringBuilder(0);
            for (let c = 0; c < this.k.count; c++) {
                if (!stringStartsWith(this.k._inner[c].trim(), "@") && a) {
                    b.u("@" + this.k._inner[c]);
                }
                else {
                    b.u(this.k._inner[c]);
                }
            }
            return b.toString();
        }
        any() {
            return this.j.count > 0 || this.k.count > 0;
        }
        addPackageImport(a, b) {
            if (this.packageOverride != null) {
                a = this.packageOverride;
            }
            if (!this.g.containsKey(a)) {
                this.j.add(a);
                this.g.addItem(a, new HashSet$1(String_$type, 0));
                this.f.addItem(a, new List$1(String_$type, 0));
            }
            if (!this.g.item(a).contains(b)) {
                this.g.item(a).add_1(b);
                this.f.item(a).add(b);
            }
        }
        addDefaultImport(a, b) {
            if (this.packageOverride != null) {
                a = this.packageOverride;
            }
            if (!this.g.containsKey(a)) {
                this.j.add(a);
                this.g.addItem(a, new HashSet$1(String_$type, 0));
                this.f.addItem(a, new List$1(String_$type, 0));
                this.h.add_1(a);
            }
            if (!this.g.item(a).contains(b)) {
                this.g.item(a).add_1(b);
                this.f.item(a).add(b);
            }
        }
        static merge(a, b) {
            let c = new CodeGeneratingImportManager();
            if (a.isImportsOnly || b.isImportsOnly) {
                c.isImportsOnly = true;
            }
            if (b.f.count > 0 || a.f.count > 0) {
                for (let d of fromEnum(a.f.keys)) {
                    for (let e of fromEnum(a.f.item(d))) {
                        if (a.h.contains(d)) {
                            c.addDefaultImport(d, e);
                        }
                        else {
                            c.addPackageImport(d, e);
                        }
                    }
                }
                for (let f of fromEnum(b.f.keys)) {
                    for (let g of fromEnum(b.f.item(f))) {
                        if (b.h.contains(f)) {
                            c.addDefaultImport(f, g);
                        }
                        else {
                            c.addPackageImport(f, g);
                        }
                    }
                }
            }
            else {
                for (let h of fromEnum(a.k)) {
                    c.addUsing(h);
                }
                for (let i of fromEnum(b.k)) {
                    c.addUsing(i);
                }
            }
            return c;
        }
        removeDuplicates(a) {
            let b = CodeGeneratingImportManager.merge(this, new CodeGeneratingImportManager());
            if (this.isImportsOnly) {
                b.isImportsOnly = true;
            }
            if (a.f.count > 0) {
                for (let c of fromEnum(a.f.keys)) {
                    if (this.f.containsKey(c)) {
                        for (let d of fromEnum(a.f.item(c))) {
                            if (b.g.containsKey(c) && b.g.item(c).contains(d)) {
                                b.g.item(c).remove(d);
                                b.f.item(c).remove(d);
                                if (b.f.item(c).count == 0) {
                                    b.j.remove(c);
                                    b.h.remove(c);
                                    b.g.removeItem(c);
                                    b.f.removeItem(c);
                                }
                            }
                        }
                    }
                }
            }
            else {
                for (let e of fromEnum(a.k)) {
                    if (b.i.contains(e)) {
                        b.i.remove(e);
                        b.k.remove(e);
                    }
                }
            }
            return b;
        }
    }
    CodeGeneratingImportManager.$t = /*@__PURE__*/ markType(CodeGeneratingImportManager, 'CodeGeneratingImportManager');
    return CodeGeneratingImportManager;
})();
