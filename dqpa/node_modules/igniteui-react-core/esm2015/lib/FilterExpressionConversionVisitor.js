/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { FilterSyntaxVisitor } from "./FilterSyntaxVisitor";
import { List$1 } from "./List$1";
import { Stack$1 } from "./Stack$1";
import { IFilterExpression_$type } from "./IFilterExpression";
import { StringBuilder } from "./StringBuilder";
import { OperationFilterExpression } from "./OperationFilterExpression";
import { FilterSyntaxTokenType_$type } from "./FilterSyntaxTokenType";
import { String_$type, EnumUtil, typeCast, enumGetBox, markType } from "./type";
import { FilterSyntaxIdentifierExpressionSyntax } from "./FilterSyntaxIdentifierExpressionSyntax";
import { PropertyReferenceFilterExpression } from "./PropertyReferenceFilterExpression";
import { FilterExpressionFunctionType } from "./FilterExpressionFunctionType";
import { FunctionFilterExpression } from "./FunctionFilterExpression";
import { LiteralFilterExpression } from "./LiteralFilterExpression";
/**
 * @hidden
 */
export let FilterExpressionConversionVisitor = /*@__PURE__*/ (() => {
    class FilterExpressionConversionVisitor extends FilterSyntaxVisitor {
        constructor() {
            super();
            this.q = null;
            this.n = null;
            this.r = new Stack$1(IFilterExpression_$type);
            this.s = new StringBuilder(0);
            this.q = new List$1(String_$type, 0);
        }
        o() {
            return this.r.e();
        }
        get p() {
            return this.q.count > 0;
        }
        get k() {
            return this.q.toArray();
        }
        c(a) {
            this.b(a.b);
            let b = this.r.e();
            this.b(a.c);
            let c = this.r.e();
            let d = new OperationFilterExpression(null, 1, null);
            d.operator = this.m(a.d);
            d.left = b;
            d.right = c;
            this.r.h(d);
        }
        t(a) {
            this.q.add(a);
        }
        m(a) {
            switch (a) {
                case 54: return 1;
                case 55: return 2;
                case 56: return 5;
                case 57: return 6;
                case 58: return 3;
                case 59: return 4;
                case 61: return 10;
                case 62: return 11;
                case 63: return 12;
                case 64: return 13;
                case 65: return 14;
                case 66: return 9;
                case 52: return 7;
                case 53: return 8;
            }
            let b = EnumUtil.getName(FilterSyntaxTokenType_$type, a);
            this.t("unexpected operator: " + b);
            return 0;
        }
        d(a) {
            let b = new PropertyReferenceFilterExpression(null);
            b.propertyReference = a.c.toString();
            this.r.h(b);
        }
        e(a) {
            this.b(a.b);
            let b = this.r.e();
            if (a.c != null) {
                this.b(a.c);
                let c = this.r.e();
                b.propertyReference += "." + c.propertyReference;
            }
            this.r.h(b);
        }
        f(a) {
            let b = this.l(a.c);
            let c = [];
            let d = new FunctionFilterExpression(b, ...c);
            d.functionType = b;
            if (a.b != null) {
                let e = true;
                let h = a.b;
                for (let g = 0; g < h.length; g++) {
                    let f = h[g];
                    this.b(f);
                    let i = this.r.e();
                    d.functionArguments.add(i);
                }
            }
            this.r.h(d);
        }
        l(a) {
            if (typeCast(FilterSyntaxIdentifierExpressionSyntax.$, a) !== null) {
                let b = a;
                switch (b.b) {
                    case 20:
                        this.t("unsupported function: " + enumGetBox(FilterSyntaxTokenType_$type, b.b));
                        return 7;
                    case 21: return 2;
                    case 22: return 1;
                    case 23: return 5;
                    case 24: return FilterExpressionFunctionType.Length;
                    case 25: return 4;
                    case 26: return 6;
                    case 27: return 0;
                    case 28: return 7;
                    case 29: return 8;
                    case 30: return 9;
                    case 31: return 10;
                    case 32: return 16;
                    case 33: return 14;
                    case 34: return 11;
                    case 35:
                        this.t("unsupported function: " + enumGetBox(FilterSyntaxTokenType_$type, b.b));
                        return 7;
                    case 36: return 12;
                    case 37:
                        this.t("unsupported function: " + enumGetBox(FilterSyntaxTokenType_$type, b.b));
                        return 7;
                    case 38: return 13;
                    case 39:
                        this.t("unsupported function: " + enumGetBox(FilterSyntaxTokenType_$type, b.b));
                        return 7;
                    case 40: return 15;
                    case 41:
                        this.t("unsupported function: " + enumGetBox(FilterSyntaxTokenType_$type, b.b));
                        return 7;
                    case 42: return 20;
                    case 43: return 21;
                    case 44: return 17;
                    case 45: return 18;
                    case 46: return 19;
                    case 75: return 25;
                    case 47:
                        this.t("unsupported function: " + enumGetBox(FilterSyntaxTokenType_$type, b.b));
                        return 7;
                    case 48:
                        this.t("unsupported function: " + enumGetBox(FilterSyntaxTokenType_$type, b.b));
                        return 7;
                    case 49:
                        this.t("unsupported function: " + enumGetBox(FilterSyntaxTokenType_$type, b.b));
                        return 7;
                    case 50:
                        this.t("unsupported function: " + enumGetBox(FilterSyntaxTokenType_$type, b.b));
                        return 7;
                    case 51: return 22;
                    case 68: return 24;
                }
            }
            this.t("unsupported function type");
            return 7;
        }
        g(a) {
            this.r.h(((() => {
                let $ret = new LiteralFilterExpression(null, false);
                $ret.literalValue = null;
                return $ret;
            })()));
        }
        h(a) {
            let b = ((() => {
                let $ret = new OperationFilterExpression(null, 1, null);
                $ret.operator = 15;
                return $ret;
            })());
            this.b(a.b);
            let c = this.r.e();
            b.left = c;
            this.r.h(b);
        }
        i(a) {
            switch (a.b) {
                case 4:
                case 3:
                case 5:
                    this.r.h(((() => {
                        let $ret = new LiteralFilterExpression(null, false);
                        $ret.literalValue = a.c;
                        return $ret;
                    })()));
                    break;
                case 0:
                    this.r.h(((() => {
                        let $ret = new LiteralFilterExpression(null, false);
                        $ret.literalValue = a.c;
                        return $ret;
                    })()));
                    break;
                case 1:
                    this.r.h(((() => {
                        let $ret = new LiteralFilterExpression(null, false);
                        $ret.literalValue = a.c;
                        return $ret;
                    })()));
                    break;
                case 2:
                    this.r.h(((() => {
                        let $ret = new LiteralFilterExpression(null, false);
                        $ret.literalValue = a.c;
                        return $ret;
                    })()));
                    break;
            }
        }
        j(a) {
            this.b(a.b);
            let b = this.r.e();
            let c = new OperationFilterExpression(null, 1, null);
            c.operator = this.m(a.c);
            c.left = b;
            this.r.h(c);
        }
    }
    FilterExpressionConversionVisitor.$t = /*@__PURE__*/ markType(FilterExpressionConversionVisitor, 'FilterExpressionConversionVisitor', FilterSyntaxVisitor.$);
    return FilterExpressionConversionVisitor;
})();
