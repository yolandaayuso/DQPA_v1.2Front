/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
export class PromiseWrapper {
    constructor(inner) {
        this._state = "pending";
        this._resolvedValue = null;
        this._rejectedError = null;
        this._then = [];
        this._fail = [];
        this._always = [];
        this._promise = inner;
        this._promise
            .then((v) => {
            this._state = "resolved";
            this._resolvedValue = v;
            for (var i = 0; i < this._then.length; i++) {
                this._then[i](v);
            }
            for (var i = 0; i < this._always.length; i++) {
                this._always[i](v);
            }
        })
            .catch((e) => {
            this._state = "rejected";
            this._rejectedError = e;
            for (var i = 0; i < this._fail.length; i++) {
                this._fail[i](e);
            }
            for (var i = 0; i < this._always.length; i++) {
                this._always[i](e);
            }
        });
    }
    state() {
        return this._state;
    }
    then(pass, fail) {
        this.done(pass);
        this.fail(fail);
        return this;
    }
    done(continuation) {
        this._then.push(continuation);
        if (this._state == "resolved") {
            continuation(this._resolvedValue);
        }
        return this;
    }
    fail(continuation) {
        this._fail.push(continuation);
        if (this._state == "failed") {
            continuation(this._rejectedError);
        }
        return this;
    }
    always(continuation) {
        this._always.push(continuation);
        if (this._state == "resolved") {
            continuation(this._resolvedValue);
        }
        if (this._state == "failed") {
            continuation(this._rejectedError);
        }
        return this;
    }
}
export class PromiseFactory {
    constructor() {
        this._wrapper = null;
    }
    resolve(result) {
        if (this._resolve) {
            this._resolve(result);
        }
    }
    reject(error) {
        if (this._reject) {
            this._reject(error);
        }
    }
    promise() {
        this._promise = new Promise((resolve, reject) => {
            this._resolve = resolve;
            this._reject = reject;
        });
        this._wrapper = new PromiseWrapper(this._promise);
        return this._wrapper;
    }
}
