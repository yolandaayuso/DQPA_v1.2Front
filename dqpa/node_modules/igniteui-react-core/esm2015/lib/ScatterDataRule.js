/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { PriorityDataRule } from "./PriorityDataRule";
import { ShapeDataInfo } from "./ShapeDataInfo";
import { DataSeries } from "./DataSeries";
import { List$1 } from "./List$1";
import { IEnumerable_$type, typeCast, String_$type, fromEnum, typeGetValue, Point_$type, markType } from "./type";
import { ShapeChartUtils } from "./ShapeChartUtils";
import { truncate, isNaN_ } from "./number";
import { stringReplace } from "./string";
/**
 * @hidden
 */
export let ScatterDataRule = /*@__PURE__*/ (() => {
    class ScatterDataRule extends PriorityDataRule {
        constructor() {
            super();
            this._supportGeographicSeries = false;
            this._geographicShapeCheckThreshold = 0;
            this._geographicPointCheckThreshold = 0;
            this._monotonicCheckAmount = 0;
            this._smallDataSourceThreshold = 0;
            this._hugeDataSourceThreshold = 0;
            this.priority = 10;
            this.monotonicCheckAmount = 1000;
            this.geographicShapeCheckThreshold = 20;
            this.geographicPointCheckThreshold = 100;
            this.smallDataSourceThreshold = 1000;
            this.hugeDataSourceThreshold = 10000;
            this.supportGeographicSeries = false;
        }
        get supportGeographicSeries() {
            return this._supportGeographicSeries;
        }
        set supportGeographicSeries(a) {
            this._supportGeographicSeries = a;
        }
        get geographicShapeCheckThreshold() {
            return this._geographicShapeCheckThreshold;
        }
        set geographicShapeCheckThreshold(a) {
            this._geographicShapeCheckThreshold = a;
        }
        get geographicPointCheckThreshold() {
            return this._geographicPointCheckThreshold;
        }
        set geographicPointCheckThreshold(a) {
            this._geographicPointCheckThreshold = a;
        }
        get monotonicCheckAmount() {
            return this._monotonicCheckAmount;
        }
        set monotonicCheckAmount(a) {
            this._monotonicCheckAmount = a;
        }
        get smallDataSourceThreshold() {
            return this._smallDataSourceThreshold;
        }
        set smallDataSourceThreshold(a) {
            this._smallDataSourceThreshold = a;
        }
        get hugeDataSourceThreshold() {
            return this._hugeDataSourceThreshold;
        }
        set hugeDataSourceThreshold(a) {
            this._hugeDataSourceThreshold = a;
        }
        evaluate(a) {
            let b = this.b(a);
            if (b != null && b.k != 0) {
                this.n(a, b);
            }
        }
        m(a, b) {
            let c = new Array(1);
            c[0] = b;
            let d = a.analyzer.getTitleString(null, c);
            if (d == null) {
                d = b;
            }
            return d;
        }
        l(a, b, c) {
            let d = new Array(2);
            d[0] = b;
            d[1] = c;
            let e = a.analyzer.getTitleStringWithSeparator(null, d, " vs ");
            if (e != null) {
                return e;
            }
            let f = this.m(a, b);
            let g = this.m(a, c);
            return f + " vs " + g;
        }
        n(a, b) {
            let c = new DataSeries();
            if (b.u) {
                c.priority = truncate(Math.round(b.q * b.o));
            }
            if (b.i.hasPath()) {
                c.addMemberPathHint(b.i);
            }
            if (b.j.hasPath()) {
                c.addMemberPathHint(b.j);
            }
            if (b.h.hasPath()) {
                c.addMemberPathHint(b.h);
            }
            if (b.f.hasPath()) {
                c.addMemberPathHint(b.f);
            }
            if (b.c.hasPath()) {
                c.addMemberPathHint(b.c);
            }
            if (b.e.hasPath()) {
                c.addMemberPathHint(b.e);
            }
            if (b.k == 0) {
                c.suggestedSeries = 24;
            }
            else {
                if (b.x <= this.smallDataSourceThreshold) {
                    if (b.f.hasPath()) {
                        c.suggestedSeries = 17;
                        if (b.v) {
                            c.suggestedSeries = 43;
                        }
                        c.title = this.m(a, b.f.path);
                    }
                    else if (b.c.hasPath()) {
                        c.suggestedSeries = 14;
                        if (b.v) {
                            c.suggestedSeries = 40;
                        }
                        c.title = this.m(a, b.c.path);
                    }
                    else if (b.h.hasPath()) {
                        c.suggestedSeries = 15;
                        if (b.v) {
                            c.suggestedSeries = 41;
                        }
                        c.title = this.m(a, b.h.path);
                    }
                    else {
                        if (b.p <= this.monotonicCheckAmount) {
                            if (b.b.isMonotonic(b.l, b.i.path, this.monotonicCheckAmount) || b.b.isMonotonic(b.l, b.j.path, this.monotonicCheckAmount)) {
                                c.suggestedSeries = 12;
                            }
                            else {
                                c.suggestedSeries = 11;
                                if (b.v) {
                                    c.suggestedSeries = 38;
                                }
                            }
                        }
                        else {
                            c.suggestedSeries = 11;
                            if (b.v) {
                                c.suggestedSeries = 38;
                            }
                        }
                        c.title = this.l(a, b.i.path, b.j.path);
                    }
                }
                else if (b.x <= this.hugeDataSourceThreshold) {
                    if (b.c.hasPath()) {
                        c.suggestedSeries = 14;
                        if (b.v) {
                            c.suggestedSeries = 40;
                        }
                        c.title = this.m(a, b.c.path);
                    }
                    else if (b.h.hasPath()) {
                        c.suggestedSeries = 15;
                        if (b.v) {
                            c.suggestedSeries = 41;
                        }
                        c.title = this.m(a, b.h.path);
                    }
                    else {
                        c.suggestedSeries = 16;
                        if (b.v) {
                            c.suggestedSeries = 42;
                        }
                        c.title = this.l(a, b.i.path, b.j.path);
                    }
                }
                else {
                    c.suggestedSeries = 16;
                    if (b.v) {
                        c.suggestedSeries = 42;
                    }
                    c.title = this.l(a, b.i.path, b.j.path);
                }
            }
            c.suggestedPrimaryAxis = 1;
            c.suggestedSecondaryAxis = 1;
            c.title = a.analyzer.expandCamelCasedWords(c.title);
            a.addDataSeries(c, this);
        }
        getAdditionalValuePropertyStrings(a) {
            let b = new ShapeDataInfo(a);
            let c = this.a(a.analyzer.getAllStringProperties());
            let d = this.a(a.analyzer.getAllNumericProperties());
            for (let e = 0; e < b.p; e++) {
                let f = b.l.getItemAtIndex(e);
                if (e == 0) {
                    let g = b.b.getAllPropertiesWithName("Fields");
                    if (g.length == 0) {
                        g = b.b.getAllPropertiesWithName("fields");
                    }
                    if (g.length > 0) {
                        let h = typeCast(IEnumerable_$type, b.l.getItemValue(f, g[0]));
                        if (h != null) {
                            let i = f.fieldsNames;
                            let j = f.fieldsTypes;
                            if (j != null && i != null) {
                                b.o = 1.2;
                                d = new List$1(String_$type, 0);
                                c = new List$1(String_$type, 0);
                                for (let k = 0; k < j.count; k++) {
                                    if (j._inner[k] == "string") {
                                        c.add(g[0] + "[" + i._inner[k] + "]");
                                    }
                                    else {
                                        d.add(g[0] + "[" + i._inner[k] + "]");
                                    }
                                }
                            }
                        }
                    }
                }
                if (!b.g.hasPath()) {
                    break;
                }
                else {
                    let l = false;
                    let m = b.l.getItemValue(f, b.g.path);
                    if (m != null && a.analyzer.isCollection(m)) {
                        let n = a.getSubProvider(m, b.g.path);
                        if (n.actualCount == 0) {
                            continue;
                        }
                        for (let o = 0; o < n.actualCount; o++) {
                            let p = n.getItemAtIndex(o);
                            if (p == null || !a.analyzer.isCollection(p)) {
                                continue;
                            }
                            let q = a.getSubProvider(p, "[" + o + "]");
                            let r = q.actualCount;
                            if (r == 0) {
                                continue;
                            }
                            if (e == 0 && o == 0 && (!b.i.hasPath() || !b.j.hasPath())) {
                                l = true;
                                let s = this.a(a.analyzer.getAllNumericProperties());
                                for (let t of fromEnum(s)) {
                                    d.add(b.g.path + "[0][0]." + t);
                                }
                            }
                            a.popSubProvider();
                        }
                        a.popSubProvider();
                        if (l) {
                            break;
                        }
                    }
                    else {
                        break;
                    }
                }
            }
            return d.toArray();
        }
        b(a) {
            let b = new ShapeDataInfo(a);
            b.q = this.priority;
            b.o = 1;
            b.u = a.adjustPrioritiesBasedOnFitness;
            if (b.p == 0) {
                if (a.adjustPrioritiesBasedOnFitness) {
                    b.q = 0;
                }
                return null;
            }
            if (a.adjustPrioritiesBasedOnFitness && b.p == 1) {
                b.o *= 0.8;
            }
            let c = true;
            let d = new List$1(String_$type, 0);
            let e = a.getCurrentDataSource();
            for (let f = 0; f < b.p; f++) {
                let g = b.l.getItemAtIndex(f);
                if (f == 0) {
                    let h = this.a(a.analyzer.getAllStringProperties());
                    let i = this.a(a.analyzer.getAllNumericProperties());
                    this.p(a, e, b, i, null);
                    b.s(i, null);
                    b.t(h, null);
                    let j = b.b.getAllPropertiesWithName("ShapeType");
                    if (j.length == 0) {
                        j = b.b.getAllPropertiesWithName("shapeType");
                    }
                    if (j.length > 0) {
                        b.o = 1.2;
                        let k = b.l.getItemValue(g, "shapeType");
                        if (typeof k === 'number') {
                            b.k = ShapeChartUtils.a(typeGetValue(k));
                        }
                        if (typeof k === 'number') {
                            b.k = ShapeChartUtils.a(truncate(Math.round(k)));
                        }
                    }
                    let l = b.b.getAllPropertiesWithName("Fields");
                    if (l.length == 0) {
                        l = b.b.getAllPropertiesWithName("fields");
                    }
                    if (l.length > 0) {
                        let m = typeCast(IEnumerable_$type, b.l.getItemValue(g, l[0]));
                        if (m != null) {
                            let n = g.fieldsNames;
                            let o = g.fieldsTypes;
                            if (o != null && n != null) {
                                b.o = 1.2;
                                i = new List$1(String_$type, 0);
                                h = new List$1(String_$type, 0);
                                for (let p = 0; p < o.count; p++) {
                                    let q = l[0] + "[" + n._inner[p] + "]";
                                    if (!a.analyzer.shouldIncludeProperty(q, null)) {
                                        continue;
                                    }
                                    if (o._inner[p] == "string") {
                                        h.add(n._inner[p]);
                                    }
                                    else {
                                        i.add(n._inner[p]);
                                        d.add("fieldValues[" + n._inner[p] + "]");
                                    }
                                }
                                this.p(a, e, b, i, "fieldValues[NAME]");
                                b.s(i, "fieldValues[NAME]");
                                b.t(h, "fieldValues[NAME]");
                            }
                        }
                    }
                    let r = this.a(a.analyzer.getAllObjectProperties());
                    b.r(r, null);
                }
                if (!b.g.hasPath()) {
                    b.x = b.p;
                    if (b.k == 0) {
                        if (b.i.hasPath() && b.j.hasPath()) {
                            if (this.supportGeographicSeries) {
                                if (f < this.geographicPointCheckThreshold) {
                                    let s = b.l.getItemValue(g, b.i.path);
                                    let t = b.l.getItemValue(g, b.j.path);
                                    if (!this.e(a.analyzer.coerceToDouble(s), a.analyzer.coerceToDouble(t))) {
                                        c = false;
                                    }
                                }
                            }
                            b.k = 3;
                        }
                    }
                    else {
                        b.k = 0;
                    }
                    break;
                }
                else {
                    let u = b.l.getItemValue(g, b.g.path);
                    let v = this.a(a.analyzer.getAllNumericProperties());
                    if (u != null && a.analyzer.isCollection(u)) {
                        b.o = 1.2;
                        b.y = Math.max(b.l.actualCount, b.y);
                        b.z += b.l.actualCount;
                        let w = a.getSubProvider(u, b.g.path);
                        if (w.actualCount == 0) {
                            continue;
                        }
                        for (let x = 0; x < w.actualCount; x++) {
                            let y = w.getItemAtIndex(x);
                            if (y == null || !a.analyzer.isCollection(y)) {
                                continue;
                            }
                            b.w = Math.max(w.actualCount, b.w);
                            b.x += w.actualCount;
                            let z = a.getSubProvider(y, "[" + x + "]");
                            let aa = z.actualCount;
                            if (aa == 0) {
                                continue;
                            }
                            if (f == 0 && x == 0 && (!b.i.hasPath() || !b.j.hasPath())) {
                                let ab = this.a(a.analyzer.getAllNumericProperties());
                                for (let ac = ab.count - 1; ac >= 0; ac--) {
                                    let ad = ab._inner[ac];
                                    let ae = b.g.path + "[0][0]." + ad;
                                    if (!a.analyzer.shouldIncludeProperty(ae, null)) {
                                        ab.removeAt(ac);
                                    }
                                }
                                if (ab.count > 0) {
                                    let af = b.g.path + "[0][0].NAME";
                                    b.s(ab, af);
                                }
                            }
                            if (this.supportGeographicSeries && f < this.geographicShapeCheckThreshold && x == 0) {
                                for (let ag = 0; ag < Math.min(z.actualCount, this.geographicPointCheckThreshold); ag++) {
                                    let ah = this.q(z.getItemAtIndex(ag));
                                    if (!this.d(ah)) {
                                        c = false;
                                    }
                                }
                            }
                            if (b.k == 0) {
                                if (z.actualCount == 1) {
                                    b.k = 3;
                                }
                                else {
                                    let ai = this.q(z.getItemAtIndex(0));
                                    let aj = this.q(z.getItemAtIndex(aa - 1));
                                    if (ai.x == aj.x && ai.y == aj.y) {
                                        b.k = 2;
                                        if (!b.c.hasPath() || this.c(a, e, b, b.c.path)) {
                                            this.o(a, e, b);
                                        }
                                    }
                                    else {
                                        b.k = 1;
                                    }
                                }
                            }
                            a.popSubProvider();
                        }
                        a.popSubProvider();
                        if (b.k == 0) {
                            if (b.x == b.p || b.y == 1) {
                                b.k = 3;
                            }
                            if (b.h.hasPath()) {
                                b.k = 1;
                            }
                        }
                    }
                }
            }
            b.v = c && this.supportGeographicSeries;
            return b;
        }
        c(a, b, c, d) {
            if (a.analyzer.isMonotonic(b, d, this.monotonicCheckAmount)) {
                return true;
            }
            if (a.analyzer.isEvenlySpaced(b, d, this.monotonicCheckAmount)) {
                return true;
            }
            if (a.analyzer.numericColumnHasNoRange(b, d, this.monotonicCheckAmount)) {
                return true;
            }
            return false;
        }
        o(a, b, c) {
            if (c.n.count > 0) {
                c.c.update1(c.n._inner[0], null);
                c.c.logarithmicSuggested = a.analyzer.shouldUseLogarithmicScale(b, c.n._inner[0]);
            }
        }
        p(a, b, c, d, e) {
            for (let f of fromEnum(d)) {
                let g = f;
                if (e != null) {
                    g = stringReplace(e, "NAME", f);
                }
                if (!this.c(a, b, c, g)) {
                    c.n.add(g);
                }
            }
        }
        e(a, b) {
            if (isNaN_(a) || isNaN_(b)) {
                return true;
            }
            if (a >= -180 && a <= 180 && b >= -90 && b <= 90) {
                return true;
            }
            return false;
        }
        d(a) {
            return this.e(a.x, a.y);
        }
        q(a) {
            if (a == null) {
                return { $type: Point_$type, x: NaN, y: NaN };
            }
            if (typeCast(Point_$type, a) !== null) {
                return a;
            }
            let p_ = a;
            if (((p_.__x && p_.__y))) {
                return a;
            }
            if (((p_.x && p_.y))) {
                return { $type: Point_$type, x: (p_.x), y: (p_.y) };
            }
            return { $type: Point_$type, x: NaN, y: NaN };
        }
    }
    ScatterDataRule.$t = /*@__PURE__*/ markType(ScatterDataRule, 'ScatterDataRule', PriorityDataRule.$);
    return ScatterDataRule;
})();
