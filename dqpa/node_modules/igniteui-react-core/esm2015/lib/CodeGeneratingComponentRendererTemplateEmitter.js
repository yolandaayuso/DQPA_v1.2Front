/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { Base, String_$type, markType } from "./type";
import { CodeGeneratingCodeWriter } from "./CodeGeneratingCodeWriter";
import { CodeGeneratingImportManager } from "./CodeGeneratingImportManager";
import { HashSet$1 } from "./HashSet$1";
import { JsonDictionaryParser } from "./JsonDictionaryParser";
import { stringReplace } from "./string";
/**
 * @hidden
 */
export let CodeGeneratingComponentRendererTemplateEmitter = /*@__PURE__*/ (() => {
    class CodeGeneratingComponentRendererTemplateEmitter extends Base {
        get n() {
            return this.m;
        }
        constructor(a, b) {
            super();
            this.o = null;
            this.m = null;
            this.e = null;
            this.b = null;
            this.c = null;
            this.d = null;
            this.a = null;
            this.k = new CodeGeneratingImportManager();
            this.p = new HashSet$1(String_$type, 0);
            this.o = a;
            this.m = b;
            this.e = new CodeGeneratingCodeWriter(this.o);
            this.a = new CodeGeneratingCodeWriter(this.o);
            this.b = new CodeGeneratingCodeWriter(this.o);
            this.c = new CodeGeneratingCodeWriter(this.o);
            this.d = new CodeGeneratingCodeWriter(this.o);
        }
        get j() {
            return this.e;
        }
        get g() {
            return this.b;
        }
        get h() {
            return this.c;
        }
        get i() {
            return this.d;
        }
        get f() {
            return this.a;
        }
        get l() {
            return this.k;
        }
        r() {
            let a = new HashSet$1(String_$type, 0);
            for (let b = 0; b < this.m.t.count; b++) {
                let c = this.m.t._inner[b];
                if (c.a != null && c.c == null) {
                    if (this.o.library != null && this.o.library.hasItem(c.a.e)) {
                        if (a.contains(c.a.e)) {
                            continue;
                        }
                        a.add_1(c.a.e);
                        let d = this.o.library.getItem(c.a.e);
                        if (d.type == 2) {
                            let e = d.getContentForPlatform(this.m.platform);
                            if (e != null) {
                                if (e.isJSContent) {
                                    let f = e.content;
                                    this.f.l(f);
                                }
                                else if (e.isJson) {
                                    let g = new JsonDictionaryParser();
                                    let h = g.parse(e.content);
                                    if (h.g("imports")) {
                                        let i = h.item("imports").value;
                                        let j = stringReplace(i, "\r\n", "\n").split('\n');
                                        for (let l = 0; l < j.length; l++) {
                                            let k = j[l];
                                            if (k.trim().length == 0) {
                                                continue;
                                            }
                                            if (!this.p.contains(k)) {
                                                this.p.add_1(k);
                                                this.s(this.l, k);
                                            }
                                        }
                                    }
                                    if (h.g("styles")) {
                                        let m = h.item("styles").value;
                                        let n = stringReplace(m, "\r\n", "\n").split('\n');
                                        for (let p = 0; p < n.length; p++) {
                                            let o = n[p];
                                            if (o.trim().length == 0) {
                                                continue;
                                            }
                                            this.g.l(o);
                                        }
                                    }
                                    if (h.g("supportingMethods")) {
                                        let q = h.item("supportingMethods").value;
                                        q = this.q(c.a.e, q);
                                        let r = stringReplace(q, "\r\n", "\n").split('\n');
                                        for (let t = 0; t < r.length; t++) {
                                            let s = r[t];
                                            if (s.trim().length == 0) {
                                                continue;
                                            }
                                            this.h.l(s);
                                        }
                                    }
                                    if (h.g("content")) {
                                        let u = h.item("content").value;
                                        u = this.q(c.a.e, u);
                                        let v = stringReplace(u, "\r\n", "\n").split('\n');
                                        let w = 0x7FFFFFFF;
                                        let x = "";
                                        for (let y = 0; y < this.o.indentSpaces; y++) {
                                            x += " ";
                                        }
                                        for (let aa = 0; aa < v.length; aa++) {
                                            let z = v[aa];
                                            let ab = z;
                                            if (ab.trim().length == 0) {
                                                continue;
                                            }
                                            ab = stringReplace(z, "\t", x);
                                            let ac = 0;
                                            for (let ad = 0; ad < ab.length; ad++) {
                                                if (ab.charAt(ad) != ' ' && ab.charAt(ad) != '\t') {
                                                    break;
                                                }
                                                ac++;
                                            }
                                            if (ac < w) {
                                                w = ac;
                                            }
                                        }
                                        for (let af = 0; af < v.length; af++) {
                                            let ae = v[af];
                                            let ag = ae;
                                            let ah = 0;
                                            if (ag.trim().length > 0) {
                                                while (ag.length > 0 && (ag.charAt(0) == ' ' || ag.charAt(0) == '\t') && ah < w) {
                                                    if (ag.charAt(0) == ' ') {
                                                        ag = ag.substr(1);
                                                        ah++;
                                                    }
                                                    if (ag.charAt(0) == '\t') {
                                                        ag = ag.substr(1);
                                                        ah += this.o.indentSpaces;
                                                    }
                                                }
                                            }
                                            this.j.l(ag);
                                        }
                                    }
                                    if (h.g("supportingTypes")) {
                                        let ai = h.item("supportingTypes").value;
                                        let aj = stringReplace(ai, "\r\n", "\n").split('\n');
                                        for (let al = 0; al < aj.length; al++) {
                                            let ak = aj[al];
                                            if (ak.trim().length == 0) {
                                                continue;
                                            }
                                            this.i.l(ak);
                                        }
                                    }
                                }
                                else {
                                    let am = e.content;
                                    this.j.l(am);
                                }
                            }
                        }
                    }
                }
            }
            this.m.addContainerResult("templateContents", this.j.toString());
            this.m.addImportResult("templateImports", this.l);
            this.m.addContainerResult("templateSupportingMethods", this.h.toString());
            this.m.addContainerResult("templateSupportingTypes", this.i.toString());
            this.m.addContainerResult("templateStyles", this.g.toString());
            this.m.addContainerResult("templateScripts", this.f.toString());
        }
        s(a, b) {
        }
        q(a, b) {
            return b;
        }
    }
    CodeGeneratingComponentRendererTemplateEmitter.$t = /*@__PURE__*/ markType(CodeGeneratingComponentRendererTemplateEmitter, 'CodeGeneratingComponentRendererTemplateEmitter');
    return CodeGeneratingComponentRendererTemplateEmitter;
})();
