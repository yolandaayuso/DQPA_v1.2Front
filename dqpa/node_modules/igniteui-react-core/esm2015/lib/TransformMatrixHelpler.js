/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { Base, typeCast, Point_$type, markType } from "./type";
import { Matrix } from "./Matrix";
import { ScaleTransform } from "./ScaleTransform";
import { RotateTransform } from "./RotateTransform";
import { TranslateTransform } from "./TranslateTransform";
import { TransformGroup } from "./TransformGroup";
import { MatrixTransform } from "./MatrixTransform";
import { isNaN_ } from "./number";
/**
 * @hidden
 */
export let TransformMatrixHelpler = /*@__PURE__*/ (() => {
    class TransformMatrixHelpler extends Base {
        static f(a) {
            if (typeCast(MatrixTransform.$, a) !== null) {
                return a.j;
            }
            if (typeCast(ScaleTransform.$, a) !== null) {
                let b = a;
                return TransformMatrixHelpler.g(0, b.l, b.m, { $type: Point_$type, x: 0, y: 0 });
            }
            if (typeCast(RotateTransform.$, a) !== null) {
                let c = a;
                let d = 0;
                let e = 0;
                if (!isNaN_(c.k)) {
                    d = c.k;
                }
                if (!isNaN_(c.l)) {
                    e = c.l;
                }
                let f = TransformMatrixHelpler.g(0, 1, 1, { $type: Point_$type, x: -d, y: -e });
                let g = TransformMatrixHelpler.g(c.j, 1, 1, { $type: Point_$type, x: 0, y: 0 });
                let h = TransformMatrixHelpler.g(0, 1, 1, { $type: Point_$type, x: d, y: e });
                let i = TransformMatrixHelpler.e(f, g);
                i = TransformMatrixHelpler.e(i, h);
                return i;
            }
            if (typeCast(TranslateTransform.$, a) !== null) {
                let j = a;
                return TransformMatrixHelpler.g(0, 1, 1, { $type: Point_$type, x: j.j, y: j.k });
            }
            if (typeCast(TransformGroup.$, a) !== null) {
                let k = a;
                let l = new Matrix();
                l.j = 1;
                l.m = 1;
                if (k.j.count > 0) {
                    l = TransformMatrixHelpler.f(k.j._inner[0]);
                    for (let m = 1; m < k.j.count; m++) {
                        let n = TransformMatrixHelpler.f(k.j._inner[m]);
                        l = TransformMatrixHelpler.e(l, n);
                    }
                }
                return l;
            }
            return a;
        }
        static a(a) {
            return Math.atan2(a.k, a.j) * 180 / Math.PI;
        }
        static b(a) {
            let b = Math.sqrt((a.j * a.j) + (a.k * a.k));
            return b;
        }
        static c(a) {
            let b = Math.sqrt((a.l * a.l) + (a.m * a.m));
            return b;
        }
        static i(a, b) {
            let c = a.j * b.x + a.l * b.y + a.n;
            let d = a.k * b.x + a.m * b.y + a.o;
            return { $type: Point_$type, x: c, y: d };
        }
        static h(a) {
            return { $type: Point_$type, x: a.n, y: a.o };
        }
        static e(a, b) {
            let c = new Matrix();
            c.j = a.j * b.j + a.k * b.l;
            c.k = a.j * b.k + a.k * b.m;
            c.n = a.n * b.j + a.o * b.l + b.n;
            c.l = a.l * b.j + a.m * b.l;
            c.m = a.l * b.k + a.m * b.m;
            c.o = a.n * b.k + a.o * b.m + b.o;
            return c;
        }
        static d(a, b, c) {
            let d = TransformMatrixHelpler.a(b);
            let e = TransformMatrixHelpler.a(c);
            let f = TransformMatrixHelpler.b(b);
            let g = TransformMatrixHelpler.b(c);
            let h = TransformMatrixHelpler.c(b);
            let i = TransformMatrixHelpler.c(c);
            let j = TransformMatrixHelpler.h(b);
            let k = TransformMatrixHelpler.h(c);
            let l = d + (e - d) * a;
            let m = f + (g - f) * a;
            let n = h + (i - h) * a;
            let o = { $type: Point_$type, x: j.x + (k.x - j.x) * a, y: j.y + (k.y - j.y) * a };
            return TransformMatrixHelpler.g(l, m, n, o);
        }
        static g(a, b, c, d) {
            a = a % 360;
            let e = a * Math.PI / 180;
            let f = new Matrix();
            let g = Math.cos(e);
            let h = Math.sin(e);
            f.j = b * g;
            f.k = b * h;
            f.l = -c * h;
            f.m = c * g;
            f.n = d.x;
            f.o = d.y;
            return f;
        }
    }
    TransformMatrixHelpler.$t = /*@__PURE__*/ markType(TransformMatrixHelpler, 'TransformMatrixHelpler');
    return TransformMatrixHelpler;
})();
