/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { Base, Point_$type, markType } from "./type";
import { Thickness } from "./Thickness";
import { CornerRadius } from "./CornerRadius";
import { Rect } from "./Rect";
import { List$1 } from "./List$1";
/**
 * @hidden
 */
export let InterpolationUtil = /*@__PURE__*/ (() => {
    class InterpolationUtil extends Base {
        static g(a, b, c) {
            return new Thickness(1, b.left + a * (c.left - b.left), b.top + a * (c.top - b.top), b.right + a * (c.right - b.right), b.bottom + a * (c.bottom - b.bottom));
        }
        static e(a, b, c) {
            return new CornerRadius(1, b.d + a * (c.d - b.d), b.e + a * (c.e - b.e), b.c + a * (c.c - b.c), b.b + a * (c.b - b.b));
        }
        static f(a, b, c) {
            return new Rect(0, b.left + a * (c.left - b.left), b.top + a * (c.top - b.top), b.width + a * (c.width - b.width), b.height + a * (c.height - b.height));
        }
        static c(a, b, c, d) {
            let e = 1 - b;
            if (a == null) {
                a = new List$1(Point_$type, 0);
            }
            if (c == null) {
                c = new List$1(Point_$type, 0);
            }
            let f = c.count;
            let g = d.count;
            let h = Math.max(f, g);
            let i = a.count;
            if (i < h) {
                a.s(i, new Array(h - i));
            }
            if (i > h) {
                a.v(h, i - h);
            }
            for (let j = 0; j < Math.min(f, g); ++j) {
                a._inner[j] = { $type: Point_$type, x: (c._inner[j].x * e) + (d._inner[j].x * b), y: (c._inner[j].y * e) + (d._inner[j].y * b) };
            }
            if (f < g) {
                let k = f > 0 ? c._inner[f - 1] : { $type: Point_$type, x: 0, y: 0 };
                for (let l = f; l < g; ++l) {
                    a._inner[l] = { $type: Point_$type, x: (k.x * e) + (d._inner[l].x * b), y: (k.y * e) + (d._inner[l].y * b) };
                }
            }
            if (f > g) {
                let m = g > 0 ? d._inner[g - 1] : { $type: Point_$type, x: 0, y: 0 };
                for (let n = g; n < f; ++n) {
                    a._inner[n] = { $type: Point_$type, x: (c._inner[n].x * e) + (m.x * b), y: (c._inner[n].y * e) + (m.y * b) };
                }
            }
            return a;
        }
        static a($t, a, b, c, d, e, f) {
            return InterpolationUtil.d($t, new List$1($t, 1, a), b, new List$1($t, 1, c), new List$1($t, 1, d), e, f).toArray();
        }
        static d($t, a, b, c, d, e, f) {
            let g = 1 - b;
            if (a == null) {
                a = new List$1($t, 0);
            }
            if (c == null) {
                c = new List$1($t, 0);
            }
            let h = c.count;
            let i = d.count;
            let j = Math.max(h, i);
            if (a.count < j) {
                let k = j - a.count;
                let l = new Array(k);
                a.s(a.count, l);
            }
            if (a.count > j) {
                a.v(j, a.count - j);
            }
            for (let m = 0; m < Math.min(h, i); ++m) {
                a._inner[m] = f(b, g, c._inner[m], d._inner[m]);
            }
            if (h < i) {
                let n = h > 0 ? c._inner[h - 1] : e();
                for (let o = h; o < i; ++o) {
                    a._inner[o] = f(b, g, n, d._inner[o]);
                }
            }
            if (h > i) {
                let p = i > 0 ? d._inner[i - 1] : e();
                for (let q = i; q < h; ++q) {
                    a._inner[q] = f(b, g, c._inner[q], p);
                }
            }
            return a;
        }
        static b(a, b, c) {
            let d = 1 - a;
            if (b == null) {
                b = new Array(0);
            }
            let e = b.length;
            let f = c.length;
            let g = Math.max(e, f);
            let h = new Array(g);
            for (let i = 0; i < Math.min(e, f); i++) {
                h[i] = b[i] + a * (c[i] - b[i]);
            }
            if (e < f) {
                let j = e > 0 ? b[e - 1] : 0;
                for (let k = e; k < f; ++k) {
                    h[k] = j + a * (c[k] - j);
                }
            }
            if (e > f) {
                let l = f > 0 ? c[f - 1] : 0;
                for (let m = f; m < e; ++m) {
                    h[m] = b[m] + a * (l - b[m]);
                }
            }
            return h;
        }
    }
    InterpolationUtil.$t = /*@__PURE__*/ markType(InterpolationUtil, 'InterpolationUtil');
    return InterpolationUtil;
})();
