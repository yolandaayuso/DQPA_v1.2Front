/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { Base, Point_$type, typeCast, markType, PointUtil } from "./type";
import { IRenderer_$type } from "./IRenderer";
import { Brush } from "./Brush";
import { List$1 } from "./List$1";
import { ArcSegment } from "./ArcSegment";
import { Size } from "./Size";
import { CoreGeometryUtil } from "./CoreGeometryUtil";
import { TransformGroup } from "./TransformGroup";
import { TranslateTransform } from "./TranslateTransform";
import { RotateTransform } from "./RotateTransform";
import { ScaleTransform } from "./ScaleTransform";
import { TextFontMetrics } from "./TextFontMetrics";
import { isNaN_ } from "./number";
/**
 * @hidden
 */
export let CanvasViewRenderer = /*@__PURE__*/ (() => {
    class CanvasViewRenderer extends Base {
        constructor() {
            super(...arguments);
            this.j = null;
            this.h = 0;
            this.f = 0;
            this.i = 0;
            this.g = 0;
            this.b = false;
            this.c = false;
            this.aa = null;
            this.m = "left";
            this.a = null;
            this.d = 11;
            this.e = 1;
        }
        h$e() {
            return this.j;
        }
        get h$d() {
            return this.j;
        }
        set h$d(a) {
            this.j = a;
        }
        l(a, b, c, d, e, f, g) {
            return CanvasViewRenderer.k(this.j, a, b, c, d, e, f, g);
        }
        static k(a, b, c, d, e, f, g, h) {
            let i;
            if (b.useCustomDirection) {
                let j, k, l, m, n;
                n = e - c;
                j = c + b.startX * n;
                l = c + b.endX * n;
                n = f - d;
                k = d + b.startY * n;
                m = d + b.endY * n;
                if (h) {
                    let o = g / 2;
                    j -= o;
                    l += o;
                    k -= o;
                    m += o;
                }
                i = a.createLinearGradient(j, k, l, m);
            }
            else {
                if (h) {
                    let p = g / 2;
                    c -= p;
                    e += p;
                    d -= p;
                    f += p;
                }
                i = a.createLinearGradient(c, d, c, f);
            }
            for (let q = 0; q < b.gradientStops.length; q++) {
                let r = b.gradientStops[q];
                i.addColorStop(r.offset, r._fill);
            }
            return i;
        }
        h$t(a) {
            if (a._visibility != 0) {
                return;
            }
            let b = a.n;
            let c = a.o;
            let d = a.width;
            let e = a.height;
            let f = a.ap;
            let g = a.aq;
            this.j.beginPath();
            this.j.globalAlpha = (a._opacity * this.e);
            if (a.ai != null) {
                let h = new Array(a.ai.count);
                for (let i = 0; i < a.ai.count; i++) {
                    h[i] = a.ai._inner[i];
                }
                this.j.setLineDash(h);
            }
            else {
                this.j.setLineDash(new Array(0));
            }
            if (f > 0 || g > 0) {
                if (f > d / 2) {
                    f = (d / 2);
                }
                if (g > e / 2) {
                    g = (e / 2);
                }
                let j = Math.min(f, g);
                this.j.beginPath();
                this.j.moveTo(b + j, c);
                this.j.lineTo(b + d - j, c);
                this.j.arc(b + d - j, c + j, j, (3 / 2 * Math.PI), 0, false);
                this.j.lineTo(b + d, c + e - j);
                this.j.arc(b + d - j, c + e - j, j, 0, (Math.PI / 2), false);
                this.j.lineTo(b + j, c + e);
                this.j.arc(b + j, c + e - j, j, (Math.PI / 2), Math.PI, false);
                this.j.lineTo(b, c + j);
                this.j.arc(b + j, c + j, j, Math.PI, (3 / 2 * Math.PI), false);
                this.j.closePath();
            }
            else {
                this.j.rect(b, c, d, e);
            }
            let k = a._fill;
            let l = a._stroke;
            if (k != null) {
                if (k.isGradient && c == c && b == b) {
                    this.j.fillStyle = this.l(k, b, c, b + d, c + e, a.ad, false);
                }
                else {
                    this.j.fillStyle = k._fill;
                }
                this.j.fill();
            }
            if (l != null) {
                if (l.isGradient && c == c && b == b) {
                    this.j.strokeStyle = this.l(l, b, c, b + d, c + e, a.ad, true);
                }
                else {
                    this.j.strokeStyle = l._fill;
                }
                this.j.lineWidth = a.ad;
                this.j.stroke();
            }
            this.j.globalAlpha = 1;
            if (a.ai != null) {
                this.j.setLineDash(new Array(0));
            }
        }
        h$q(a) {
            if (a._visibility != 0) {
                return;
            }
            this.j.beginPath();
            if (a._opacity < 1 || this.e < 1) {
                this.j.globalAlpha = (a._opacity * this.e);
            }
            let b = a._fill;
            let c = a._stroke;
            this.b = (b != null && b.isGradient) || (c != null && c.isGradient);
            if (this.b) {
                this.f = -1.7976931348623157E+308;
                this.g = -1.7976931348623157E+308;
                this.h = 1.7976931348623157E+308;
                this.i = 1.7976931348623157E+308;
                this.c = false;
            }
            switch (a.am) {
                case 0:
                    this.j.lineJoin = "miter";
                    break;
                case 1:
                    this.j.lineJoin = "bevel";
                    break;
                case 2:
                    this.j.lineJoin = "round";
                    break;
            }
            switch (a.al) {
                case 0:
                    this.j.lineCap = "butt";
                    break;
                case 3:
                case 2:
                    this.j.lineCap = "round";
                    break;
                case 1:
                    this.j.lineCap = "square";
                    break;
            }
            if (a.ai != null) {
                let d = new Array(a.ai.count);
                for (let e = 0; e < a.ai.count; e++) {
                    d[e] = a.ai._inner[e];
                }
                this.j.setLineDash(d);
            }
            else {
                this.j.setLineDash(new Array(0));
            }
            this.h$o(a.an);
            if (b != null) {
                if (b.isGradient && this.c) {
                    this.j.fillStyle = this.l(b, this.h, this.i, this.f, this.g, a.ad, false);
                }
                else {
                    this.j.fillStyle = a._fill._fill;
                }
                this.j.fill();
            }
            if (c != null) {
                if (c.isGradient && this.c) {
                    this.j.strokeStyle = this.l(c, this.h, this.i, this.f, this.g, a.ad, true);
                }
                else {
                    this.j.strokeStyle = a._stroke._fill;
                }
                this.j.lineWidth = a.ad;
                if (a.ad > 0) {
                    this.j.stroke();
                }
            }
            if (a._opacity < 1 || this.e < 1) {
                this.j.globalAlpha = 1;
            }
            if (a.ai != null) {
                this.j.setLineDash(new Array(0));
            }
        }
        h$o(a) {
            if (a == null) {
                return;
            }
            let b = a.b;
            switch (b) {
                case 0:
                    for (let c = 0; c < a.d.count; c++) {
                        this.h$o(a.d._inner[c]);
                    }
                    break;
                case 4:
                    this.t(a);
                    break;
                case 1:
                    this.r(a);
                    break;
                case 2:
                    this.w(a);
                    break;
                case 3:
                    this.p(a);
                    break;
            }
        }
        p(a) {
            this.j.moveTo(a.e.x, (a.e.y - a.d));
            this.aa = { $type: Point_$type, x: a.e.x, y: a.e.y - a.d };
            let b = ((() => {
                let $ret = new ArcSegment();
                $ret.e = { $type: Point_$type, x: a.e.x, y: a.e.y + a.d };
                $ret.b = false;
                $ret.f = new Size(1, a.c, a.d);
                return $ret;
            })());
            let c = ((() => {
                let $ret = new ArcSegment();
                $ret.e = { $type: Point_$type, x: a.e.x, y: a.e.y - a.d };
                $ret.b = false;
                $ret.f = new Size(1, a.c, a.d);
                return $ret;
            })());
            let d = this.b;
            this.b = false;
            this.n(b);
            this.n(c);
            this.b = d;
            if (!this.b) {
                return;
            }
            let e = a.e.x - a.c;
            let f = a.e.y + a.c;
            let g = a.e.x - a.d;
            let h = a.e.y + a.d;
            let i = this.f;
            let j = this.g;
            let k = this.h;
            let l = this.i;
            this.h = e < k ? e : k;
            this.i = g < l ? g : l;
            this.f = f > i ? f : i;
            this.g = h > j ? h : j;
            this.c = true;
        }
        t(a) {
            let b = a.c;
            let c = b.count;
            for (let d = 0; d < c; d++) {
                this.q(b._inner[d]);
            }
        }
        q(a) {
            let b = a == null ? null : a._startPoint;
            if (PointUtil.equals(b, null)) {
                return;
            }
            let c = b.x;
            let d = b.y;
            this.j.moveTo(c, d);
            if (this.b) {
                let e = this.f;
                let f = this.g;
                let g = this.h;
                let h = this.i;
                this.h = c < g ? c : g;
                this.i = d < h ? d : h;
                this.f = c > e ? c : e;
                this.g = d > f ? d : f;
                this.c = true;
            }
            this.aa = b;
            let i = a._segments;
            let j = i.count;
            for (let k = 0; k < j; k++) {
                this.x(i._inner[k]);
            }
            if (a._isClosed) {
                this.j.closePath();
            }
        }
        x(a) {
            let b = a.a;
            switch (b) {
                case 0:
                    this.s(a);
                    break;
                case 3:
                    this.v(a);
                    break;
                case 4:
                    this.n(a);
                    break;
                case 1:
                    this.o(a);
                    break;
                case 2:
                    this.u(a);
                    break;
            }
        }
        z(a, b, c, d, e, f, g, h) {
            let i = 1 / 50;
            let j;
            let k;
            let l;
            let m;
            let n;
            let o;
            let p;
            let q = this.h;
            let r = this.i;
            let s = this.f;
            let t = this.g;
            for (let u = 0; u <= 1; u += i) {
                j = 1 - u;
                k = j * j;
                l = k * j;
                m = u * u;
                n = m * u;
                o = l * a + 3 * k * u * c + 3 * j * m * e + n * g;
                p = l * b + 3 * k * u * d + 3 * j * m * f + n * h;
                q = o < q ? o : q;
                r = p < r ? p : r;
                s = o > s ? o : s;
                t = p > t ? p : t;
            }
            this.h = q;
            this.i = r;
            this.f = s;
            this.g = t;
            this.c = true;
        }
        o(a) {
            this.j.bezierCurveTo(a.e.x, a.e.y, a.f.x, a.f.y, a.g.x, a.g.y);
            if (this.b) {
                this.z(this.aa.x, this.aa.y, a.e.x, a.e.y, a.f.x, a.f.y, a.g.x, a.g.y);
            }
        }
        u(a) {
            let b = 0;
            let c = a.b.count;
            let d = a.b;
            let e = this.aa;
            let f = this.aa;
            let g = this.aa;
            let h = this.b;
            while (b < c) {
                if (b + 1 < c && b + 2 < c) {
                    e = d._inner[b];
                    f = d._inner[b + 1];
                    g = d._inner[b + 2];
                    this.j.bezierCurveTo(e.x, e.y, f.x, f.y, g.x, g.y);
                    if (h) {
                        this.z(this.aa.x, this.aa.y, e.x, e.y, f.x, f.y, g.x, g.y);
                        this.aa = g;
                    }
                }
                b = b + 3;
            }
            this.aa = g;
        }
        y(a, b, c, d, e) {
            let f = new List$1(Point_$type, 0);
            f.add(a);
            f.add({ $type: Point_$type, x: a.x + Math.cos(b) * d, y: a.y + Math.sin(b) * d });
            f.add({ $type: Point_$type, x: a.x + Math.cos(c) * d, y: a.y + Math.sin(c) * d });
            let g = Math.PI * 2;
            let h = Math.PI / 2;
            let i = Math.PI;
            let j = Math.PI * 3 / 2;
            while (b < 0) {
                b += g;
            }
            while (b > g) {
                b -= g;
            }
            while (c < 0) {
                c += g;
            }
            while (c > g) {
                c -= g;
            }
            if (e) {
                if ((0 > c && 0 < b) || (g > c && g < b) || (b < c)) {
                    f.add({ $type: Point_$type, x: a.x + Math.cos(0) * d, y: a.y + Math.sin(0) * d });
                }
                if (h > c && h < b) {
                    f.add({ $type: Point_$type, x: a.x + Math.cos(h) * d, y: a.y + Math.sin(h) * d });
                }
                if (i > c && i < b) {
                    f.add({ $type: Point_$type, x: a.x + Math.cos(i) * d, y: a.y + Math.sin(i) * d });
                }
                if (j > c && j < b) {
                    f.add({ $type: Point_$type, x: a.x + Math.cos(j) * d, y: a.y + Math.sin(j) * d });
                }
            }
            else {
                if ((0 > b && 0 < c) || (g > b && g < c) || (c < b)) {
                    f.add({ $type: Point_$type, x: a.x + Math.cos(0) * d, y: a.y + Math.sin(0) * d });
                }
                if (h > b && h < c) {
                    f.add({ $type: Point_$type, x: a.x + Math.cos(h) * d, y: a.y + Math.sin(h) * d });
                }
                if (i > b && i < c) {
                    f.add({ $type: Point_$type, x: a.x + Math.cos(i) * d, y: a.y + Math.sin(i) * d });
                }
                if (j > b && j < c) {
                    f.add({ $type: Point_$type, x: a.x + Math.cos(j) * d, y: a.y + Math.sin(j) * d });
                }
            }
            let k = 1.7976931348623157E+308;
            let l = 1.7976931348623157E+308;
            let m = -1.7976931348623157E+308;
            let n = -1.7976931348623157E+308;
            for (let o = 0; o < f.count; o++) {
                let p = f._inner[o];
                k = Math.min(k, p.x);
                l = Math.min(l, p.y);
                m = Math.max(m, p.x);
                n = Math.max(n, p.y);
            }
            this.h = Math.min(this.h, k);
            this.i = Math.min(this.i, l);
            this.f = Math.max(this.f, m);
            this.g = Math.max(this.g, n);
            this.c = true;
        }
        n(a) {
            let b = this.aa;
            let c = a.e;
            if (a.f.width != a.f.height) {
                this.j.save();
                this.j.scale(a.f.width / a.f.height, 1);
                b = { $type: Point_$type, x: b.x * (a.f.height / a.f.width), y: b.y };
                c = { $type: Point_$type, x: c.x * (a.f.height / a.f.width), y: c.y };
            }
            let d = a.d == 0;
            let e = CoreGeometryUtil.c(b, c, a.f.height, d, a.b);
            let f = Math.atan2(b.y - e.y, b.x - e.x);
            let g = Math.atan2(c.y - e.y, c.x - e.x);
            let h = (Math.abs(g - f) < Math.PI);
            if (a.b == h) {
                if (f < g) {
                    f += 2 * Math.PI;
                }
                else {
                    g += 2 * Math.PI;
                }
            }
            if (!isNaN_(e.x) && !isNaN_(e.y) && !isNaN_(a.f.height) && !isNaN_(f) && !isNaN_(g)) {
                this.j.arc(e.x, e.y, a.f.height, f, g, d);
                if (this.b) {
                    this.y(e, f, g, a.f.height, d);
                }
            }
            this.aa = a.e;
            if (a.f.width != a.f.height) {
                this.j.restore();
            }
        }
        s(a) {
            let b = a.c.x;
            let c = a.c.y;
            this.j.lineTo(b, c);
            this.aa = a.c;
            if (this.b) {
                let d = this.f;
                let e = this.g;
                let f = this.h;
                let g = this.i;
                this.h = b < f ? b : f;
                this.i = c < g ? c : g;
                this.f = b > d ? b : d;
                this.g = c > e ? c : e;
                this.c = true;
            }
        }
        v(a) {
            let b = a._points;
            let c = b.count;
            if (this.b) {
                let d = this.h;
                let e = this.i;
                let f = this.f;
                let g = this.g;
                let h;
                let i;
                for (let j = 0; j < c; j++) {
                    h = b._inner[j].x;
                    i = b._inner[j].y;
                    this.j.lineTo(h, i);
                    d = h < d ? h : d;
                    e = i < e ? i : e;
                    f = h > f ? h : f;
                    g = i > g ? i : g;
                }
                this.h = d;
                this.i = e;
                this.f = f;
                this.g = g;
                this.c = true;
            }
            else {
                for (let k = 0; k < c; k++) {
                    this.j.lineTo(b._inner[k].x, b._inner[k].y);
                }
            }
            this.aa = a._points._inner[c - 1];
        }
        w(a) {
            this.j.rect(a.e.left, a.e.top, a.e.width, a.e.height);
            if (this.b) {
                let b = a.e;
                let c = this.h;
                let d = this.i;
                let e = this.f;
                let f = this.g;
                let g = b.left;
                let h = b.right;
                let i = b.top;
                let j = b.bottom;
                this.h = g < c ? g : c;
                this.i = i < d ? i : d;
                this.f = h > e ? h : e;
                this.g = j > f ? j : f;
                this.c = true;
            }
        }
        r(a) {
            this.j.moveTo(a.d.x, a.d.y);
            this.j.lineTo(a.c.x, a.c.y);
            if (this.b) {
                let b = a.d;
                let c = a.c;
                let d = this.h;
                let e = this.i;
                let f = this.f;
                let g = this.g;
                let h = b.x < c.x ? b.x : c.x;
                let i = b.x > c.x ? b.x : c.x;
                let j = b.y < c.y ? b.y : c.y;
                let k = b.y > c.y ? b.y : c.y;
                this.h = h < d ? h : d;
                this.i = j < e ? j : e;
                this.f = i > f ? i : f;
                this.g = k > g ? k : g;
                this.c = true;
            }
        }
        h$u(a) {
            if (a._visibility == 0 && a.al != null) {
                if (a._opacity < 1 || this.e < 1) {
                    this.j.globalAlpha = (a._opacity * this.e);
                }
                let def_ = this.m;
                let con_ = this.j;
                con_.textAlign = def_;
                this.j.fillStyle = a.ao != null ? a.ao._fill : null;
                if (a.ag) {
                    this.j.textBaseline = "alphabetic";
                    this.j.fillText(a.al, a.n, a.o + a.ah);
                }
                else {
                    this.j.textBaseline = "top";
                    this.j.fillText(a.al, a.n, a.o);
                }
                if (a._opacity < 1 || this.e < 1) {
                    this.j.globalAlpha = 1;
                }
            }
        }
        h$v(a, b, c) {
            if (a._visibility == 0) {
                if (a._opacity < 1 || this.e < 1) {
                    this.j.globalAlpha = (a._opacity * this.e);
                }
                let d = b.left + b.width / 2;
                let e = a.al.split(' ');
                this.j.fillStyle = a.ao._fill;
                this.j.textBaseline = "top";
                this.j.textAlign = "center";
                let f = b.width;
                let g = b.height;
                let h = b.top;
                let i = "";
                for (let j = 0; j < e.length; j++) {
                    let k = i + e[j];
                    let l = this.j.measureText(k);
                    if (l.width > f) {
                        if (i != null) {
                            this.j.fillText(i, d, h);
                        }
                        i = "";
                        h = h + c;
                    }
                    i = i + e[j] + " ";
                }
                if (i != null) {
                    this.j.fillText(i, d, h);
                }
                if (a._opacity < 1 || this.e < 1) {
                    this.j.globalAlpha = 1;
                }
            }
        }
        h$r(a) {
            if (a.an == null || a.an.count < 1) {
                return;
            }
            this.j.beginPath();
            this.j.globalAlpha = (a._opacity * this.e);
            if (a.ai != null) {
                let b = new Array(a.ai.count);
                for (let c = 0; c < a.ai.count; c++) {
                    b[c] = a.ai._inner[c];
                }
                this.j.setLineDash(b);
            }
            else {
                this.j.setLineDash(new Array(0));
            }
            let d = a.an;
            let e = d._inner[0];
            let f = a._fill;
            let g = a._stroke;
            this.b = (f != null && f.isGradient) || (g != null && g.isGradient);
            if (this.b) {
                let h = 1.7976931348623157E+308;
                let i = -1.7976931348623157E+308;
                let j = 1.7976931348623157E+308;
                let k = -1.7976931348623157E+308;
                let l = e.x;
                let m = e.y;
                h = l < h ? l : h;
                j = m < j ? m : j;
                i = l > i ? l : i;
                k = m > k ? m : k;
                this.j.moveTo(l, m);
                for (let n = 1; n < d.count; n++) {
                    l = d._inner[n].x;
                    m = d._inner[n].y;
                    this.j.lineTo(l, m);
                    h = l < h ? l : h;
                    j = m < j ? m : j;
                    i = l > i ? l : i;
                    k = m > k ? m : k;
                }
                this.j.closePath();
                this.h = h;
                this.i = j;
                this.f = i;
                this.g = k;
            }
            else {
                this.j.moveTo(e.x, e.y);
                for (let o = 1; o < d.count; o++) {
                    this.j.lineTo(d._inner[o].x, d._inner[o].y);
                }
                this.j.closePath();
            }
            if (f != null) {
                if (f.isGradient) {
                    this.j.fillStyle = this.l(f, this.h, this.i, this.f, this.g, a.ad, false);
                }
                else {
                    this.j.fillStyle = f._fill;
                }
                this.j.fill();
            }
            if (g != null) {
                if (g.isGradient) {
                    this.j.strokeStyle = this.l(g, this.h, this.i, this.f, this.g, a.ad, true);
                }
                else {
                    this.j.strokeStyle = g._fill;
                }
                this.j.lineWidth = a.ad;
                this.j.stroke();
            }
            this.j.globalAlpha = 1;
            if (a.ai != null) {
                this.j.setLineDash(new Array(0));
            }
        }
        h$s(a) {
            if (a.an == null || a.an.count < 1) {
                return;
            }
            this.j.beginPath();
            this.j.globalAlpha = (a._opacity * this.e);
            if (a.ai != null) {
                let b = new Array(a.ai.count);
                for (let c = 0; c < a.ai.count; c++) {
                    b[c] = a.ai._inner[c];
                }
                this.j.setLineDash(b);
            }
            else {
                this.j.setLineDash(new Array(0));
            }
            let d = a.an;
            let e = d._inner[0];
            let f = a._fill;
            let g = a._stroke;
            this.b = (f != null && f.isGradient) || (g != null && g.isGradient);
            if (this.b) {
                let h = 1.7976931348623157E+308;
                let i = -1.7976931348623157E+308;
                let j = 1.7976931348623157E+308;
                let k = -1.7976931348623157E+308;
                let l = e.x;
                let m = e.y;
                h = l < h ? l : h;
                j = m < j ? m : j;
                i = l > i ? l : i;
                k = m > k ? m : k;
                this.j.moveTo(l, m);
                for (let n = 1; n < d.count; n++) {
                    l = d._inner[n].x;
                    m = d._inner[n].y;
                    this.j.lineTo(l, m);
                    h = l < h ? l : h;
                    j = m < j ? m : j;
                    i = l > i ? l : i;
                    k = m > k ? m : k;
                }
                this.h = h;
                this.i = j;
                this.f = i;
                this.g = k;
            }
            else {
                this.j.moveTo(e.x, e.y);
                for (let o = 1; o < d.count; o++) {
                    this.j.lineTo(d._inner[o].x, d._inner[o].y);
                }
            }
            if (f != null) {
                if (f.isGradient) {
                    this.j.fillStyle = this.l(f, this.h, this.i, this.f, this.g, a.ad, false);
                }
                else {
                    this.j.fillStyle = f._fill;
                }
                this.j.fill();
            }
            if (g != null) {
                if (g.isGradient) {
                    this.j.strokeStyle = this.l(g, this.h, this.i, this.f, this.g, a.ad, true);
                }
                else {
                    this.j.strokeStyle = g._fill;
                }
                this.j.lineWidth = a.ad;
                this.j.stroke();
            }
            this.j.globalAlpha = 1;
            if (a.ai != null) {
                this.j.setLineDash(new Array(0));
            }
        }
        h$n(a, b) {
            if (b._visibility == 1) {
                return;
            }
            if ((b._opacity != 1 || this.e != 1) && !a.isHitTestRender) {
                this.j.globalAlpha = (b._opacity * this.e);
            }
            let c = b.ah;
            if (c != null && c.render != null) {
                a.context = this.j;
                a.xPosition = b.n;
                a.yPosition = b.o;
                a.data = b.content;
                c.render(a);
            }
            this.j.globalAlpha = 1;
        }
        h$h(a) {
            if (typeCast(TransformGroup.$, a) !== null) {
                let b = a;
                for (let c = b.j.count - 1; c >= 0; c--) {
                    let d = b.j._inner[c];
                    this.h$h(d);
                }
            }
            else if (typeCast(TranslateTransform.$, a) !== null) {
                let e = a;
                this.j.translate(e.j, e.k);
            }
            else if (typeCast(RotateTransform.$, a) !== null) {
                let f = a;
                let g = f.j * Math.PI / 180;
                let h = Math.cos(g);
                let i = Math.sin(g);
                let j = f.k * (1 - h) + f.l * i;
                let k = f.l * (1 - h) - f.k * i;
                this.j.transform(h, i, i * -1, h, j, k);
            }
            else if (typeCast(ScaleTransform.$, a) !== null) {
                let l = a;
                this.j.transform(l.l, 0, 0, l.m, l.j - l.l * l.j, l.k - l.m * l.k);
            }
        }
        h$p(a) {
            if (a._visibility != 0) {
                return;
            }
            this.j.beginPath();
            this.j.globalAlpha = (a._opacity * this.e);
            if (a.ai != null) {
                let b = new Array(a.ai.count);
                for (let c = 0; c < a.ai.count; c++) {
                    b[c] = a.ai._inner[c];
                }
                this.j.setLineDash(b);
            }
            else {
                this.j.setLineDash(new Array(0));
            }
            this.j.moveTo(a.an, a.ap);
            this.j.lineTo(a.ao, a.aq);
            if (this.b) {
                this.h = 1.7976931348623157E+308;
                this.f = -1.7976931348623157E+308;
                this.i = 1.7976931348623157E+308;
                this.g = -1.7976931348623157E+308;
                let d = this.h;
                let e = this.i;
                let f = this.f;
                let g = this.g;
                let h = a.an < a.ao ? a.an : a.ao;
                let i = a.an > a.ao ? a.an : a.ao;
                let j = a.ap < a.aq ? a.ap : a.aq;
                let k = a.ap > a.aq ? a.ap : a.aq;
                this.h = h < d ? h : d;
                this.i = j < e ? j : e;
                this.f = i > f ? i : f;
                this.g = k > g ? k : g;
            }
            let l = a._fill;
            let m = a._stroke;
            if (l != null) {
                if (l.isGradient) {
                    this.j.fillStyle = this.l(l, this.h, this.i, this.f, this.f, a.ad, false);
                }
                else {
                    this.j.fillStyle = l._fill;
                }
                this.j.fill();
            }
            if (m != null) {
                if (m.isGradient) {
                    this.j.strokeStyle = this.l(m, this.h, this.i, this.f, this.f, a.ad, true);
                }
                else {
                    this.j.strokeStyle = a._stroke._fill;
                }
                this.j.lineWidth = a.ad;
                this.j.stroke();
            }
            this.j.globalAlpha = 1;
            if (a.ai != null) {
                this.j.setLineDash(new Array(0));
            }
        }
        h$ac(a) {
            this.j.beginPath();
            this.j.rect(a.left, a.top, a.width, a.height);
            this.j.clip();
        }
        h$x() {
            this.j.save();
        }
        h$w() {
            this.j.restore();
        }
        h$y(a, b) {
            this.j.scale(a, b);
        }
        h$ad(a, b) {
            this.j.translate(a, b);
        }
        h$i(a, b, c, d) {
            this.j.clearRect(a, b, c, d);
        }
        h$k(a, b, c, d, e, f) {
            if (b != 1) {
                this.j.globalAlpha = (b * this.e);
            }
            this.j.drawImage(a, c, d, e, f);
            if (b != 1) {
                this.j.globalAlpha = 1;
            }
        }
        h$l(a, b, c, d, e, f, g, h, i, j) {
            if (b != 1) {
                this.j.globalAlpha = (b * this.e);
            }
            this.j.drawImage(a, c, d, e, f, g, h, i, j);
            if (b != 1) {
                this.j.globalAlpha = 1;
            }
        }
        h$a(a, b) {
            let c = this.j.getImageData(a, b, 1, 1);
            let d = new Array(4);
            d[0] = c.data[0];
            d[1] = c.data[1];
            d[2] = c.data[2];
            d[3] = c.data[3];
            return d;
        }
        h$f() {
            return this.j.font;
        }
        h$b() {
            return this.a;
        }
        h$z(a) {
            if (this.j.font != a) {
                this.j.font = a;
            }
        }
        h$aa(a) {
            this.a = a;
            if (a != null) {
                this.d = a.f;
            }
            let b = a != null ? a.fontString : null;
            if (this.j.font != b) {
                this.j.font = b;
            }
        }
        h$ae(a, b, c) {
            this.j.textBaseline = "alphabetic";
            let d = this.j.measureText(a);
            let metrics_ = d;
            let e = b;
            let f = new TextFontMetrics();
            if ((metrics_.actualBoundingBoxAscent !== undefined)) {
                f.a = (metrics_.actualBoundingBoxAscent);
                e = (metrics_.actualBoundingBoxAscent + metrics_.actualBoundingBoxDescent);
                if (c) {
                    let g = (b - e);
                    let h = g / 2;
                    f.a += h;
                    e += g;
                }
            }
            f.c = d.width;
            f.b = e;
            return f;
        }
        h$c(a) {
            let b = this.j.measureText(a);
            return b.width;
        }
        h$ab(a) {
            this.e = a;
        }
        h$g(shape_, style_) {
            if (style_ == null) {
                return;
            }
            let fillColor_ = null;
            let strokeColor_ = null;
            let strokeThickness_ = NaN;
            let opacity_ = NaN;
            let s_ = style_;
            if (s_.fill) {
                fillColor_ = s_.fill;
            }
            ;
            if (s_.stroke) {
                strokeColor_ = s_.stroke;
            }
            ;
            if (s_.strokeThickness) {
                strokeThickness_ = s_.strokeThickness;
            }
            ;
            if (s_.opacity) {
                opacity_ = s_.opacity;
            }
            ;
            if (fillColor_ != null) {
                shape_._fill = ((() => {
                    let $ret = new Brush();
                    $ret.fill = fillColor_;
                    return $ret;
                })());
            }
            if (strokeColor_ != null) {
                shape_._stroke = ((() => {
                    let $ret = new Brush();
                    $ret.fill = strokeColor_;
                    return $ret;
                })());
            }
            if (strokeThickness_ != undefined && !isNaN_(strokeThickness_)) {
                shape_.ad = strokeThickness_;
            }
            if (!isNaN_(opacity_)) {
                shape_._opacity = opacity_;
            }
        }
        h$m(a, b, c, d) {
            this.j.shadowColor = a;
            this.j.shadowBlur = b;
            this.j.shadowOffsetX = c;
            this.j.shadowOffsetY = d;
        }
        h$j() {
            this.j.shadowColor = "rgba(0,0,0,0)";
            this.j.shadowBlur = 0;
            this.j.shadowOffsetX = 0;
            this.j.shadowOffsetY = 0;
        }
    }
    CanvasViewRenderer.$t = /*@__PURE__*/ markType(CanvasViewRenderer, 'CanvasViewRenderer', Base.$, [IRenderer_$type]);
    return CanvasViewRenderer;
})();
