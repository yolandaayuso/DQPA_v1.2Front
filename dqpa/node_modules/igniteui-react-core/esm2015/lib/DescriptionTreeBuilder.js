/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { Base, String_$type, typeCast, Array_$type, markType } from "./type";
import { List$1 } from "./List$1";
import { HashSet$1 } from "./HashSet$1";
import { DescriptionTreeNode } from "./DescriptionTreeNode";
import { Description } from "./Description";
/**
 * @hidden
 */
export let DescriptionTreeBuilder = /*@__PURE__*/ (() => {
    class DescriptionTreeBuilder extends Base {
        static c(item_) {
            let propertyKey_ = null;
            let ret_ = new List$1(String_$type, 0);
            let seen_ = new HashSet$1(String_$type, 0);
            let exclusions_ = {};
            let seen = new Set();
            let comp = item_;
            while (comp = (comp.prototype || Object.getPrototypeOf(comp))) {
                if (comp == Base.prototype) {
                    break;
                }
                let props = Object.getOwnPropertyNames(comp.constructor.prototype);
                for (let i = 0; i < props.length; i++) {
                    if (!seen.has(props[i])) {
                        seen.add(props[i]);
                        ret_.add(props[i]);
                    }
                }
            }
            ;
            return ret_;
        }
        static createTree(a, description_) {
            return DescriptionTreeBuilder.createTreeWithOptions(a, description_, false);
        }
        static createTreeWithOptions(a, description_, b) {
            let c = new DescriptionTreeNode();
            if (description_ == null) {
                return null;
            }
            let d = DescriptionTreeBuilder.c(description_);
            for (let e = 0; e < d.count; e++) {
                let key_ = d._inner[e];
                if (key_.toLowerCase() != "type" && !description_.b(DescriptionTreeBuilder.d(key_))) {
                    continue;
                }
                let f = description_[key_];
                if (typeCast(Description.$, f) !== null) {
                    let g = DescriptionTreeBuilder.createTree(a, f);
                    f = g;
                }
                if (typeCast(Array_$type, f) !== null) {
                    let h = f;
                    let i = new Array(h.length);
                    for (let j = 0; j < i.length; j++) {
                        let k = h[j];
                        if (typeCast(Description.$, k) !== null) {
                            let l = DescriptionTreeBuilder.createTree(a, k);
                            i[j] = l;
                        }
                        else {
                            i[j] = k;
                        }
                    }
                    f = i;
                }
                if (key_.toLowerCase() == "type") {
                    c.i = f;
                }
                c.j(DescriptionTreeBuilder.d(key_), f);
            }
            if (c.c("type")) {
                let m = c.a("type").b;
                let n = c.f();
                for (let o = 0; o < n.count; o++) {
                    let p = n._inner[o];
                    p.a = a.getMetadata(m, p.c);
                }
            }
            return c;
        }
        static d(key_) {
            if (key_ == null) {
                return null;
            }
            return key_.substr(0, 1).toUpperCase() + key_.substr(1);
        }
    }
    DescriptionTreeBuilder.$t = /*@__PURE__*/ markType(DescriptionTreeBuilder, 'DescriptionTreeBuilder');
    return DescriptionTreeBuilder;
})();
